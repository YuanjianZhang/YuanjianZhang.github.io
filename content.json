{"pages":[{"title":"关于","text":"这是一个用来记录生活为主的Blog,请不要转载。声明：本博客中部分图片、文章来源于网络，版权归原作者所有， 如有侵权请联系删除。Email：selectitemc@gmail.com","link":"/about/index.html"},{"title":"other","text":"","link":"/other/index.html"}],"posts":[{"title":"在hexo上添加Live 2D看板娘","text":"博客美化—给Hexo博客添加萌萌的康娜（Kanna） 前言 在逛V站时，看到了一个帖子，然后就被她的看板娘吸引，但是想我也算是有Blog的人(虽然才刚建)，我是不是也可以弄一个呢，说干就干，立马开始捣鼓起来。 过程开始 因为看板娘在WordPress、Typecho、Typecho等用户群体大的博客上应用广泛，所以Live2d 看板娘在WordPress这些博客上能被更好的应用，在网上找的的教程大部分也是关于WordPress等的教程，所以我自己也是懵懵懂懂的去实现这个功能，这篇文章仅记录过程。 经过 在查看下列几篇文章后,开始动手搭建 在Hexo博客上添加可爱的Live 2D模型hexo 添加live2d看板动画 安装模块 hexo博客根目录选择cmd命令窗口或者git bash 输入以下代码，安装插件 1npm install --save hexo-helper-live2d 下载模型1npm install live2d-widget-model-shizuku 配置 打开个人Hexo博客文件根目录下的 _config.yml 文件，在最后添加一下代码 _config.yml12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true再打开cmd键入hexo g -d 就大功告成了😁🎉🎉🎉 DIY资料 资源模型插件:hexo-helper-live2d模型插件作者各种模型包展示hexo模型插件作者各种模型包合集Live2d模型资源：梦象-Live2D 模型资源收集站 适用于WordPress、Typecho、Typecho等强烈推荐：为你的博客博客/网页添加Live2d二次元老婆的插件/手动方法给博客添加能动的看板娘(Live2D)-关于模型的二三事网页添加 Live2D 看板娘","link":"/2019/03/25/%E5%9C%A8hexo%E4%B8%8A%E6%B7%BB%E5%8A%A0Live-2D/"},{"title":"在hexo文章里使用emoji🤔","text":"记录如何然hexo文章支持emojiHexo 默认的 markdown 渲染引擎不支持将 Github emoji 渲染到静态的 html 页面中，我们换一个支持 emoji 的引擎，再增加一个 emoji 插件即可.","link":"/2019/03/25/%E5%9C%A8hexo%E6%96%87%E7%AB%A0%E9%87%8C%E4%BD%BF%E7%94%A8emoji/"},{"title":"各种软件版本号的含义","text":"今天在逛spring的文档repo时， 常见软件版本编辑软件版本：包含两种不同含义（1）为满足不同用户的不同使用要求，如适用于不同运行环境或不同平台的系列产品。（2）软件产品投入使用以后，经过一段时间运行提出了变更的要求，需要做较大的修正或纠错，增强功能或提高性能。 Alpha版（内部测试版）：Alpha版本通常会送交到开发软件的组织或社群中的各个软件测试者，用作内部测试。在市场上，越来越多公司会邀请外部的客户或合作伙伴参与其软件的Alpha测试阶段。这令软件在此阶段有更大的可用性测试。在测试的第一个阶段中，开发者通常会进行白盒测试。其他测试会在稍后时间由其他测试团体以黑盒或灰盒技术进行，不过有时会同时进行。 Beta版（外部测试版）：软件开发公司为对外宣传，将非正式产品免费发送给具有典型性的用户，让用户测试该软件的不足之处及存在问题，以便在正式发行前进一步改进和完善 。一般可通过Internet免费下载，也可以向软件公司索取。Beta版本是第一个对外公开的软件版本，是由公众参与的测试阶段。一般来说，Beta包含所有功能，但可能有一些已知问题和较轻微的臭虫（Bug）。Beta版本的测试者通常是开发软件的组织的客户，他们会以免费或优惠价钱得到软件，但会成为组织的免费测试者。Beta版本主要测试产品的支援和市场反应（在邀请Beta用户时）等。 Demo版（演示版）：主要是演示正式软件的部分功能，用户可以从中得知软件的基本操作，为正式产品的发售扩大影响。如果是游戏的话，则只有一两个关卡可以玩。该版本也可以从Internet上免费下载。Enhanced版（增强版或加强版）：如果是一般软件，一般称作“增强版”，会加入一些实用的新功能。如果是游戏，一般称作“加强版”，会加入一些新的游戏场景和游戏情节等。这是正式发售的版本。 Free版（自由版）：这一般是个人或自由软件联盟组织的成员制作的软件，希望免费给大家使用，没有版权，一般也是通过Internet免费下载。Full Version版（完全版）：也就是正式版，是最终正式发售的版本。 Shareware版（共享版）：有些公司为了吸引客户，对于他们制作的某些软件，可以让用户通过Internet免费下载的方式获取。不过，此版本软件多会带有一些使用时间或次数的限制，但可以利用在线注册或电子注册成为正式版用户。 Release版（发行版）：稳定的发行版，可从Internet上免费下载。Release Candidate（简称RC）指可能成为最终产品的版本，如果没有再出现问题则可释出正式版本。在此阶段，产品包含所有功能亦不会出现严重问题。通常此阶段的产品是接近完整的。微软公司很多时会使用此名称。在1990年代，苹果电脑把在这阶段的产品称为“Golden Master”，而最后的Golden Master为正式版本。这阶段亦称Gamma（更后期的称为Delta，及其后的希腊字母）。 Upgrade版（升级版）：当你有某个软件以前的正式版本时，可以购买升级版，将你的软件升级为最新版。升级后的软件与正式版在功能上相同，但价格会低些，这主要是为了给原有的正版用户提供优惠。 Retail版 零售版，一般只针对个人的功能不是很全的版本，价格比较低，升级时间也有限制。Cardware版 属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。Plus版 属增强版，不过这种大部分是在程序界面及多媒体功能上增强。Preview版 预览版，软件作者为了满足那些对新版本很关注的人，发布的可以看到大部分功能的测试软件。Corporation &amp; Enterprise版 企业版，只针对企业发布的全功能版本，价格比较昂贵，服务非常齐全。Standard版 标准版，软件商推荐大家使用的版本，这种版本一般比较稳定，BUG少。Mini版 迷你版也叫精简版只有最基本的功能，为那些想节省硬盘空间或者不追求华丽的人准备的。Premium——超值版Professional——专业版Express——简易版（比如Outlook express 和outlook 相比，前者更精简；Sql Server Express版表示免费精简版）Deluxe——豪华版Regged——已注册版CN——简体中文版CHT——繁体中文版EN——英文版Multilanguage——多语言版Rip 是指从原版文件（一般是指光盘或光盘镜像文件）直接将有用的内容（核心内容）分离出来，剔除无用的文档，例如PDF说明文件啊，视频演示啊之类的东西，也可以算做是精简版吧…但主要内容功能是一点也不能缺少的！另：DVDrip是指将视频和音频直接从DVD光盘里以文件方式分离出来。trial 试用版（含有某些限制，如时间、功能，注册后也有可能变为正式版）RC 版 是 Release Candidate 的缩写，意思是发布倒计时，该版本已经完成全部功能并清除大部分的BUG。到了这个阶段只会除BUG，不会对软件做任何大的更改。RTM 版 这基本就是最终的版本，英文是 Release To Manufacture，意思是发布到生产商。版本号编辑V（Version）即版本，通常用数字表示版本号。（如：EVEREST Ultimate v4.20.1188 Beta） Build：用数字或日期标示版本号的一种方式。（如：VeryCD eMule v0.48a Build 071112）SP：Service Pack，升级包。（如：WindowsXP SP2/Vista SP1）授权和功能划分： Trial：试用版，通常都有时间限制，有些试用版软件还在功能上做了一定的限制。可注册或购买成为正式版Unregistered未注册版，通常没有时间限制，在功能上相对于正式版做了一定的限制。可注册或购买成为正式版。Demo：演示版，仅仅集成了正式版中的几个功能，不能升级成正式版。Lite：精简版。Full version：完整版，属于正式版。 语言划分编辑SC：Simplified Chinese简体中文版。CN：简体中文版GBK：简体中文汉字内码扩展规范版。TC：Traditional Chinese繁体中文版。CHT：繁体中文版BIG5：繁体中文大五码版。EN：英文版Multilanguage：多语言版UTF8： Unicode Transformation Format 8 bit，对现有的中文系统不是好的解决方案。 开发阶段划分编辑α（Alpha）版：内测版，内部交流或者专业测试人员测试用。Bug较多，普通用户最好不要安装。β（Beta）版：公测版，专业爱好者大规模测试用，存在一些缺陷，该版本也不适合一般用户安装。γ（Gamma）版：相当成熟的测试版，与即将发行的正式版相差无几。RC版：Release Candidate。RC版。是Release Candidate的缩写，意思是发布倒计时，候选版本，处于Gamma阶段，该版本已经完成全部功能并清除大部分的BUG。到了这个阶段只会除BUG，不会对软件做任何大的更改。从Alpha到Beta再到Gamma是改进的先后关系，但RC1、RC2往往是取舍关系。SR版：Service Release的缩写，修正版或更新版，修正了正式版推出后发现的Bug。Final版：正式版。 其他版本编辑Enhance：增强版或者加强版，属于正式版Free：自由版（免费版）Release：发行版Upgrade：升级版Retail：零售版Cardware：属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。/SPlus：属增强版，不过这种大部分是在程序界面及多媒体功能上增强。Preview：预览版Corporation&amp;Enterprise：企业版Standard：标准版Mini：迷你版也叫精简版只有最基本的功能Professional/pro：专业版Express：特别版Deluxe： 豪华版Regged：已注册版Rip： 是指从原版文件（一般是指光盘或光盘镜像文件）直接将有用的内容（核心内容）分离出来，剔除无用的文档，例如PDF说明文件啊，视频演示啊之类的东西，也可以算做是精简版吧…但主要内容功能是一点也不能缺少的！另：DVDrip是指将视频和音频直接从DVD光盘里以文件方式分离出来。RTM：这基本就是最终的版本，英文是Release To Manufactur，意思是发布到生产商。OEM：Original Equipment Manufacturer，是给电脑生产厂的版本，软件发行商于电脑生产厂家的定制版本。FPP：Full Packaged Product（FPP）/Retail，就是零售版（盒装软件），这种产品的光盘的卷标都带有“FPP”字样，比如英文WXP Pro的FPP版本的光盘卷标就是WXPFPP_EN，其中WX表示是Windows XP，P是Professional（H是Home），FPP表明是零售版本，EN是表明是英语。获得途径除了在商店购买之外，某些MSDN用户也可以得到。VOL：Volume Licensing for Organizations（VLO），团体批量许可证（大量采购授权合约），这是为团体购买而制定的一种优惠方式。这种产品的光盘的卷标都带有“VOL”字样，取“Volume”前3个字母，以表明是批量，比如英文WXP Pro的VOL版本的光盘卷标就是WXPVOL_EN，其中WX表示是Windows XP，P是Professional（VOL没有Home版本），VOL表明是团体批量许可证版本，EN是表明是英语。获得途径主要是集团购买，某些MSDN用户也可以得到。","link":"/2019/03/26/%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/"},{"title":"只是一个普通人","text":"","link":"/2019/04/08/%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E4%BA%BA/"},{"title":"ASP.Net MVC action 同时支持Get和Post","text":"项目中遇到一个action，有post和get请求，特此记录方法：在action 上加上 AcceptVerbs标签: 12[AcceptVerbs(HttpVerbs.Get | HttpVerbs.Post)]public ActionResult Index() 转自：https://blog.csdn.net/Helloantoherday/article/details/85007344","link":"/2019/04/10/ASP-Net-MVC-action-%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81Get%E5%92%8CPost/"},{"title":"C#邮件发送问题","text":"转自：C#邮件发送问题（一）C#邮件发送问题（二）","link":"/2019/04/10/C#%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98/"},{"title":"C# ASP.NET发送电子邮件System.Net.Mail","text":"本文转载自-https://www.cnblogs.com/Jeremy2001/p/6870175.html，侵删。 1.补充知识 （1）POP3和SMTP服务器是什么？ 简单点来说：POP3 用于接收电子邮件 ，SMTP 用于发送电子邮件。 （1）POP3具体指什么？ POP3(Post Office Protocol 3)即邮局协议的第3个版本，它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。它是因特网电子邮件的第一个离线协议标准，POP3协议允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上，同时根据客户端的操作删除或保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。POP3协议是TCP/IP协议族中的一员，,由RFC 1939 定义 （2）SMTP具体是指什么？ SMTP的全称是”Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。 2.System.Net.Mail 使用ASP.NET发送电子邮件，需要引用System.Net.Mail命名空间。System.Net.Mail 命名空间包含用于将电子邮件发送到简单邮件传输协议 (SMTP) 服务器进行传送的类。 （1）命名空间下有三个比较主要的类： MailMessage:提供属性和方法来创建一个邮件消息对象，即邮件内容。 Attachment:提供属性和方法来创建一个邮件附件对象，即邮件附件。 SmtpClient:将电子邮件传输到您指定用于邮件传送的 SMTP 主机。 （2）MailMessage类： From：发送邮件的地址To：接收邮件的地址Subject：邮件的标题Priority：邮件的优先级（分别为为High,Low,Normal）Attachments：电子邮件的数据的附件集合Bcc：密送地址Cc：抄送地址Body：邮件正文SubjectEncoding：电子邮件的主题内容使用的编码 IsBodyHtml：邮件正文是否为 Html 格式的值 详细参考：MailMessage （3）Attachment类： 详细参考：Attachment （4）SmtpClient类： DeliveryMethod：指定如何处理待发的电子邮件 Host：SMTP 事务的主机的名称或 IP 地址 Credentials：设置用于验证发件人身份的凭据 详细参考：SmtpClient 3.ASP.NET发送邮件两种方式 （1）通过邮件服务提供商的SMTP来发送邮件 首先需要注册对应服务提供商免费邮箱，因为你要使用邮件服务提供商的SMTP，他们需要对身份进行验证，这样可以避免产生大量的垃圾邮件。 有三个是重要的信息：SMTP服务器、用户名、密码。从网上收集了几个类，可以参考下。 123456789101112131415161718192021222324252627282930313233343536373839#region/// &lt;summary&gt;/// 发送邮件/// &lt;/summary&gt;/// &lt;param name=\"mailTo\"&gt;要发送的邮箱&lt;/param&gt;/// &lt;param name=\"mailSubject\"&gt;邮箱主题&lt;/param&gt;/// &lt;param name=\"mailContent\"&gt;邮箱内容&lt;/param&gt;/// &lt;returns&gt;返回发送邮箱的结果&lt;/returns&gt;public static bool SendEmail(string mailTo,string mailSubject,string mailContent){ // 设置发送方的邮件信息,例如使用网易的smtp string smtpServer = \"smtp.163.com\"; //SMTP服务器 string mailFrom = \"XXX@163.com\"; //登陆用户名 string userPassword = \"XXX\";//登陆密码 // 邮件服务设置 SmtpClient smtpClient=new SmtpClient(); smtpClient.DeliveryMethod = SmtpDeliveryMethod.Network;//指定电子邮件发送方式 smtpClient.Host = smtpServer; //指定SMTP服务器 smtpClient.Credentials = new System.Net.NetworkCredential(mailFrom, userPassword);//用户名和密码 // 发送邮件设置 MailMessage mailMessage = new MailMessage(mailFrom, mailTo); // 发送人和收件人 mailMessage.Subject = mailSubject;//主题 mailMessage.Body = mailContent;//内容 mailMessage.BodyEncoding = Encoding.UTF8;//正文编码 mailMessage.IsBodyHtml = true;//设置为HTML格式 mailMessage.Priority = MailPriority.Low;//优先级 try { smtpClient.Send(mailMessage); // 发送邮件 return true; } catch (SmtpException ex) { return false; }}2）利用本机的SMTP虚拟服务器的SMTP来发送邮件 需要进行SMTP配置，还是第一种简单实用。 4.参考资料：常用邮件服务器 gmail.com:POP3服务器地址:pop.gmail.comSMTP服务器地址:smtp.gmail.com qq.com: POP3服务器地址:pop.qq.comSMTP服务器地址:smtp.qq.com 163.com:POP3服务器地址:pop.163.comSMTP服务器地址:smtp.163.com sina.com: POP3服务器地址:pop3.sina.com.cnSMTP服务器地址:smtp.sina.com.cn yahoo.com:POP3服务器地址:pop.mail.yahoo.comSMTP服务器地址:smtp.mail.yahoo.com sohu.com:POP3服务器地址:pop3.sohu.comSMTP服务器地址:smtp.sohu.com china.com:POP3服务器地址:pop.china.comSMTP服务器地址:smtp.china.com 21cn.com:POP3服务器地址:pop.21cn.comSMTP服务器地址:smtp.21cn.com sina.com: 实例下载","link":"/2019/04/11/C#-ASP.NET%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6System.Net.Mail/"},{"title":"突发奇想：对于人类进化的优胜劣汰","text":"最近实习越来越发现自己","link":"/2019/04/16/%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%EF%BC%9A%E5%AF%B9%E4%BA%8E%E4%BA%BA%E7%B1%BB%E8%BF%9B%E5%8C%96%E7%9A%84%E4%BC%98%E8%83%9C%E5%8A%A3%E6%B1%B0/"},{"title":"彻底清除Github上某个文件的历史（对于误传密码等隐私信息等情况）","text":"Removing sensitive data from a repository","link":"/2019/04/26/%E5%BD%BB%E5%BA%95%E6%B8%85%E9%99%A4Github%E4%B8%8A%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%88%E5%AF%B9%E4%BA%8E%E8%AF%AF%E4%BC%A0%E5%AF%86%E7%A0%81%E7%AD%89%E9%9A%90%E7%A7%81%E4%BF%A1%E6%81%AF%E7%AD%89%E6%83%85%E5%86%B5%EF%BC%89/"},{"title":"Asp.net MVC在Razor中输出Html的两种方式","text":"Razor中所有的Html都会自动编码，这样就不需要我们手动去编码了（安全），但在需要输出Html时就是已经转义过的Html文本了，如下所示： 1234@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\";}@thisTest; 这样在页面输出的文本就是：&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;而不是红色的字体了，要输出红色的字体，有下面常用的两种方式： 1、使用Razor中的Html.Raw（推荐使用这种方式）： 1234@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\";}@Html.Raw(thisTest); 2、使用MvcHtmlString类来实现： 12345@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\"; var thisResult = new MvcHtmlString(thisTest);}@thisResult 或 @(new HtmlString(thisTest))","link":"/2019/05/07/Asp-net-MVC%E5%9C%A8Razor%E4%B8%AD%E8%BE%93%E5%87%BAHtml%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"jQuery的Ajax的dataType设置问题","text":"在Asp.Net MVC的前台页面使用Ajax获取数据，当Ajax方法中设置了dataType: \"json\"后，Ajax无法使用data.ret的方式处理数据。Controller.Json Method (Object)Json(Object) 方法返回的是继承自System.Object的类型值System.Web.Mvc.JsonResult在前台获取到的是object，而不是json字符串 http://www.cnblogs.com/zhangcybb/p/6604380.htmlhttps://docs.microsoft.com/en-us/previous-versions/aspnet/dd504936%28v%3dvs.100%29#see-alsohttps://docs.microsoft.com/en-us/previous-versions/aspnet/dd504936%28v%3dvs.100%29https://docs.microsoft.com/zh-cn/previous-versions/aspnet/dd470569%28v%3dvs.100%29https://www.cnblogs.com/fire-dragon/p/5889400.html","link":"/2019/05/09/jQuery%E7%9A%84Ajax%E7%9A%84dataType%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"},{"title":"SQL语句使用技巧","text":"记录一下自己在使用PL/SQL的编写SQL语句的注意点和技巧 记录工作中遇到的在统计一张数据表中一个数据类型为Char(2) 的字段的值为空的数量时，使用 `select count(1) from table1 where EHR_PAT_GEN = ''`，查询出的结果为0（数据库中数据已经确认有空的）。 然后将语句换成`select count(1) from table1 where EHR_PAT_GEN &lt;&gt; ''`执行后，结果仍然为0，然后查询数据表，发现不为空的的数据为数字时，使用`select count(1) from table1 where EHR_PAT_GEN &gt; 0`查出该字段不为空的数据量。然后百度到char类型是","link":"/2019/05/20/SQL%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"对当今教育的一些感想","text":"今天是2019年5月24日，工作了一段时间后，逐渐发现","link":"/2019/05/24/%E5%AF%B9%E5%BD%93%E4%BB%8A%E6%95%99%E8%82%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/"},{"title":"'nginx缓存页面+cookie后-串会话问题'","text":"https://blog.csdn.net/clevercode/article/details/75145258","link":"/2019/05/31/nginx%E7%BC%93%E5%AD%98%E9%A1%B5%E9%9D%A2-cookie%E5%90%8E-%E4%B8%B2%E4%BC%9A%E8%AF%9D%E9%97%AE%E9%A2%98/"},{"title":"终究还是毕业了","text":"","link":"/2019/06/05/%E7%BB%88%E7%A9%B6%E8%BF%98%E6%98%AF%E6%AF%95%E4%B8%9A%E4%BA%86/"},{"title":"hexo指令列表","text":"为了方便使用hexo，将一些hexo指令记录下来 hexo指令 hexo 提示 hexo 官方文档 Hexo起步安装（-g为全局安装） 1npm install hexo -g 升级（-g为全局升级） 1npm update hexo -g 初始化，生成文件夹为blog 1hexo init blog 安装依赖库 1npm install 简写hexo n \"我的博客\"== hexo new \"我的博客\" #新建文章hexo p== hexo publish #将草稿帖子从_drafts移动到_posts文件夹。hexo g== hexo generate#生成hexo s== hexo server #启动服务预览hexo d == hexo deploy#部署hexo s -g == hexo server --generate#生成静态页面并启动服务预览 生成静态网页后部署到GitHub上 两个命令的作用是相同的hexo g -d == hexo generate --deployhexo d -g == hexo deploy --generate 模板hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate --watch #监视文件变动 hexo提示在CMD中输入hexo help后，获得的命令行列表 1234567891011121314151617181920212223用法: hexo &lt;command&gt;Commands: clean 删除生成的文件和缓存。 config 获取或设置配置 deploy 部署你的网站。 可简写成 `hexo d` generate 生成静态文件。 可简写成 `hexo g` help 获取有关命令的帮助。 init 创建一个新的Hexo文件夹。 list 列出网站的信息 migrate 将您的站点从其他系统迁移到Hexo。 new 创建一个新帖子。 可简写成 `hexo n` publish 将草稿帖子从_drafts移动到_posts文件夹。 render 使用渲染器插件渲染文件。 server 启动服务器。 可简写成 `hexo s` version 显示版本信息。全局选项: --config 指定配置文件而不是使用_config.yml --cwd 指定CWD --debug 显示终端中的所有详细消息 --draft 显示草稿帖子 --safe 禁用所有插件和脚本 --silent 隐藏控制台上的输出 官方文档的一些指令init1hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new1hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1hexo new \"post title with whitespace\" generate1hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 该命令可以简写为 1hexo g publish1hexo publish [layout] &lt;filename&gt; 发表草稿。 server1hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 deploy1hexo deploy 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 该命令可以简写为： 1hexo d render1hexo render &lt;file1&gt; [file2] ... 渲染文件。 参数 描述 -o, --output 设置输出路径 migrate1hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1hexo list &lt;type&gt; 列出网站资料。 version1hexo version 显示 Hexo 版本。 选项安全模式1hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式1hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式1hexo --silent 隐藏终端信息。 自定义配置文件的路径1hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿1hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD1hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。","link":"/2019/06/12/hexo%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A8/"},{"title":"a标签的target的用法","text":"记录一下今天在学习项目时遇到的一个低级问题🙃 HTML&lt;a&gt;标签的target属性 参考地址：http://www.w3school.com.cn/tags/att_a_target.asp 定义和用法&lt;a&gt; 标签的 target 属性规定在何处打开链接文档。 如果在一个 &lt;a&gt; 标签内包含一个 target 属性，浏览器将会载入和显示用这个标签的 href 属性命名的、名称与这个目标吻合的框架或者窗口中的文档。如果这个指定名称或 id 的框架或者窗口不存在，浏览器将打开一个新的窗口，给这个窗口一个指定的标记，然后将新的文档载入那个窗口。从此以后，超链接文档就可以指向这个新的窗口。 打开新窗口 被指向的超链接使得创建高效的浏览工具变得很容易。例如，一个简单的内容文档的列表，可以将文档重定向到一个单独的窗口： 12&lt;a href=\"https://www.bing.com\" target=\"view_window\"&gt;打开一个新的窗口，显示必应的首页HTML文档&lt;/a&gt;&lt;a href=\"https://www.baidu.com\" target=\"view_window\"&gt;在已经打开的窗口上，将必应的文档取代。显示百度的首页HTML文档&lt;/a&gt; 打开一个新的窗口，指向必应的新窗口 在已经打开的窗口上，将必应的文档取代。显示百度的首页HTML文档 当用户第一次选择内容列表中的某个链接时，浏览器将打开一个新的窗口，将它标记为 “view_window”，然后在其中显示希望显示的文档内容。如果用户从这个内容列表中选择另一个链接，且这个 “view_window” 仍处于打开状态，浏览器就会再次将选定的文档载入那个窗口，取代刚才的那些文档。 在整个过程中，这个包含了内容列表的窗口是用户可以访问的。通过单击窗口中的一个连接，可使另一个窗口的内容发生变化。 在框架中打开窗口不用打开一个完整的浏览器窗口，使用 target 更通常的方法是在一个 &lt;frameset&gt; 显示中将超链接内容定向到一个或者多个框架中。可以将这个内容列表放入一个带有两个框架的文档的其中一个框架中，并用这个相邻的框架来显示选定的文档： 12&lt;frame name=\"view\" src=\"\"&gt;&lt;a href=\"https://bing.com\" target=\"view\"&gt;在右边窗口打开必应首页&lt;/a&gt; 在右边窗口打开必应首页在右边窗口打开一张图片 语法1&lt;a target=&quot;value&quot;&gt; 属性值 值 描述 _blank 在新窗口中打开被链接文档。 _self 默认。在相同的框架中打开被链接文档。 _parent 在父框架集中打开被链接文档。 _top 在整个窗口中打开被链接文档。 framename 在指定的框架中打开被链接文档。 特殊的目标有 4 个保留的目标名称用作特殊的文档重定向操作： _blank浏览器总在一个新打开、未命名的窗口中载入目标文档。 _self这个目标的值对所有没有指定目标的 &lt;a&gt; 标签是默认目标，它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的，除非和文档标题 &lt;base&gt; 标签中的 target 属性一起使用。 _parent这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。 _top这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。 提示：这些 target 的所有 4 个值都以下划线开始。任何其他用一个下划线作为开头的窗口或者目标都会被浏览器忽略，因此，不要将下划线作为文档中定义的任何框架 name 或 id 的第一个字符。","link":"/2019/06/24/a%E6%A0%87%E7%AD%BE%E7%9A%84target%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"在Gmail地址上填个加号","text":"本文转载自：在Gmail地址上填个加号 在Gmail地址上填个加号 我在使用Gmail邮箱时，还有一个很好的功能经常用到，那就是给电子邮件地址填上“+”。给别人发邮件的时候，在自己Gmail邮箱地址上添加一个“+”，这种方法可以自动过滤掉那些未必是垃圾邮件却由于来自不同的邮箱而难以过滤的电子邮件。 考虑一下网上购物时的情况。你买东西的每一个网站都想留下你的电子邮件地址，以便给你发送货款收据、送货通知之类信息。不过可以肯定，它们也会利用你提供的邮件地址向你发送打折票券、促销信息之类内容，甚至发送垃圾邮件。由于来自这些网站的邮件可能包含有关你购买产品的重要信息，因此把这些网站加入垃圾邮件的黑名单并不是一个好的解决办法。此外，这些邮件可能来自多个邮箱（当然都出自同一个网站），因而难以事先预知，也不容易设置过滤条件。另一方面，你又不愿意让电子商务网站发送的垃圾邮件充斥自己的邮箱。 在这种情况下，你可以有别的选择。你可以针对每一个购物公司创建一个电子邮箱。这个办法效率不高，容易造成混乱，而且也会占用别人想用的邮箱地址。其实你不必这么办，只要在Gmail邮箱地址后面填个加号就可以了。 操作要领如下：如果你的Gmail邮箱地址是yourname@gmail.com，提供给购物网站的邮箱就可以是yourname+shopping@gmail.com，无须开设新的电子邮箱。 接下来，你可以设置过滤条件，把所有发向yourname+shopping@gmail.com的邮件自动存档。通过这种操作，所有来自电子商务网站的邮件会自动从当前收件箱中转移出去，成为Gmail邮箱里的历史邮件。结果，那些邮件就不会分散你的注意力，也不会让你恼怒，因为眼不见心不烦。然而，当你搜索邮件或者查看收件箱的时候，这些邮件都还在。另一个办法是，你可以给所有发向yourname+shopping@gmail.com的邮件自动加上诸如“购物”之类的标签。然后可以根据需要，对与电子商务活动有关的邮件进行查看或归类。 所有这些办法的关键是什么呢？对于你想看或不想看的邮件，这是一种简单易行的自动化组织方式。“+”是一个自动过滤器，马上就能作用于所有的网上购物邮件，需要你做的不过是设置一下而已。","link":"/2019/06/25/%E5%9C%A8Gmail%E5%9C%B0%E5%9D%80%E4%B8%8A%E5%A1%AB%E4%B8%AA%E5%8A%A0%E5%8F%B7/"},{"title":"XML文档笔记（一）","text":"转载自： https://www.cnblogs.com/catgatp/p/6403382.html &lt;![CDATA[]]&gt;和转义字符被&lt;![CDATA[]]&gt;这个标记所包含的内容将表示为纯文本，比如&lt;![CDATA[&lt;]]&gt;表示文本内容“&lt;”。 此标记用于xml文档中，我们先来看看使用转义符的情况。我们知道，在xml中，”&lt;”、”&gt;”、”&amp;”等字符是不能直接存入的，否则xml语法检查时会报错，如果想在xml中使用这些符号，必须将其转义为实体，如”&lt;”、”&gt;”、”&amp;”，这样才能保存进xml文档。 在使用程序读取的时候，解析器会自动将这些实体转换回”&lt;”、”&gt;”、”&amp;”。举个例子： &lt;age&gt; age &lt; 30 &lt;/age&gt; 上面这种写法会报错，应该这样写： &lt;age&gt; age&amp;lt;30 &lt;/age&gt; 值得注意的是： (1)转义序列字符之间不能有空格； (2) 转义序列必须以”;”结束； (3) 单独出现的”&amp;”不会被认为是转义的开始； (4) 区分大小写。 在XML中，需要转义的字符有： (1)&amp; &amp;amp; (2)&lt; &amp;lt; (3)&gt; &amp;gt; (4)＂ &amp;quot; (5)＇ &amp;apos; 但是严格来说，在XML中只有”&lt;”和”&amp;”是非法的，其它三个都是可以合法存在的，但是，把它们都进行转义是一个好的习惯。 不管怎么样，转义前的字符也好，转义后的字符也好，都会被xml解析器解析，为了方便起见，使用&lt;![CDATA[]]&gt;来包含不被xml解析器解析的内容。但要注意的是： (1) 此部分不能再包含”]]&gt;”； (2) 不允许嵌套使用； (3)”]]&gt;”这部分不能包含空格或者换行。 最后，说说&lt;![CDATA[]]&gt;和xml转移字符的关系，它们两个看起来是不是感觉功能重复了？ 是的，它们的功能就是一样的，只是应用场景和需求有些不同： (1)&lt;![CDATA[]]&gt;不能适用所有情况，转义字符可以； (2) 对于短字符串&lt;![CDATA[]]&gt;写起来啰嗦，对于长字符串转义字符写起来可读性差； (3) &lt;![CDATA[]]&gt;表示xml解析器忽略解析，所以更快。","link":"/2019/07/02/XML%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"为什么一到毕业就要经历生离死别","text":"","link":"/2019/07/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%88%B0%E6%AF%95%E4%B8%9A%E5%B0%B1%E8%A6%81%E7%BB%8F%E5%8E%86%E7%94%9F%E7%A6%BB%E6%AD%BB%E5%88%AB/"},{"title":"使用Postman测试SOAP接口","text":"使用Postman发出SOAP请求我们知道它说的是Postman“REST”客户端，但这并不意味着我们不能将其用于发出SOAP请求。通过执行以下简单步骤，可以轻松地使用Postman发出任何HTTP SOAP请求： 链接地址Making SOAP requests using PostmanPostman makes SOAP requests too","link":"/2019/10/25/%E4%BD%BF%E7%94%A8Postman%E6%B5%8B%E8%AF%95SOAP%E6%8E%A5%E5%8F%A3/"},{"title":"sqlserver查询使用with(nolock)","text":"sqlserver中，一张表会因为频繁的进行select、delete、insert操作而导致死锁。 记录一次数据库死锁在自己负责的一个业务中，有一张表因为会进行频繁的select、delete、insert。导致报了死锁的错：检验结果存储失败：事务(进程 ID 56)与另一个进程被死锁在 锁 | 通信缓冲区 资源上，并且已被选作死锁牺牲品。请重新运行该事务。SQL:delete LIS_RESULT_CG where JYLSH=’************’ 参考文章 select死锁问题sqlserver查询使用with(nolock)详解WITH(NOLOCK)与WITH(READPAST)共享锁（S锁）和排它锁（X锁）SQL SERVER SELECT语句中加锁选项的详细说明","link":"/2019/11/18/sqlserver%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8with-nolock/"},{"title":"前台加密3DES-C#后台解密","text":"js的3des加解密和c#.net后台解密 Des-3DesDemo C# 3Des加密解密 前台使用cryptojs加密解密时，一定要注意。方法会自动处理key，以凑齐24位。（key不足24位自动以0(最小位数是0)补齐,如果多余24位,则截取前24位,后面多余则舍弃掉） 但C#生成是是允许使用16位字符和24位字符加密的。具体参考：3DES将16位秘钥升级为24位 按3DES规范要求，的确其秘钥应该是24位而不是16位的，但16位秘钥可以按 前8位+后8位+前8位 的规则来升级成24位的秘钥。所以C#的key实际上也是24位，它将16位的key转换成了24位。服了，真是个大坑","link":"/2019/12/05/%E5%89%8D%E5%8F%B0%E5%8A%A0%E5%AF%863DES-C#%E5%90%8E%E5%8F%B0%E8%A7%A3%E5%AF%86/"},{"title":"关于json.stringfy不兼容ie8操作","text":"IE低版本 JSON.parse 和stringify 的兼容 （IE8以下）解决IE8以下低版本实现JSON.parse()与JSON.stringify()的兼容关于 json.stringfy不兼容ie8操作","link":"/2019/12/10/%E5%85%B3%E4%BA%8Ejson-stringfy%E4%B8%8D%E5%85%BC%E5%AE%B9ie8%E6%93%8D%E4%BD%9C/"},{"title":"SQL语句中的N'xxxx'是什么意思","text":"https://www.cnblogs.com/wanshutao/p/4128016.html","link":"/2020/06/01/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84N-xxxx-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"},{"title":"拖延症的改善(一)","text":"拖延症在意识到拖延症已经严重影响到了生活后，我开始尝试改善这个十几年的毛病。 养成一个小习惯改善拖延症，尝试过制定每天的行程，通过闹钟严格控制自己。刚开始的时候确实有成效，但都坚持不了几周，自己慢慢失去动力。这种方式的中，人是被动的。 健身 拖延一个很简单只需要花费几分钟的动作，在坚持一到两天就能看到效果，或者感受到效果。这会给与我一个很强大的正反馈。付出和收获反馈很及时，这会在一定程度上，促使我主动去做，以为在我潜意识里只要我今天做了这个动作，我明天身体的某块地方就会改变，并且能被我感受到，捕捉到这个变化，一个很健康的正反馈循环会是我转守为攻，自己会监督自己去每天做这个动作。它在很大程度上改善了我的拖延。 这样的习惯养成后，能改善我自身的思维和心态。它会促使我潜意识觉得，每天坚持做一些事情，是会有益与我的，自身能接受的付出和收获的间隔长度也会慢慢变长。 健身改善了我的生活。 [EOF]","link":"/2020/08/07/%E6%8B%96%E5%BB%B6%E7%97%87%E7%9A%84%E6%94%B9%E5%96%84-%E4%B8%80/"},{"title":"最近感受到的压力","text":"","link":"/2020/09/10/%E6%9C%80%E8%BF%91%E6%84%9F%E5%8F%97%E5%88%B0%E7%9A%84%E5%8E%8B%E5%8A%9B/"},{"title":"转载—数据库锁的概念","text":"锁的概述一. 为什么要引入锁多个用户同时对数据库的并发操作时会带来以下数据不一致的问题: 丢失更新A,B两个用户读同一数据并进行修改,其中一个用户的修改结果破坏了另一个修改的结果,比如订票系统 脏读A用户修改了数据,随后B用户又读出该数据,但A用户因为某些原因取消了对数据的修改,数据恢复原值,此时B得到的数据就与数据库内的数据产生了不一致 不可重复读A用户读取数据,随后B用户读出该数据并修改,此时A用户再读取数据时发现前后两次的值不一致 并发控制的主要方法是封锁,锁就是在一段时间内禁止用户做某些操作以避免产生数据不一致 二 锁的分类锁的类别有两种分法： 从数据库系统的角度来看：分为独占锁（即排它锁），共享锁和更新锁 MS-SQL Server 使用以下资源锁模式。 锁模式描述:共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。更新 (U) 用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。排它 (X) 用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。意向锁 用于建立锁的层次结构。意向锁的类型为：意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。架构锁 在执行依赖于表架构的操作时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)。大容量更新 (BU) 向表中大容量复制数据并指定了 TABLOCK 提示时使用。共享锁共享 (S) 锁允许并发事务读取 (SELECT) 一个资源。资源上存在共享 (S) 锁时，任何其它事务都不能修改数据。一旦已经读取数据，便立即释放资源上的共享 (S) 锁，除非将事务隔离级别设置为可重复读或更高级别，或者在事务生存周期内用锁定提示保留共享 (S) 锁。 更新锁更新 (U) 锁可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享 (S) 锁，然后修改行，此操作要求锁转换为排它 (X) 锁。如果两个事务获得了资源上的共享模式锁，然后试图同时更新数据，则一个事务尝试将锁转换为排它 (X) 锁。共享模式到排它锁的转换必须等待一段时间，因为一个事务的排它锁与其它事务的共享模式锁不兼容；发生锁等待。第二个事务试图获取排它 (X) 锁以进行更新。由于两个事务都要转换为排它 (X) 锁，并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。 若要避免这种潜在的死锁问题，请使用更新 (U) 锁。一次只有一个事务可以获得资源的更新 (U) 锁。如果事务修改资源，则更新 (U) 锁转换为排它 (X) 锁。否则，锁转换为共享锁。 排它锁排它 (X) 锁可以防止并发事务对资源进行访问。其它事务不能读取或修改排它 (X) 锁锁定的数据。 意向锁意向锁表示 SQL Server 需要在层次结构中的某些底层资源上获取共享 (S) 锁或排它 (X) 锁。例如，放置在表级的共享意向锁表示事务打算在表中的页或行上放置共享 (S) 锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它 (X) 锁。意向锁可以提高性能，因为 SQL Server 仅在表级检查意向锁来确定事务是否可以安全地获取该表上的锁。而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。 意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。 锁模式 描述意向共享 (IS) 通过在各资源上放置 S 锁，表明事务的意向是读取层次结构中的部分（而不是全部）底层资源。意向排它 (IX) 通过在各资源上放置 X 锁，表明事务的意向是修改层次结构中的部分（而不是全部）底层资源。IX 是 IS 的超集。与意向排它共享 (SIX) 通过在各资源上放置 IX 锁，表明事务的意向是读取层次结构中的全部底层资源并修改部分（而不是全部）底层资源。允许顶层资源上的并发 IS 锁。例如，表的 SIX 锁在表上放置一个 SIX 锁（允许并发 IS 锁），在当前所修改页上放置 IX 锁（在已修改行上放置 X 锁）。虽然每个资源在一段时间内只能有一个 SIX 锁，以防止其它事务对资源进行更新，但是其它事务可以通过获取表级的 IS 锁来读取层次结构中的底层资源。 独占锁：只允许进行锁定操作的程序使用，其他任何对他的操作均不会被接受。执行数据更新命令时，SQL Server会自动使用独占锁。当对象上有其他锁存在时，无法对其加独占锁。共享锁：共享锁锁定的资源可以被其他用户读取，但其他用户无法修改它，在执行Select时，SQL Server会对对象加共享锁。更新锁：当SQL Server准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到SQL Server确定要进行更新数据操作时，他会自动将更新锁换为独占锁，当对象上有其他锁存在时，无法对其加更新锁。 从程序员的角度看：分为乐观锁和悲观锁。乐观锁：完全依靠数据库来管理锁的工作。悲观锁：程序员自己管理数据或对象上的锁处理。 MS-SQLSERVER 使用锁在多个同时在数据库内执行修改的用户间实现悲观并发控制 三 锁的粒度锁粒度是被封锁目标的大小,封锁粒度小则并发性高,但开销大,封锁粒度大则并发性低但开销小 SQL Server支持的锁粒度可以分为为行、页、键、键范围、索引、表或数据库获取锁 资源 描述RID 行标识符。用于单独锁定表中的一行。键 索引中的行锁。用于保护可串行事务中的键范围。页 8 千字节 (KB) 的数据页或索引页。扩展盘区 相邻的八个数据页或索引页构成的一组。表 包括所有数据和索引在内的整个表。DB 数据库。 四 锁定时间的长短锁保持的时间长度为保护所请求级别上的资源所需的时间长度。 用于保护读取操作的共享锁的保持时间取决于事务隔离级别。采用 READ COMMITTED 的默认事务隔离级别时，只在读取页的期间内控制共享锁。在扫描中，直到在扫描内的下一页上获取锁时才释放锁。如果指定 HOLDLOCK 提示或者将事务隔离级别设置为 REPEATABLE READ 或 SERIALIZABLE，则直到事务结束才释放锁。 根据为游标设置的并发选项，游标可以获取共享模式的滚动锁以保护提取。当需要滚动锁时，直到下一次提取或关闭游标（以先发生者为准）时才释放滚动锁。但是，如果指定 HOLDLOCK，则直到事务结束才释放滚动锁。 用于保护更新的排它锁将直到事务结束才释放。如果一个连接试图获取一个锁，而该锁与另一个连接所控制的锁冲突，则试图获取锁的连接将一直阻塞到： 将冲突锁释放而且连接获取了所请求的锁。 连接的超时间隔已到期。默认情况下没有超时间隔，但是一些应用程序设置超时间隔以防止无限期等待 五 SQL Server 中锁的自定义1 处理死锁和设置死锁优先级 死锁就是多个用户申请不同封锁,由于申请者均拥有一部分封锁权而又等待其他用户拥有的部分封锁而引起的无休止的等待 可以使用SET DEADLOCK_PRIORITY控制在发生死锁情况时会话的反应方式。如果两个进程都锁定数据，并且直到其它进程释放自己的锁时，每个进程才能释放自己的锁，即发生死锁情况。 2 处理超时和设置锁超时持续时间。 @@LOCK_TIMEOUT 返回当前会话的当前锁超时设置，单位为毫秒 SET LOCK_TIMEOUT 设置允许应用程序设置语句等待阻塞资源的最长时间。当语句等待的时间大于 LOCK_TIMEOUT 设置时，系统将自动取消阻塞的语句，并给应用程序返回”已超过了锁请求超时时段”的 1222 号错误信息 示例下例将锁超时期限设置为 1,800 毫秒。SET LOCK_TIMEOUT 1800 设置事务隔离级别。 4 ) 对 SELECT、INSERT、UPDATE 和 DELETE 语句使用表级锁定提示。 配置索引的锁定粒度可以使用 sp_indexoption 系统存储过程来设置用于索引的锁定粒度 六 查看锁的信息1 执行 EXEC SP_LOCK 报告有关锁的信息2 查询分析器中按Ctrl+2可以看到锁的信息 七 使用注意事项如何避免死锁1 使用事务时，尽量缩短事务的逻辑处理过程，及早提交或回滚事务；2 设置死锁超时参数为合理范围，如：3分钟-10分种；超过时间，自动放弃本次操作，避免进程悬挂；3 优化程序，检查并避免死锁现象出现；4 .对所有的脚本和SP都要仔细测试，在正是版本之前。5 所有的SP都要有错误处理（通过@error）6 一般不要修改SQL SERVER事务的默认级别。不推荐强行加锁 解决问题 如何对行 表 数据库加锁 八 几个有关锁的问题1 如何锁一个表的某一行 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED SELECT * FROM table ROWLOCK WHERE id = 1 2 锁定数据库的一个表 SELECT * FROM table WITH (HOLDLOCK) 加锁语句：sybase:update 表 set col1=col1 where 1=0 ;MSSQL:select col1 from 表 (tablockx) where 1=0 ;oracle:LOCK TABLE 表 IN EXCLUSIVE MODE ；加锁后其它人不可操作，直到加锁用户解锁，用commit或rollback解锁 几个例子帮助大家加深印象设table1(A,B,C)A B Ca1 b1 c1a2 b2 c2a3 b3 c3 1）排它锁新建两个连接在第一个连接中执行以下语句begin tranupdate table1set A=’aa’where B=’b2’waitfor delay ‘00:00:30’ –等待30秒commit tran在第二个连接中执行以下语句 1234begin tran select * from table1 where B='b2' commit tran 若同时执行上述两个语句，则select查询必须等待update执行完毕才能执行即要等待30秒 2）共享锁在第一个连接中执行以下语句 12345begin tran select * from table1 holdlock -holdlock人为加锁 where B='b2' waitfor delay '00:00:30' --等待30秒 commit tran 在第二个连接中执行以下语句 1234567begin tran select A,C from table1 where B='b2' update table1 set A='aa' where B='b2' commit tran 若同时执行上述两个语句，则第二个连接中的select查询可以执行而update必须等待第一个事务释放共享锁转为排它锁后才能执行 即要等待30秒 3）死锁 1234增设table2(D,E) D E d1 e1 d2 e2 在第一个连接中执行以下语句 123456789begin tran update table1 set A='aa' where B='b2' waitfor delay '00:00:30' update table2 set D='d5' where E='e1' commit tran 在第二个连接中执行以下语句 123456789begin tran update table2 set D='d5' where E='e1' waitfor delay '00:00:10' update table1 set A='aa' where B='b2' commit tran 同时执行，系统会检测出死锁，并中止进程 补充一点:Sql Server2000支持的表级锁定提示 HOLDLOCK 持有共享锁，直到整个事务完成，应该在被锁对象不需要时立即释放，等于SERIALIZABLE事务隔离级别 NOLOCK 语句执行时不发出共享锁，允许脏读 ，等于 READ UNCOMMITTED事务隔离级别 PAGLOCK 在使用一个表锁的地方用多个页锁 READPAST 让sql server跳过任何锁定行，执行事务，适用于READ UNCOMMITTED事务隔离级别只跳过RID锁，不跳过页，区域和表锁 ROWLOCK 强制使用行锁 TABLOCKX 强制使用独占表级锁，这个锁在事务期间阻止任何其他事务使用这个表 UPLOCK 强制在读表时使用更新而不用共享锁 应用程序锁:应用程序锁就是客户端代码生成的锁，而不是sql server本身生成的锁 处理应用程序锁的两个过程 sp_getapplock 锁定应用程序资源 sp_releaseapplock 为应用程序资源解锁 注意: 锁定数据库的一个表的区别 123SELECT * FROM table WITH (HOLDLOCK) 其他事务可以读取表，但不能更新删除 SELECT * FROM table WITH (TABLOCKX) 其他事务不能读取表,更新和删除","link":"/2020/11/27/%E8%BD%AC%E8%BD%BD%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5/"},{"title":"CMD start command","text":"by SRINI Start command可用于在另一个命令窗口中运行command/batch（批处理文件）或从命令行启动应用程序。您可以在下面找到该命令的语法和一些示例。 启动另一个命令窗口： 1start cmd 该命令将打开一个新的命令提示符窗口。 在单独的窗口中运行命令 1Start command 该命令将打开一个新的命令窗口，并运行指定的命令。如果命令是GUI应用程序，则将在没有任何新命令窗口的情况下启动该应用程序。 例子：启动新的命令窗口并运行dir命令： 1Start dir 在另一个窗口中运行命令，并在命令执行后终止： 1234567start cmd /c command````例如，要在另一个命令窗口中运行批处理文件并在批处理文件执行完成后关闭该窗口，命令将为：``` CMDStart cmd /c C:\\mybatchfile.bat 在同一窗口中运行命令： 1Start /b command 像在Linux中使用”&amp;”一样，在后台运行命令： 在Windows中，我们可以使用start命令执行类似的操作。但是在这里它不是在后台运行的。一个新的命令窗口将执行指定的命令，而当前窗口将返回以提示执行下一个命令。 123Start command(or)Start batchfile.bat 启动GUI应用程序： 1Start application 例如，要启动Chrome，我们可以使用以下命令: 1Start Chrome 在当前目录中打开Windows资源管理器：: 1start .","link":"/2021/05/07/CMD-Start-Command/"},{"title":"2020人口普查随笔","text":"男女比例的不平衡，以及人口出生率的降低，感觉一定程度上可以使用进化论的来解释。从古至今，人类都存在淘汰，野人时期，身体素质不够高，打不到足够的猎物就是饿死，到了封建时期，第一看投胎，第二就看自己够不够努力（只看生存能力,坑蒙拐骗也算本领）。而到了现在也是如此，第一看投胎，第二看自身。自古如此，人类的基因也在随着时间的变化而被筛选，更能适应社会的，能够获取到异性的注意力的人，他们的基因将会更好的流传下去，而一些从经济、思想、为人上无法获取到异性的青睐时，他们的基因从某种意义上来讲，也算是被自然所淘汰。 没钱的人只能单身","link":"/2021/05/11/2020%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5%E9%9A%8F%E7%AC%94/"},{"title":"一句话","text":"自己下定决心到达成某个目标时，不要和别人说，等自己完成后再说","link":"/2021/05/17/%E4%B8%80%E5%8F%A5%E8%AF%9D/"},{"title":"C#设置程序开机自启动","text":"方法一：将软件的快捷方式创建到计算机的自动启动目录下（不需要管理员权限） 进入目录：C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 将应用程序快捷方式剪切(或者复制)并粘贴到目录中 应用程序快捷方式加入到了启动项，下次重启电脑之后这个应用程序就会自动开机运行了 如果需要针对个人账户进行配置：Win+R输入命令shell:startup ,会直接弹出启动项对应的目录，然后像前面方法一样把应用程序快捷方式复制到启动目录 方法二：修改计算机注册表的方式（需要管理员权限）开始Windows自启动原理在Windows操作系统下，主要有2个文件夹和8个注册表键项控制程序的自启动，通过修改“Run”键值实现自启动程序是比较常见的方法。具体的位置是：HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Run 参考资料： Windows程序自启动原理 代码在知道注册表中自启动位置所在后，只需要将需要启动的程序路径添加至指定路径中就可以实现开机自启动功能。 Program.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/// &lt;summary&gt;/// 应用程序的主入口点。/// &lt;/summary&gt;[STAThread]static void Main(){ Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); string appGuid = ((GuidAttribute)Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(GuidAttribute), false).GetValue(0)).Value; using (Mutex mutex = new Mutex(false, \"Global\\\\\" + appGuid)) { if (!mutex.WaitOne(0, false)) { return; } //判断是否开启自启动 string strFilePath = Application.ExecutablePath; string strFileName = System.IO.Path.GetFileName(strFilePath); try { //自启动功能是否开启 var AutoRunFlag = ConfigurationManager.AppSettings[\"AutoRunFlag\"] == \"1\" ? true : false; //自启动是否已经存在 var flag = SystemHelper.IsAutoRun(strFilePath, strFileName); if (AutoRunFlag != flag) { #region 获取管理员权限，进行注册表写入操作 //当前用户是管理员的时候，直接启动应用程序并且写入注册表 //如果不是管理员，则使用启动对象启动程序，以确保使用管理员身份运行 //获得当前登录的Windows用户标示 WindowsIdentity identity = WindowsIdentity.GetCurrent(); WindowsPrincipal principal = new WindowsPrincipal(identity); //判断当前登录用户是否为管理员 if (principal.IsInRole(WindowsBuiltInRole.Administrator)) { try { //如果是管理员，注册自启动代码 SystemHelper.SetAutoRun(strFilePath, strFileName, AutoRunFlag); } catch(Exception ex) { MessageBox.Show( ex.Message, \"错误提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); } } else { //创建启动对象 System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo(); startInfo.UseShellExecute = true; startInfo.WorkingDirectory = Environment.CurrentDirectory; startInfo.FileName = Application.ExecutablePath; //设置启动动作,确保以管理员身份运行 startInfo.Verb = \"runas\"; try { System.Diagnostics.Process.Start(startInfo); } catch { return; } //退出 Application.Exit(); } #endregion } //启动程序 Application.Run(new Form1()); } catch(Exception ex) { MessageBox.Show(ex.Message, \"错误提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); //return; } } } SystemHelper.cs 参考自：C# winform程序实现开机自启动，并且识别是开机启动还是双击启动 SystemHelper.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public sealed class SystemHelper{ private SystemHelper() { } /// &lt;summary&gt; /// 设置程序开机启动 /// &lt;/summary&gt; /// &lt;param name=\"strAppPath\"&gt;应用程序exe所在文件夹&lt;/param&gt; /// &lt;param name=\"strAppName\"&gt;应用程序exe名称&lt;/param&gt; /// &lt;param name=\"bIsAutoRun\"&gt;自动运行状态&lt;/param&gt; public static void SetAutoRun(string strAppPath, string strAppName, bool bIsAutoRun) { try { if (string.IsNullOrWhiteSpace(strAppPath) || string.IsNullOrWhiteSpace(strAppName)) { throw new Exception(\"应用程序路径或名称为空！\"); } RegistryKey reg = Registry.LocalMachine; RegistryKey run = reg.CreateSubKey(@\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"); if (bIsAutoRun) { run.SetValue(strAppName, strAppPath); } else { if (null != run.GetValue(strAppName)) { run.DeleteValue(strAppName); } } run.Close(); reg.Close(); } catch (Exception ex) { throw new Exception(ex.Message, ex); } } /// &lt;summary&gt; /// 判断是否开机启动 /// &lt;/summary&gt; /// &lt;param name=\"strAppPath\"&gt;应用程序路径&lt;/param&gt; /// &lt;param name=\"strAppName\"&gt;应用程序名称&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsAutoRun(string strAppPath, string strAppName) { try { RegistryKey reg = Registry.LocalMachine; RegistryKey software = reg.OpenSubKey(@\"SOFTWARE\"); RegistryKey run = reg.OpenSubKey(@\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"); object key = run.GetValue(strAppName); software.Close(); run.Close(); if (null == key || !strAppPath.Equals(key.ToString())) { return false; } return true; } catch (Exception ex) { throw new Exception(ex.Message, ex); } }} 运行环境 Win10.NET Framework4.5VS2019 填坑 注册表地址 使用代码修改注册表的方式，如果需要查看注册信息，需要确认程序是32-bit还是64-bit。 32位，查看地址为 :HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVers ion\\Run 64位，查看地址为 :HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 操作系统 64位程序访问的注册表 32位程序访问的注册表 64位系统 HKEY_LOCAL_MACHINE\\SOFTWARE HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node 32位系统 - HKEY_LOCAL_MACHINE\\SOFTWARE 参考资料： .NET/C# 在 64 位进程中读取 32 位进程重定向后的注册表 关于WOW6432Node 以管理员权限打开程序：参考资料： Windows 下使用 runas 命令以指定的权限启动一个进程（非管理员、管理员） Windows 中的 UAC 用户账户控制 C#程序以管理员权限运行","link":"/2021/07/16/C-%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"},{"title":"C#代码确保应用程序只有一个实例","text":"使用互斥锁，实现只有一个程序 代码： code.cs12345678910string appGuid = ((GuidAttribute)Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(GuidAttribute), false).GetValue(0)).Value;using (Mutex mutex = new Mutex(false, \"Global\\\\\" + appGuid)){ if (!mutex.WaitOne(0, false)) { return; } //启动程序 Application.Run(new Form1()); } 运行环境 Win10.NET Framework 4.5VS2019 参考资料： What is a good pattern for using a Global Mutex in C#? The Misunderstood Mutex C# prevent multiple instance of console application running","link":"/2021/07/20/C-%E4%BB%A3%E7%A0%81%E7%A1%AE%E4%BF%9D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B/"},{"title":"Win1020H2中文语言下添加美式键盘","text":"来源：https://www.itsk.com/thread-413229-1-1.html 2021-7-20.reg12345678910111213141516171819Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Keyboard Layout\\Preload]\"1\"=\"00000804\"[HKEY_CURRENT_USER\\Keyboard Layout\\Substitutes]\"00000804\"=\"00000409\"[HKEY_USERS\\.DEFAULT\\Keyboard Layout\\Preload]\"1\"=\"00000804\"[HKEY_USERS\\.DEFAULT\\Keyboard Layout\\Substitutes]\"00000804\"=\"00000409\"[HKEY_CURRENT_USER\\Control Panel\\International\\User Profile]\"InputMethodOverride\"=\"0804:00000409\"[HKEY_CURRENT_USER\\Control Panel\\International\\User Profile\\zh-Hans-CN]\"0804:00000409\"=dword:00000001","link":"/2021/07/20/Win1020H2%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%BE%8E%E5%BC%8F%E9%94%AE%E7%9B%98/"},{"title":"服务器设置系统启动时程序自动运行（不需要登录）","text":"","link":"/2021/07/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%97%B6%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%EF%BC%88%E4%B8%8D%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95%EF%BC%89/"},{"title":"你好，世界","text":"欢迎来到[Hexo](https://hexo.io/)! 这是你的第一篇文章。 查看[文档](https://hexo.io/docs/) 以获取更多信息。如果您在使用Hexo时遇到任何问题，可以在[故障排除](https://hexo.io/docs/troubleshooting.html)中找到答案, 者您可以在[GitHub](https://github.com/hexojs/hexo/issues)上询问我。 快速开始创建一个新帖子1$ hexo new \"My New Post\" 更多信息： 写作 运行服务器1$ hexo server 更多信息：服务器 生成静态文件1$ hexo generate 更多信息：生成 部署到远程站点1$ hexo deploy 更多信息：部署","link":"/2019/06/30/hello-world/"},{"title":"测试","text":"Welcome to my Blog ! this is a test article ,This blog is built using Hexo and the theme is Minos theme .","link":"/2019/03/19/%E6%B5%8B%E8%AF%95/"},{"title":"记录第一次搭建Blog","text":"花了两天把我想了两年的事情给解决了 ## 起因 &nbsp;&nbsp;&nbsp;&nbsp;早就在学校读书时就想搭建一个记录生活的Blog,迫于自己比较懒（ 其实是游戏太好玩😑）,一直没有动手。然后从今年一月份开始实习后，遭受了社会太多的毒打😶,经历的一些事情让我很想找个地方记录下来，加之最近工作闲下来的时候在学习怎么用Github,用GitHub Page搭建Blog无疑是个很好的机会。于是我搭建了这个blog——一个记录生活，偶尔记录技术🙃的博客。 经过 在百度后，照着网上的教程一步步照着做下来，博客花了不到两天就这么搭好了（内心OS:😕这么简单，我为啥拖了这么久）。在搭建过程中也有出现一些小问题，在开始的时候让我无语的是在_config.yml中，配置项的值都需要和字段空一格😑： 错误:theme:minos 正确：theme: minos 。最后Blog使用Hexo+Minos+GitHub Pages搭建完成。 搭建参照： 使用Hexo+Github一步步搭建属于自己的博客（基础）使用Hexo+Github一步步搭建属于自己的博客（进阶）Github Pages和Hexo简明教程用Hexo+Github+Coding搭建静态博客（一） 配置插件和样式参照： Hexo文档讲解（二）Hexo安装和配置API和一些小部件（四） 主题的配置参照： 配置Minos主题自定义（三） Markdown语法和Minos支持的语法参照： Minos Markdown在线编辑markdownMarkdown 语法手册 效果： Thoughts搭建一个可以记录自己生活的地方是我从16年就想做的事，但是一直到了19年才实现。(我是不是太拖了🙃)不过还好，我终于搭建起了这个Blog虽然是静态的。想起来自己最初想搭建Blog也只是想找个类似树洞一样的地方倾述。没想到现在实现了，却突然没有那么多话想写下来。心里有点失落，不过好在自己以后也有吐槽的地方了，很好😝","link":"/2019/03/20/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BABlog/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"},{"name":"live2d","slug":"live2d","link":"/tags/live2d/"},{"name":"emoji","slug":"emoji","link":"/tags/emoji/"},{"name":"记录","slug":"记录","link":"/tags/%E8%AE%B0%E5%BD%95/"},{"name":"软件版本号","slug":"软件版本号","link":"/tags/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7/"},{"name":"-ASP.Net MVC","slug":"ASP-Net-MVC","link":"/tags/ASP-Net-MVC/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Mail","slug":"Mail","link":"/tags/Mail/"},{"name":"发送邮件","slug":"发送邮件","link":"/tags/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"name":"ASP.NET","slug":"ASP-NET","link":"/tags/ASP-NET/"},{"name":"System.Net.Mail","slug":"System-Net-Mail","link":"/tags/System-Net-Mail/"},{"name":"邮件发送","slug":"邮件发送","link":"/tags/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"},{"name":"吐槽","slug":"吐槽","link":"/tags/%E5%90%90%E6%A7%BD/"},{"name":"感想","slug":"感想","link":"/tags/%E6%84%9F%E6%83%B3/"},{"name":"负能量","slug":"负能量","link":"/tags/%E8%B4%9F%E8%83%BD%E9%87%8F/"},{"name":"Technology","slug":"Technology","link":"/tags/Technology/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Oracle","slug":"Oracle","link":"/tags/Oracle/"},{"name":"教育","slug":"教育","link":"/tags/%E6%95%99%E8%82%B2/"},{"name":"成长","slug":"成长","link":"/tags/%E6%88%90%E9%95%BF/"},{"name":"命令行","slug":"命令行","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Gmail","slug":"Gmail","link":"/tags/Gmail/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"Postman","slug":"Postman","link":"/tags/Postman/"},{"name":"sqlserver","slug":"sqlserver","link":"/tags/sqlserver/"},{"name":"死锁","slug":"死锁","link":"/tags/%E6%AD%BB%E9%94%81/"},{"name":"树洞","slug":"树洞","link":"/tags/%E6%A0%91%E6%B4%9E/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"搭建Blog","slug":"搭建Blog","link":"/tags/%E6%90%AD%E5%BB%BABlog/"}],"categories":[{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"other","slug":"other","link":"/categories/other/"},{"name":"转载","slug":"Technology/转载","link":"/categories/Technology/%E8%BD%AC%E8%BD%BD/"},{"name":"LifeStyle","slug":"LifeStyle","link":"/categories/LifeStyle/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"转载","slug":"other/转载","link":"/categories/other/%E8%BD%AC%E8%BD%BD/"},{"name":"转载","slug":"转载","link":"/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"lifeStyle","slug":"lifeStyle","link":"/categories/lifeStyle/"}]}