{"pages":[{"title":"关于","text":"这是一个用来记录生活为主的Blog,请不要转载。声明：本博客中部分图片、文章来源于网络，版权归原作者所有， 如有侵权请联系删除。Email：selectitemc@gmail.com","link":"/about/index.html"},{"title":"其它","text":"其它","link":"/other/index.html"}],"posts":[{"title":"在hexo上添加Live 2D看板娘","text":"博客美化—给Hexo博客添加萌萌的康娜（Kanna） 前言 在逛V站时，看到了一个帖子，然后就被她的看板娘吸引，但是想我也算是有Blog的人(虽然才刚建)，我是不是也可以弄一个呢，说干就干，立马开始捣鼓起来。 过程开始 因为看板娘在WordPress、Typecho、Typecho等用户群体大的博客上应用广泛，所以Live2d 看板娘在WordPress这些博客上能被更好的应用，在网上找的的教程大部分也是关于WordPress等的教程，所以我自己也是懵懵懂懂的去实现这个功能，这篇文章仅记录过程。 经过 在查看下列几篇文章后,开始动手搭建 在Hexo博客上添加可爱的Live 2D模型hexo 添加live2d看板动画 安装模块 hexo博客根目录选择cmd命令窗口或者git bash 输入以下代码，安装插件 1npm install --save hexo-helper-live2d 下载模型1npm install live2d-widget-model-shizuku 配置 打开个人Hexo博客文件根目录下的 _config.yml 文件，在最后添加一下代码 _config.yml12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true再打开cmd键入hexo g -d 就大功告成了😁🎉🎉🎉 DIY资料 资源模型插件:hexo-helper-live2d模型插件作者各种模型包展示hexo模型插件作者各种模型包合集Live2d模型资源：梦象-Live2D 模型资源收集站 适用于WordPress、Typecho、Typecho等强烈推荐：为你的博客博客/网页添加Live2d二次元老婆的插件/手动方法给博客添加能动的看板娘(Live2D)-关于模型的二三事网页添加 Live2D 看板娘","link":"/2019/03/25/%E5%9C%A8hexo%E4%B8%8A%E6%B7%BB%E5%8A%A0Live-2D/"},{"title":"在hexo文章里使用emoji🤔","text":"记录如何然hexo文章支持emojiHexo 默认的 markdown 渲染引擎不支持将 Github emoji 渲染到静态的 html 页面中，我们换一个支持 emoji 的引擎，再增加一个 emoji 插件即可.","link":"/2019/03/25/%E5%9C%A8hexo%E6%96%87%E7%AB%A0%E9%87%8C%E4%BD%BF%E7%94%A8emoji/"},{"title":"各种软件版本号的含义","text":"今天在逛spring的文档repo时， 常见软件版本编辑软件版本：包含两种不同含义（1）为满足不同用户的不同使用要求，如适用于不同运行环境或不同平台的系列产品。（2）软件产品投入使用以后，经过一段时间运行提出了变更的要求，需要做较大的修正或纠错，增强功能或提高性能。 Alpha版（内部测试版）：Alpha版本通常会送交到开发软件的组织或社群中的各个软件测试者，用作内部测试。在市场上，越来越多公司会邀请外部的客户或合作伙伴参与其软件的Alpha测试阶段。这令软件在此阶段有更大的可用性测试。在测试的第一个阶段中，开发者通常会进行白盒测试。其他测试会在稍后时间由其他测试团体以黑盒或灰盒技术进行，不过有时会同时进行。 Beta版（外部测试版）：软件开发公司为对外宣传，将非正式产品免费发送给具有典型性的用户，让用户测试该软件的不足之处及存在问题，以便在正式发行前进一步改进和完善 。一般可通过Internet免费下载，也可以向软件公司索取。Beta版本是第一个对外公开的软件版本，是由公众参与的测试阶段。一般来说，Beta包含所有功能，但可能有一些已知问题和较轻微的臭虫（Bug）。Beta版本的测试者通常是开发软件的组织的客户，他们会以免费或优惠价钱得到软件，但会成为组织的免费测试者。Beta版本主要测试产品的支援和市场反应（在邀请Beta用户时）等。 Demo版（演示版）：主要是演示正式软件的部分功能，用户可以从中得知软件的基本操作，为正式产品的发售扩大影响。如果是游戏的话，则只有一两个关卡可以玩。该版本也可以从Internet上免费下载。Enhanced版（增强版或加强版）：如果是一般软件，一般称作“增强版”，会加入一些实用的新功能。如果是游戏，一般称作“加强版”，会加入一些新的游戏场景和游戏情节等。这是正式发售的版本。 Free版（自由版）：这一般是个人或自由软件联盟组织的成员制作的软件，希望免费给大家使用，没有版权，一般也是通过Internet免费下载。Full Version版（完全版）：也就是正式版，是最终正式发售的版本。 Shareware版（共享版）：有些公司为了吸引客户，对于他们制作的某些软件，可以让用户通过Internet免费下载的方式获取。不过，此版本软件多会带有一些使用时间或次数的限制，但可以利用在线注册或电子注册成为正式版用户。 Release版（发行版）：稳定的发行版，可从Internet上免费下载。Release Candidate（简称RC）指可能成为最终产品的版本，如果没有再出现问题则可释出正式版本。在此阶段，产品包含所有功能亦不会出现严重问题。通常此阶段的产品是接近完整的。微软公司很多时会使用此名称。在1990年代，苹果电脑把在这阶段的产品称为“Golden Master”，而最后的Golden Master为正式版本。这阶段亦称Gamma（更后期的称为Delta，及其后的希腊字母）。 Upgrade版（升级版）：当你有某个软件以前的正式版本时，可以购买升级版，将你的软件升级为最新版。升级后的软件与正式版在功能上相同，但价格会低些，这主要是为了给原有的正版用户提供优惠。 Retail版 零售版，一般只针对个人的功能不是很全的版本，价格比较低，升级时间也有限制。Cardware版 属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。Plus版 属增强版，不过这种大部分是在程序界面及多媒体功能上增强。Preview版 预览版，软件作者为了满足那些对新版本很关注的人，发布的可以看到大部分功能的测试软件。Corporation &amp; Enterprise版 企业版，只针对企业发布的全功能版本，价格比较昂贵，服务非常齐全。Standard版 标准版，软件商推荐大家使用的版本，这种版本一般比较稳定，BUG少。Mini版 迷你版也叫精简版只有最基本的功能，为那些想节省硬盘空间或者不追求华丽的人准备的。Premium——超值版Professional——专业版Express——简易版（比如Outlook express 和outlook 相比，前者更精简；Sql Server Express版表示免费精简版）Deluxe——豪华版Regged——已注册版CN——简体中文版CHT——繁体中文版EN——英文版Multilanguage——多语言版Rip 是指从原版文件（一般是指光盘或光盘镜像文件）直接将有用的内容（核心内容）分离出来，剔除无用的文档，例如PDF说明文件啊，视频演示啊之类的东西，也可以算做是精简版吧…但主要内容功能是一点也不能缺少的！另：DVDrip是指将视频和音频直接从DVD光盘里以文件方式分离出来。trial 试用版（含有某些限制，如时间、功能，注册后也有可能变为正式版）RC 版 是 Release Candidate 的缩写，意思是发布倒计时，该版本已经完成全部功能并清除大部分的BUG。到了这个阶段只会除BUG，不会对软件做任何大的更改。RTM 版 这基本就是最终的版本，英文是 Release To Manufacture，意思是发布到生产商。版本号编辑V（Version）即版本，通常用数字表示版本号。（如：EVEREST Ultimate v4.20.1188 Beta） Build：用数字或日期标示版本号的一种方式。（如：VeryCD eMule v0.48a Build 071112）SP：Service Pack，升级包。（如：WindowsXP SP2/Vista SP1）授权和功能划分： Trial：试用版，通常都有时间限制，有些试用版软件还在功能上做了一定的限制。可注册或购买成为正式版Unregistered未注册版，通常没有时间限制，在功能上相对于正式版做了一定的限制。可注册或购买成为正式版。Demo：演示版，仅仅集成了正式版中的几个功能，不能升级成正式版。Lite：精简版。Full version：完整版，属于正式版。 语言划分编辑SC：Simplified Chinese简体中文版。CN：简体中文版GBK：简体中文汉字内码扩展规范版。TC：Traditional Chinese繁体中文版。CHT：繁体中文版BIG5：繁体中文大五码版。EN：英文版Multilanguage：多语言版UTF8： Unicode Transformation Format 8 bit，对现有的中文系统不是好的解决方案。 开发阶段划分编辑α（Alpha）版：内测版，内部交流或者专业测试人员测试用。Bug较多，普通用户最好不要安装。β（Beta）版：公测版，专业爱好者大规模测试用，存在一些缺陷，该版本也不适合一般用户安装。γ（Gamma）版：相当成熟的测试版，与即将发行的正式版相差无几。RC版：Release Candidate。RC版。是Release Candidate的缩写，意思是发布倒计时，候选版本，处于Gamma阶段，该版本已经完成全部功能并清除大部分的BUG。到了这个阶段只会除BUG，不会对软件做任何大的更改。从Alpha到Beta再到Gamma是改进的先后关系，但RC1、RC2往往是取舍关系。SR版：Service Release的缩写，修正版或更新版，修正了正式版推出后发现的Bug。Final版：正式版。 其他版本编辑Enhance：增强版或者加强版，属于正式版Free：自由版（免费版）Release：发行版Upgrade：升级版Retail：零售版Cardware：属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。/SPlus：属增强版，不过这种大部分是在程序界面及多媒体功能上增强。Preview：预览版Corporation&amp;Enterprise：企业版Standard：标准版Mini：迷你版也叫精简版只有最基本的功能Professional/pro：专业版Express：特别版Deluxe： 豪华版Regged：已注册版Rip： 是指从原版文件（一般是指光盘或光盘镜像文件）直接将有用的内容（核心内容）分离出来，剔除无用的文档，例如PDF说明文件啊，视频演示啊之类的东西，也可以算做是精简版吧…但主要内容功能是一点也不能缺少的！另：DVDrip是指将视频和音频直接从DVD光盘里以文件方式分离出来。RTM：这基本就是最终的版本，英文是Release To Manufactur，意思是发布到生产商。OEM：Original Equipment Manufacturer，是给电脑生产厂的版本，软件发行商于电脑生产厂家的定制版本。FPP：Full Packaged Product（FPP）/Retail，就是零售版（盒装软件），这种产品的光盘的卷标都带有“FPP”字样，比如英文WXP Pro的FPP版本的光盘卷标就是WXPFPP_EN，其中WX表示是Windows XP，P是Professional（H是Home），FPP表明是零售版本，EN是表明是英语。获得途径除了在商店购买之外，某些MSDN用户也可以得到。VOL：Volume Licensing for Organizations（VLO），团体批量许可证（大量采购授权合约），这是为团体购买而制定的一种优惠方式。这种产品的光盘的卷标都带有“VOL”字样，取“Volume”前3个字母，以表明是批量，比如英文WXP Pro的VOL版本的光盘卷标就是WXPVOL_EN，其中WX表示是Windows XP，P是Professional（VOL没有Home版本），VOL表明是团体批量许可证版本，EN是表明是英语。获得途径主要是集团购买，某些MSDN用户也可以得到。","link":"/2019/03/26/%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/"},{"title":"只是一个普通人","text":"","link":"/2019/04/08/%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E4%BA%BA/"},{"title":"ASP.Net MVC action 同时支持Get和Post","text":"项目中遇到一个action，有post和get请求，特此记录方法：在action 上加上 AcceptVerbs标签: 12[AcceptVerbs(HttpVerbs.Get | HttpVerbs.Post)]public ActionResult Index() 转自：https://blog.csdn.net/Helloantoherday/article/details/85007344","link":"/2019/04/10/ASP-Net-MVC-action-%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81Get%E5%92%8CPost/"},{"title":"Asp.net MVC在Razor中输出Html的两种方式","text":"Razor中所有的Html都会自动编码，这样就不需要我们手动去编码了（安全），但在需要输出Html时就是已经转义过的Html文本了，如下所示： 1234@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\";}@thisTest; 这样在页面输出的文本就是：&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;而不是红色的字体了，要输出红色的字体，有下面常用的两种方式： 1、使用Razor中的Html.Raw（推荐使用这种方式）： 1234@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\";}@Html.Raw(thisTest); 2、使用MvcHtmlString类来实现： 12345@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\"; var thisResult = new MvcHtmlString(thisTest);}@thisResult 或 @(new HtmlString(thisTest))","link":"/2019/05/07/Asp-net-MVC%E5%9C%A8Razor%E4%B8%AD%E8%BE%93%E5%87%BAHtml%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"突发奇想：对于人类进化的优胜劣汰","text":"最近实习越来越发现自己","link":"/2019/04/16/%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%EF%BC%9A%E5%AF%B9%E4%BA%8E%E4%BA%BA%E7%B1%BB%E8%BF%9B%E5%8C%96%E7%9A%84%E4%BC%98%E8%83%9C%E5%8A%A3%E6%B1%B0/"},{"title":"彻底清除Github上某个文件的历史（对于误传密码等隐私信息等情况）","text":"Removing sensitive data from a repository","link":"/2019/04/26/%E5%BD%BB%E5%BA%95%E6%B8%85%E9%99%A4Github%E4%B8%8A%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%88%E5%AF%B9%E4%BA%8E%E8%AF%AF%E4%BC%A0%E5%AF%86%E7%A0%81%E7%AD%89%E9%9A%90%E7%A7%81%E4%BF%A1%E6%81%AF%E7%AD%89%E6%83%85%E5%86%B5%EF%BC%89/"},{"title":"对当今教育的一些感想","text":"今天是2019年5月24日，工作了一段时间后，逐渐发现","link":"/2019/05/24/%E5%AF%B9%E5%BD%93%E4%BB%8A%E6%95%99%E8%82%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/"},{"title":"SQL语句使用技巧","text":"记录一下自己在使用PL/SQL的编写SQL语句的注意点和技巧 记录工作中遇到的在统计一张数据表中一个数据类型为Char(2) 的字段的值为空的数量时，使用 `select count(1) from table1 where EHR_PAT_GEN = ''`，查询出的结果为0（数据库中数据已经确认有空的）。 然后将语句换成`select count(1) from table1 where EHR_PAT_GEN &lt;&gt; ''`执行后，结果仍然为0，然后查询数据表，发现不为空的的数据为数字时，使用`select count(1) from table1 where EHR_PAT_GEN &gt; 0`查出该字段不为空的数据量。然后百度到char类型是","link":"/2019/05/20/SQL%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"&#39;nginx缓存页面+cookie后-串会话问题&#39;","text":"https://blog.csdn.net/clevercode/article/details/75145258","link":"/2019/05/31/nginx%E7%BC%93%E5%AD%98%E9%A1%B5%E9%9D%A2-cookie%E5%90%8E-%E4%B8%B2%E4%BC%9A%E8%AF%9D%E9%97%AE%E9%A2%98/"},{"title":"jQuery的Ajax的dataType设置问题","text":"在Asp.Net MVC的前台页面使用Ajax获取数据，当Ajax方法中设置了dataType: \"json\"后，Ajax无法使用data.ret的方式处理数据。Controller.Json Method (Object)Json(Object) 方法返回的是继承自System.Object的类型值System.Web.Mvc.JsonResult在前台获取到的是object，而不是json字符串 http://www.cnblogs.com/zhangcybb/p/6604380.htmlhttps://docs.microsoft.com/en-us/previous-versions/aspnet/dd504936%28v%3dvs.100%29#see-alsohttps://docs.microsoft.com/en-us/previous-versions/aspnet/dd504936%28v%3dvs.100%29https://docs.microsoft.com/zh-cn/previous-versions/aspnet/dd470569%28v%3dvs.100%29https://www.cnblogs.com/fire-dragon/p/5889400.html","link":"/2019/05/09/jQuery%E7%9A%84Ajax%E7%9A%84dataType%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"},{"title":"终究还是毕业了","text":"","link":"/2019/06/05/%E7%BB%88%E7%A9%B6%E8%BF%98%E6%98%AF%E6%AF%95%E4%B8%9A%E4%BA%86/"},{"title":"hexo指令列表","text":"为了方便使用hexo，将一些hexo指令记录下来 hexo指令 hexo 提示 hexo 官方文档 Hexo起步安装（-g为全局安装） 1npm install hexo -g 升级（-g为全局升级） 1npm update hexo -g 初始化，生成文件夹为blog 1hexo init blog 安装依赖库 1npm install 简写hexo n \"我的博客\"== hexo new \"我的博客\" #新建文章hexo p== hexo publish #将草稿帖子从_drafts移动到_posts文件夹。hexo g== hexo generate#生成hexo s== hexo server #启动服务预览hexo d == hexo deploy#部署hexo s -g == hexo server --generate#生成静态页面并启动服务预览 生成静态网页后部署到GitHub上 两个命令的作用是相同的hexo g -d == hexo generate --deployhexo d -g == hexo deploy --generate 模板hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate --watch #监视文件变动 hexo提示在CMD中输入hexo help后，获得的命令行列表 1234567891011121314151617181920212223用法: hexo &lt;command&gt;Commands: clean 删除生成的文件和缓存。 config 获取或设置配置 deploy 部署你的网站。 可简写成 `hexo d` generate 生成静态文件。 可简写成 `hexo g` help 获取有关命令的帮助。 init 创建一个新的Hexo文件夹。 list 列出网站的信息 migrate 将您的站点从其他系统迁移到Hexo。 new 创建一个新帖子。 可简写成 `hexo n` publish 将草稿帖子从_drafts移动到_posts文件夹。 render 使用渲染器插件渲染文件。 server 启动服务器。 可简写成 `hexo s` version 显示版本信息。全局选项: --config 指定配置文件而不是使用_config.yml --cwd 指定CWD --debug 显示终端中的所有详细消息 --draft 显示草稿帖子 --safe 禁用所有插件和脚本 --silent 隐藏控制台上的输出 官方文档的一些指令init1hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new1hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1hexo new \"post title with whitespace\" generate1hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 该命令可以简写为 1hexo g publish1hexo publish [layout] &lt;filename&gt; 发表草稿。 server1hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 deploy1hexo deploy 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 该命令可以简写为： 1hexo d render1hexo render &lt;file1&gt; [file2] ... 渲染文件。 参数 描述 -o, --output 设置输出路径 migrate1hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1hexo list &lt;type&gt; 列出网站资料。 version1hexo version 显示 Hexo 版本。 选项安全模式1hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式1hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式1hexo --silent 隐藏终端信息。 自定义配置文件的路径1hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿1hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD1hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。","link":"/2019/06/12/hexo%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A8/"},{"title":"在Gmail地址上填个加号","text":"本文转载自：在Gmail地址上填个加号 在Gmail地址上填个加号 我在使用Gmail邮箱时，还有一个很好的功能经常用到，那就是给电子邮件地址填上“+”。给别人发邮件的时候，在自己Gmail邮箱地址上添加一个“+”，这种方法可以自动过滤掉那些未必是垃圾邮件却由于来自不同的邮箱而难以过滤的电子邮件。 考虑一下网上购物时的情况。你买东西的每一个网站都想留下你的电子邮件地址，以便给你发送货款收据、送货通知之类信息。不过可以肯定，它们也会利用你提供的邮件地址向你发送打折票券、促销信息之类内容，甚至发送垃圾邮件。由于来自这些网站的邮件可能包含有关你购买产品的重要信息，因此把这些网站加入垃圾邮件的黑名单并不是一个好的解决办法。此外，这些邮件可能来自多个邮箱（当然都出自同一个网站），因而难以事先预知，也不容易设置过滤条件。另一方面，你又不愿意让电子商务网站发送的垃圾邮件充斥自己的邮箱。 在这种情况下，你可以有别的选择。你可以针对每一个购物公司创建一个电子邮箱。这个办法效率不高，容易造成混乱，而且也会占用别人想用的邮箱地址。其实你不必这么办，只要在Gmail邮箱地址后面填个加号就可以了。 操作要领如下：如果你的Gmail邮箱地址是yourname@gmail.com，提供给购物网站的邮箱就可以是yourname+shopping@gmail.com，无须开设新的电子邮箱。 接下来，你可以设置过滤条件，把所有发向yourname+shopping@gmail.com的邮件自动存档。通过这种操作，所有来自电子商务网站的邮件会自动从当前收件箱中转移出去，成为Gmail邮箱里的历史邮件。结果，那些邮件就不会分散你的注意力，也不会让你恼怒，因为眼不见心不烦。然而，当你搜索邮件或者查看收件箱的时候，这些邮件都还在。另一个办法是，你可以给所有发向yourname+shopping@gmail.com的邮件自动加上诸如“购物”之类的标签。然后可以根据需要，对与电子商务活动有关的邮件进行查看或归类。 所有这些办法的关键是什么呢？对于你想看或不想看的邮件，这是一种简单易行的自动化组织方式。“+”是一个自动过滤器，马上就能作用于所有的网上购物邮件，需要你做的不过是设置一下而已。","link":"/2019/06/25/%E5%9C%A8Gmail%E5%9C%B0%E5%9D%80%E4%B8%8A%E5%A1%AB%E4%B8%AA%E5%8A%A0%E5%8F%B7/"},{"title":"a标签的target的用法","text":"记录一下今天在学习项目时遇到的一个低级问题🙃 HTML&lt;a&gt;标签的target属性 参考地址：http://www.w3school.com.cn/tags/att_a_target.asp 定义和用法&lt;a&gt; 标签的 target 属性规定在何处打开链接文档。 如果在一个 &lt;a&gt; 标签内包含一个 target 属性，浏览器将会载入和显示用这个标签的 href 属性命名的、名称与这个目标吻合的框架或者窗口中的文档。如果这个指定名称或 id 的框架或者窗口不存在，浏览器将打开一个新的窗口，给这个窗口一个指定的标记，然后将新的文档载入那个窗口。从此以后，超链接文档就可以指向这个新的窗口。 打开新窗口 被指向的超链接使得创建高效的浏览工具变得很容易。例如，一个简单的内容文档的列表，可以将文档重定向到一个单独的窗口： 12&lt;a href=\"https://www.bing.com\" target=\"view_window\"&gt;打开一个新的窗口，显示必应的首页HTML文档&lt;/a&gt;&lt;a href=\"https://www.baidu.com\" target=\"view_window\"&gt;在已经打开的窗口上，将必应的文档取代。显示百度的首页HTML文档&lt;/a&gt; 打开一个新的窗口，指向必应的新窗口 在已经打开的窗口上，将必应的文档取代。显示百度的首页HTML文档 当用户第一次选择内容列表中的某个链接时，浏览器将打开一个新的窗口，将它标记为 “view_window”，然后在其中显示希望显示的文档内容。如果用户从这个内容列表中选择另一个链接，且这个 “view_window” 仍处于打开状态，浏览器就会再次将选定的文档载入那个窗口，取代刚才的那些文档。 在整个过程中，这个包含了内容列表的窗口是用户可以访问的。通过单击窗口中的一个连接，可使另一个窗口的内容发生变化。 在框架中打开窗口不用打开一个完整的浏览器窗口，使用 target 更通常的方法是在一个 &lt;frameset&gt; 显示中将超链接内容定向到一个或者多个框架中。可以将这个内容列表放入一个带有两个框架的文档的其中一个框架中，并用这个相邻的框架来显示选定的文档： 12&lt;frame name=\"view\" src=\"\"&gt;&lt;a href=\"https://bing.com\" target=\"view\"&gt;在右边窗口打开必应首页&lt;/a&gt; 在右边窗口打开必应首页在右边窗口打开一张图片 语法1&lt;a target=&quot;value&quot;&gt; 属性值 值 描述 _blank 在新窗口中打开被链接文档。 _self 默认。在相同的框架中打开被链接文档。 _parent 在父框架集中打开被链接文档。 _top 在整个窗口中打开被链接文档。 framename 在指定的框架中打开被链接文档。 特殊的目标有 4 个保留的目标名称用作特殊的文档重定向操作： _blank浏览器总在一个新打开、未命名的窗口中载入目标文档。 _self这个目标的值对所有没有指定目标的 &lt;a&gt; 标签是默认目标，它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的，除非和文档标题 &lt;base&gt; 标签中的 target 属性一起使用。 _parent这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。 _top这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。 提示：这些 target 的所有 4 个值都以下划线开始。任何其他用一个下划线作为开头的窗口或者目标都会被浏览器忽略，因此，不要将下划线作为文档中定义的任何框架 name 或 id 的第一个字符。","link":"/2019/06/24/a%E6%A0%87%E7%AD%BE%E7%9A%84target%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"XML文档笔记（一）","text":"转载自： https://www.cnblogs.com/catgatp/p/6403382.html &lt;![CDATA[]]&gt;和转义字符被&lt;![CDATA[]]&gt;这个标记所包含的内容将表示为纯文本，比如&lt;![CDATA[&lt;]]&gt;表示文本内容“&lt;”。 此标记用于xml文档中，我们先来看看使用转义符的情况。我们知道，在xml中，”&lt;”、”&gt;”、”&amp;”等字符是不能直接存入的，否则xml语法检查时会报错，如果想在xml中使用这些符号，必须将其转义为实体，如”&lt;”、”&gt;”、”&amp;”，这样才能保存进xml文档。 在使用程序读取的时候，解析器会自动将这些实体转换回”&lt;”、”&gt;”、”&amp;”。举个例子： &lt;age&gt; age &lt; 30 &lt;/age&gt; 上面这种写法会报错，应该这样写： &lt;age&gt; age&amp;lt;30 &lt;/age&gt; 值得注意的是： (1)转义序列字符之间不能有空格； (2) 转义序列必须以”;”结束； (3) 单独出现的”&amp;”不会被认为是转义的开始； (4) 区分大小写。 在XML中，需要转义的字符有： (1)&amp; &amp;amp; (2)&lt; &amp;lt; (3)&gt; &amp;gt; (4)＂ &amp;quot; (5)＇ &amp;apos; 但是严格来说，在XML中只有”&lt;”和”&amp;”是非法的，其它三个都是可以合法存在的，但是，把它们都进行转义是一个好的习惯。 不管怎么样，转义前的字符也好，转义后的字符也好，都会被xml解析器解析，为了方便起见，使用&lt;![CDATA[]]&gt;来包含不被xml解析器解析的内容。但要注意的是： (1) 此部分不能再包含”]]&gt;”； (2) 不允许嵌套使用； (3)”]]&gt;”这部分不能包含空格或者换行。 最后，说说&lt;![CDATA[]]&gt;和xml转移字符的关系，它们两个看起来是不是感觉功能重复了？ 是的，它们的功能就是一样的，只是应用场景和需求有些不同： (1)&lt;![CDATA[]]&gt;不能适用所有情况，转义字符可以； (2) 对于短字符串&lt;![CDATA[]]&gt;写起来啰嗦，对于长字符串转义字符写起来可读性差； (3) &lt;![CDATA[]]&gt;表示xml解析器忽略解析，所以更快。","link":"/2019/07/02/XML%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"使用Postman测试SOAP接口","text":"使用Postman发出SOAP请求我们知道它说的是Postman“REST”客户端，但这并不意味着我们不能将其用于发出SOAP请求。通过执行以下简单步骤，可以轻松地使用Postman发出任何HTTP SOAP请求： 链接地址Making SOAP requests using PostmanPostman makes SOAP requests too","link":"/2019/10/25/%E4%BD%BF%E7%94%A8Postman%E6%B5%8B%E8%AF%95SOAP%E6%8E%A5%E5%8F%A3/"},{"title":"sqlserver查询使用with(nolock)","text":"sqlserver中，一张表会因为频繁的进行select、delete、insert操作而导致死锁。 记录一次数据库死锁在自己负责的一个业务中，有一张表因为会进行频繁的select、delete、insert。导致报了死锁的错：检验结果存储失败：事务(进程 ID 56)与另一个进程被死锁在 锁 | 通信缓冲区 资源上，并且已被选作死锁牺牲品。请重新运行该事务。SQL:delete LIS_RESULT_CG where JYLSH=’************’ 参考文章 select死锁问题sqlserver查询使用with(nolock)详解WITH(NOLOCK)与WITH(READPAST)共享锁（S锁）和排它锁（X锁）SQL SERVER SELECT语句中加锁选项的详细说明","link":"/2019/11/18/sqlserver%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8with-nolock/"},{"title":"为什么一到毕业就要经历生离死别","text":"","link":"/2019/07/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%88%B0%E6%AF%95%E4%B8%9A%E5%B0%B1%E8%A6%81%E7%BB%8F%E5%8E%86%E7%94%9F%E7%A6%BB%E6%AD%BB%E5%88%AB/"},{"title":"拖延症的改善(一)","text":"拖延症在意识到拖延症已经严重影响到了生活后，我开始尝试改善这个十几年的毛病。 养成一个小习惯改善拖延症，尝试过制定每天的行程，通过闹钟严格控制自己。刚开始的时候确实有成效，但都坚持不了几周，自己慢慢失去动力。这种方式的中，人是被动的。 健身 拖延一个很简单只需要花费几分钟的动作，在坚持一到两天就能看到效果，或者感受到效果。这会给与我一个很强大的正反馈。付出和收获反馈很及时，这会在一定程度上，促使我主动去做，以为在我潜意识里只要我今天做了这个动作，我明天身体的某块地方就会改变，并且能被我感受到，捕捉到这个变化，一个很健康的正反馈循环会是我转守为攻，自己会监督自己去每天做这个动作。它在很大程度上改善了我的拖延。 这样的习惯养成后，能改善我自身的思维和心态。它会促使我潜意识觉得，每天坚持做一些事情，是会有益与我的，自身能接受的付出和收获的间隔长度也会慢慢变长。 健身改善了我的生活。 [EOF]","link":"/2020/08/07/%E6%8B%96%E5%BB%B6%E7%97%87%E7%9A%84%E6%94%B9%E5%96%84-%E4%B8%80/"},{"title":"SQL语句中的N&#39;xxxx&#39;是什么意思","text":"https://www.cnblogs.com/wanshutao/p/4128016.html","link":"/2020/06/01/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84N-xxxx-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"},{"title":"关于json.stringfy不兼容ie8操作","text":"IE低版本 JSON.parse 和stringify 的兼容 （IE8以下）解决IE8以下低版本实现JSON.parse()与JSON.stringify()的兼容关于 json.stringfy不兼容ie8操作","link":"/2019/12/10/%E5%85%B3%E4%BA%8Ejson-stringfy%E4%B8%8D%E5%85%BC%E5%AE%B9ie8%E6%93%8D%E4%BD%9C/"},{"title":"最近感受到的压力","text":"","link":"/2020/09/10/%E6%9C%80%E8%BF%91%E6%84%9F%E5%8F%97%E5%88%B0%E7%9A%84%E5%8E%8B%E5%8A%9B/"},{"title":"CMD start command","text":"by SRINI Start command可用于在另一个命令窗口中运行command/batch（批处理文件）或从命令行启动应用程序。您可以在下面找到该命令的语法和一些示例。 启动另一个命令窗口： 1start cmd 该命令将打开一个新的命令提示符窗口。 在单独的窗口中运行命令 1Start command 该命令将打开一个新的命令窗口，并运行指定的命令。如果命令是GUI应用程序，则将在没有任何新命令窗口的情况下启动该应用程序。 例子：启动新的命令窗口并运行dir命令： 1Start dir 在另一个窗口中运行命令，并在命令执行后终止： 1234567start cmd /c command````例如，要在另一个命令窗口中运行批处理文件并在批处理文件执行完成后关闭该窗口，命令将为：``` CMDStart cmd /c C:\\mybatchfile.bat 在同一窗口中运行命令： 1Start /b command 像在Linux中使用”&amp;”一样，在后台运行命令： 在Windows中，我们可以使用start命令执行类似的操作。但是在这里它不是在后台运行的。一个新的命令窗口将执行指定的命令，而当前窗口将返回以提示执行下一个命令。 123Start command(or)Start batchfile.bat 启动GUI应用程序： 1Start application 例如，要启动Chrome，我们可以使用以下命令: 1Start Chrome 在当前目录中打开Windows资源管理器：: 1start .","link":"/2021/05/07/CMD-Start-Command/"},{"title":"2020人口普查随笔","text":"男女比例的不平衡，以及人口出生率的降低，感觉一定程度上可以使用进化论的来解释。从古至今，人类都存在淘汰，野人时期，身体素质不够高，打不到足够的猎物就是饿死，到了封建时期，第一看投胎，第二就看自己够不够努力（只看生存能力,坑蒙拐骗也算本领）。而到了现在也是如此，第一看投胎，第二看自身。自古如此，人类的基因也在随着时间的变化而被筛选，更能适应社会的，能够获取到异性的注意力的人，他们的基因将会更好的流传下去，而一些从经济、思想、为人上无法获取到异性的青睐时，他们的基因从某种意义上来讲，也算是被自然所淘汰。 没钱的人只能单身","link":"/2021/05/11/2020%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5%E9%9A%8F%E7%AC%94/"},{"title":"转载—数据库锁的概念","text":"锁的概述一. 为什么要引入锁多个用户同时对数据库的并发操作时会带来以下数据不一致的问题: 丢失更新A,B两个用户读同一数据并进行修改,其中一个用户的修改结果破坏了另一个修改的结果,比如订票系统 脏读A用户修改了数据,随后B用户又读出该数据,但A用户因为某些原因取消了对数据的修改,数据恢复原值,此时B得到的数据就与数据库内的数据产生了不一致 不可重复读A用户读取数据,随后B用户读出该数据并修改,此时A用户再读取数据时发现前后两次的值不一致 并发控制的主要方法是封锁,锁就是在一段时间内禁止用户做某些操作以避免产生数据不一致 二 锁的分类锁的类别有两种分法： 从数据库系统的角度来看：分为独占锁（即排它锁），共享锁和更新锁 MS-SQL Server 使用以下资源锁模式。 锁模式描述:共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。更新 (U) 用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。排它 (X) 用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。意向锁 用于建立锁的层次结构。意向锁的类型为：意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。架构锁 在执行依赖于表架构的操作时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)。大容量更新 (BU) 向表中大容量复制数据并指定了 TABLOCK 提示时使用。共享锁共享 (S) 锁允许并发事务读取 (SELECT) 一个资源。资源上存在共享 (S) 锁时，任何其它事务都不能修改数据。一旦已经读取数据，便立即释放资源上的共享 (S) 锁，除非将事务隔离级别设置为可重复读或更高级别，或者在事务生存周期内用锁定提示保留共享 (S) 锁。 更新锁更新 (U) 锁可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享 (S) 锁，然后修改行，此操作要求锁转换为排它 (X) 锁。如果两个事务获得了资源上的共享模式锁，然后试图同时更新数据，则一个事务尝试将锁转换为排它 (X) 锁。共享模式到排它锁的转换必须等待一段时间，因为一个事务的排它锁与其它事务的共享模式锁不兼容；发生锁等待。第二个事务试图获取排它 (X) 锁以进行更新。由于两个事务都要转换为排它 (X) 锁，并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。 若要避免这种潜在的死锁问题，请使用更新 (U) 锁。一次只有一个事务可以获得资源的更新 (U) 锁。如果事务修改资源，则更新 (U) 锁转换为排它 (X) 锁。否则，锁转换为共享锁。 排它锁排它 (X) 锁可以防止并发事务对资源进行访问。其它事务不能读取或修改排它 (X) 锁锁定的数据。 意向锁意向锁表示 SQL Server 需要在层次结构中的某些底层资源上获取共享 (S) 锁或排它 (X) 锁。例如，放置在表级的共享意向锁表示事务打算在表中的页或行上放置共享 (S) 锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它 (X) 锁。意向锁可以提高性能，因为 SQL Server 仅在表级检查意向锁来确定事务是否可以安全地获取该表上的锁。而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。 意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。 锁模式 描述意向共享 (IS) 通过在各资源上放置 S 锁，表明事务的意向是读取层次结构中的部分（而不是全部）底层资源。意向排它 (IX) 通过在各资源上放置 X 锁，表明事务的意向是修改层次结构中的部分（而不是全部）底层资源。IX 是 IS 的超集。与意向排它共享 (SIX) 通过在各资源上放置 IX 锁，表明事务的意向是读取层次结构中的全部底层资源并修改部分（而不是全部）底层资源。允许顶层资源上的并发 IS 锁。例如，表的 SIX 锁在表上放置一个 SIX 锁（允许并发 IS 锁），在当前所修改页上放置 IX 锁（在已修改行上放置 X 锁）。虽然每个资源在一段时间内只能有一个 SIX 锁，以防止其它事务对资源进行更新，但是其它事务可以通过获取表级的 IS 锁来读取层次结构中的底层资源。 独占锁：只允许进行锁定操作的程序使用，其他任何对他的操作均不会被接受。执行数据更新命令时，SQL Server会自动使用独占锁。当对象上有其他锁存在时，无法对其加独占锁。共享锁：共享锁锁定的资源可以被其他用户读取，但其他用户无法修改它，在执行Select时，SQL Server会对对象加共享锁。更新锁：当SQL Server准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到SQL Server确定要进行更新数据操作时，他会自动将更新锁换为独占锁，当对象上有其他锁存在时，无法对其加更新锁。 从程序员的角度看：分为乐观锁和悲观锁。乐观锁：完全依靠数据库来管理锁的工作。悲观锁：程序员自己管理数据或对象上的锁处理。 MS-SQLSERVER 使用锁在多个同时在数据库内执行修改的用户间实现悲观并发控制 三 锁的粒度锁粒度是被封锁目标的大小,封锁粒度小则并发性高,但开销大,封锁粒度大则并发性低但开销小 SQL Server支持的锁粒度可以分为为行、页、键、键范围、索引、表或数据库获取锁 资源 描述RID 行标识符。用于单独锁定表中的一行。键 索引中的行锁。用于保护可串行事务中的键范围。页 8 千字节 (KB) 的数据页或索引页。扩展盘区 相邻的八个数据页或索引页构成的一组。表 包括所有数据和索引在内的整个表。DB 数据库。 四 锁定时间的长短锁保持的时间长度为保护所请求级别上的资源所需的时间长度。 用于保护读取操作的共享锁的保持时间取决于事务隔离级别。采用 READ COMMITTED 的默认事务隔离级别时，只在读取页的期间内控制共享锁。在扫描中，直到在扫描内的下一页上获取锁时才释放锁。如果指定 HOLDLOCK 提示或者将事务隔离级别设置为 REPEATABLE READ 或 SERIALIZABLE，则直到事务结束才释放锁。 根据为游标设置的并发选项，游标可以获取共享模式的滚动锁以保护提取。当需要滚动锁时，直到下一次提取或关闭游标（以先发生者为准）时才释放滚动锁。但是，如果指定 HOLDLOCK，则直到事务结束才释放滚动锁。 用于保护更新的排它锁将直到事务结束才释放。如果一个连接试图获取一个锁，而该锁与另一个连接所控制的锁冲突，则试图获取锁的连接将一直阻塞到： 将冲突锁释放而且连接获取了所请求的锁。 连接的超时间隔已到期。默认情况下没有超时间隔，但是一些应用程序设置超时间隔以防止无限期等待 五 SQL Server 中锁的自定义1 处理死锁和设置死锁优先级 死锁就是多个用户申请不同封锁,由于申请者均拥有一部分封锁权而又等待其他用户拥有的部分封锁而引起的无休止的等待 可以使用SET DEADLOCK_PRIORITY控制在发生死锁情况时会话的反应方式。如果两个进程都锁定数据，并且直到其它进程释放自己的锁时，每个进程才能释放自己的锁，即发生死锁情况。 2 处理超时和设置锁超时持续时间。 @@LOCK_TIMEOUT 返回当前会话的当前锁超时设置，单位为毫秒 SET LOCK_TIMEOUT 设置允许应用程序设置语句等待阻塞资源的最长时间。当语句等待的时间大于 LOCK_TIMEOUT 设置时，系统将自动取消阻塞的语句，并给应用程序返回”已超过了锁请求超时时段”的 1222 号错误信息 示例下例将锁超时期限设置为 1,800 毫秒。SET LOCK_TIMEOUT 1800 设置事务隔离级别。 4 ) 对 SELECT、INSERT、UPDATE 和 DELETE 语句使用表级锁定提示。 配置索引的锁定粒度可以使用 sp_indexoption 系统存储过程来设置用于索引的锁定粒度 六 查看锁的信息1 执行 EXEC SP_LOCK 报告有关锁的信息2 查询分析器中按Ctrl+2可以看到锁的信息 七 使用注意事项如何避免死锁1 使用事务时，尽量缩短事务的逻辑处理过程，及早提交或回滚事务；2 设置死锁超时参数为合理范围，如：3分钟-10分种；超过时间，自动放弃本次操作，避免进程悬挂；3 优化程序，检查并避免死锁现象出现；4 .对所有的脚本和SP都要仔细测试，在正是版本之前。5 所有的SP都要有错误处理（通过@error）6 一般不要修改SQL SERVER事务的默认级别。不推荐强行加锁 解决问题 如何对行 表 数据库加锁 八 几个有关锁的问题1 如何锁一个表的某一行 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED SELECT * FROM table ROWLOCK WHERE id = 1 2 锁定数据库的一个表 SELECT * FROM table WITH (HOLDLOCK) 加锁语句：sybase:update 表 set col1=col1 where 1=0 ;MSSQL:select col1 from 表 (tablockx) where 1=0 ;oracle:LOCK TABLE 表 IN EXCLUSIVE MODE ；加锁后其它人不可操作，直到加锁用户解锁，用commit或rollback解锁 几个例子帮助大家加深印象设table1(A,B,C)A B Ca1 b1 c1a2 b2 c2a3 b3 c3 1）排它锁新建两个连接在第一个连接中执行以下语句begin tranupdate table1set A=’aa’where B=’b2’waitfor delay ‘00:00:30’ –等待30秒commit tran在第二个连接中执行以下语句 1234begin tran select * from table1 where B='b2' commit tran 若同时执行上述两个语句，则select查询必须等待update执行完毕才能执行即要等待30秒 2）共享锁在第一个连接中执行以下语句 12345begin tran select * from table1 holdlock -holdlock人为加锁 where B='b2' waitfor delay '00:00:30' --等待30秒 commit tran 在第二个连接中执行以下语句 1234567begin tran select A,C from table1 where B='b2' update table1 set A='aa' where B='b2' commit tran 若同时执行上述两个语句，则第二个连接中的select查询可以执行而update必须等待第一个事务释放共享锁转为排它锁后才能执行 即要等待30秒 3）死锁 1234增设table2(D,E) D E d1 e1 d2 e2 在第一个连接中执行以下语句 123456789begin tran update table1 set A='aa' where B='b2' waitfor delay '00:00:30' update table2 set D='d5' where E='e1' commit tran 在第二个连接中执行以下语句 123456789begin tran update table2 set D='d5' where E='e1' waitfor delay '00:00:10' update table1 set A='aa' where B='b2' commit tran 同时执行，系统会检测出死锁，并中止进程 补充一点:Sql Server2000支持的表级锁定提示 HOLDLOCK 持有共享锁，直到整个事务完成，应该在被锁对象不需要时立即释放，等于SERIALIZABLE事务隔离级别 NOLOCK 语句执行时不发出共享锁，允许脏读 ，等于 READ UNCOMMITTED事务隔离级别 PAGLOCK 在使用一个表锁的地方用多个页锁 READPAST 让sql server跳过任何锁定行，执行事务，适用于READ UNCOMMITTED事务隔离级别只跳过RID锁，不跳过页，区域和表锁 ROWLOCK 强制使用行锁 TABLOCKX 强制使用独占表级锁，这个锁在事务期间阻止任何其他事务使用这个表 UPLOCK 强制在读表时使用更新而不用共享锁 应用程序锁:应用程序锁就是客户端代码生成的锁，而不是sql server本身生成的锁 处理应用程序锁的两个过程 sp_getapplock 锁定应用程序资源 sp_releaseapplock 为应用程序资源解锁 注意: 锁定数据库的一个表的区别 123SELECT * FROM table WITH (HOLDLOCK) 其他事务可以读取表，但不能更新删除 SELECT * FROM table WITH (TABLOCKX) 其他事务不能读取表,更新和删除","link":"/2020/11/27/%E8%BD%AC%E8%BD%BD%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5/"},{"title":"一句话","text":"自己下定决心到达成某个目标时，不要和别人说，等自己完成后再说","link":"/2021/05/17/%E4%B8%80%E5%8F%A5%E8%AF%9D/"},{"title":"Win10中文语言下添加美式键盘","text":"个人操作习惯使用Ctrl+Shift切换键盘布局，但是win10的更新会经常性导致输入法的问题出现。下面是一些平时收集到的方法。 20H2版本无法通过修改注册表实现添加美式键盘，目前使用Silence的工具箱博主开发的工具进行修改 日期 使用版本 链接 2021-7-20 V0.9.2.0 TSFTool V0.9.2.0 输入法设置工具 20H2以前的版本通过注册表可以正常添加美式键盘布局。 来源：https://www.itsk.com/thread-413229-1-1.html 2021-7-20.reg12345678910111213141516171819Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Keyboard Layout\\Preload]\"1\"=\"00000804\"[HKEY_CURRENT_USER\\Keyboard Layout\\Substitutes]\"00000804\"=\"00000409\"[HKEY_USERS\\.DEFAULT\\Keyboard Layout\\Preload]\"1\"=\"00000804\"[HKEY_USERS\\.DEFAULT\\Keyboard Layout\\Substitutes]\"00000804\"=\"00000409\"[HKEY_CURRENT_USER\\Control Panel\\International\\User Profile]\"InputMethodOverride\"=\"0804:00000409\"[HKEY_CURRENT_USER\\Control Panel\\International\\User Profile\\zh-Hans-CN]\"0804:00000409\"=dword:00000001","link":"/2021/07/20/Win1020H2%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%BE%8E%E5%BC%8F%E9%94%AE%E7%9B%98/"},{"title":"服务器设置系统启动时程序自动运行（不需要登录）","text":"写在前面本方法不适用于winform、WPF等UI程序。涉及到windows系统的用户会话管理的策略。Windows系统中存在一个特殊的 Session，其 Session ID 为 0。这通常称为 Session0。所有 Windows 服务都在 Session0 中运行，并且 Session0 是非交互式的。非交互式意味着无法启动 UI 应用程序； 1. 通过组策略设置脚本随服务器启动打开组策略编辑器 找到 计算机配置-&gt;Windows设置-&gt;脚本（启动/关机） 选中启动 将下列脚本添加进去，配置好启动程序路径的参数： start.bat1234567@echo offREM 声明采用UTF-8编码chcp 65001@REM pauseset input=%1%echo 自启动程序路径参数:%input%start %input% 2. 使用任务计划程序需要注意的时，在选择用户执行时，如果创建任务的用户为Administrator，需要注意执行时的用户账户，如果是需要在服务器启动时运行，就不应该为Administrator，而是应该为SYSTEM。 参考资料： Windows Server 2012的服务管理自动化 windows2008服务器设置系统启动时程序自动运行 碰见的问题： Windows Scheduled Task - Error 2147943711 for “on startup” task Task scheduler can’t show GUI of the application after login (Run whether user is logged on or not mode) - How bypass it with C# 界面显示问题： According to Microsoft (emphasis added): You can specify that a task should run even if the account under which the task is scheduled to run is not logged on when the task is triggered. To do this, select the radio button labeled Run whether user is logged on or not . If this radio button is selected, tasks will not run interactively. To make a task run interactively, select the Run only when user is logged on radio button. Essentially, if you select ‘Run whether user is logged on or not’, the process will not start a UI.","link":"/2021/07/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%97%B6%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%EF%BC%88%E4%B8%8D%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95%EF%BC%89/"},{"title":"PDI【Kettle】（一）","text":"转换组件-脚本-JavaScript【Spoon】我们在使用JavaScript组件的时候,在左侧核心树对象栏中可以看到Kettle为我们提供了很多简洁强大的内置函数,帮助我们在写脚本的时候对数据、参数变量等能很轻松的做处理,体验编码的感觉.本篇将详细介绍JavaScript组件中的函数功能 脚本组件包含的函数主要包括六大类,分别是： 字符串类型的函数(String Functions) 浮点型的函数(Numeric Functions) 日期类型函数(Date Functions) 逻辑判断型函数(Logic Functions) 特殊的函数(Special Functions) 文件处理类函数(File Functions) 字符串类型函数(String Functions)顾名思义,字符串类型的函数肯定是针对字符串类型的参数、变量进行处理操作的函数 日期转字符串(date2str)日期转字符串函数date2str主要有4个方法,分别是： date2str(date):传入日期实例,转换成字符串类型 date2str(date,format):传入日期和格式化参数,进行格式化转换 date2str(date,format,iso):传入日期和参数格式化及ISO代码进行转换,(DE = German, EN = English, FR = France, …) date2str(date,format,iso,zone):传入时区进行格式化,例如北京时区(GMT+8) 日期格式化参数format参数类型供参考： 1234567yy / yyyy - 06 / 2006MM / MMM / MMMMM - 11 / Nov / Novemberd / dd - 1 / 01E / EEEE - Tue / Tuesdayhh / HH - 11 / 23m / mm - 5 / 05s / ss - 8 / 08 代码示例: 1234567var dValue = new Date();writeToLog(date2str(dValue,\"dd.MM.yyyy\"));writeToLog(date2str(dValue,\"dd.MM.yyyy HH:mm:ss\"));writeToLog(date2str(dValue,\"E.MMM.yyyy\",\"DE\"));writeToLog(date2str(dValue,\"dd.MM.yyyy HH:mm:ss\",\"EN\"));writeToLog(date2str(dValue,\"dd.MM.yyyy HH:mm:ss\",\"ZH\", \"GMT+8\"));writeToLog(date2str(dValue,\"yyyy-MM-dd HH:mm:ss\",\"ZH\", \"GMT+8\")); 以上代码在控制台将会输出如下： 1234562019/08/19 10:12:56 - JavaScript代码.0 - 19.08.20192019/08/19 10:12:56 - JavaScript代码.0 - 19.08.2019 10:12:562019/08/19 10:12:56 - JavaScript代码.0 - Mo.Aug.20192019/08/19 10:12:56 - JavaScript代码.0 - 19.08.2019 10:12:562019/08/19 10:12:56 - JavaScript代码.0 - 19.08.2019 10:12:562019/08/19 10:12:56 - JavaScript代码.0 - 2019-08-19 10:12:56 转义HTMLescapeHtml(html)代码如下： 123var html=\"&lt;h1&gt;我是H2标题&lt;/h2&gt;\";writeToLog(escapeHtml(html)) 最终输出 12019/08/19 10:16:13 - JavaScript代码.0 - &amp;lt;h1&amp;gt;&amp;#25105;&amp;#26159;H2&amp;#26631;&amp;#39064;&amp;lt;/h2&amp;gt; 转义SQL(escapeSQL(var))12var str1 = \"SELECT * FROM CUSTOMER WHERE NAME='\" + escapeSQL(\"McHale's Navy\") + \"'\"; writeToLog(str1) 该函数会把单引号转成双引号,输出结果如下： 12019/08/19 10:18:59 - JavaScript代码.0 - SELECT * FROM CUSTOMER WHERE NAME='McHale''s Navy' 构造定长字符串(fillString(char,length))代码示例如下： 12writeToLog(fillString(\"x\",10));writeToLog(fillString(\"A\",3)); 最终会输出10个X和3个A,输出结果如下： 122019/08/19 10:24:08 - JavaScript代码.0 - xxxxxxxxxx2019/08/19 10:24:08 - JavaScript代码.0 - AAA 需要注意的是第一个是一个char类型的单字符,不能是字符串 统计字符串出现频次(getOcuranceString(str,searchStr))第一个参数是要搜索的完整字符串,第二个参数是要搜索统计的字符串 代码示例： 1234var sef='2007-09-11';writeToLog(getOcuranceString(sef,'0'))writeToLog(getOcuranceString(sef,'00')) 我们分别统计字符串0和00最终出现的次数,此时,日志最终打印的次数是3和1： 122019/08/19 10:28:45 - JavaScript代码.0 - 32019/08/19 10:28:45 - JavaScript代码.0 - 1 获取字符串下标索引(indexOf)获取下标索引主要有2个重构函数,分别是： indexOf(string,subString):获取出现字符串的索引开始位置 indexOf(string,subString,fromIndex)；指定开始位置,获取字符串索引开始位置 代码示例： 123456var str1= \"Hello Pentaho!\";var str2= indexOf(str1, \"Pentaho\");var str3= indexOf(str1, \"o\", 7);writeToLog(\"Input : \" + str1);writeToLog(\"Index of 'Pentaho' : \" + str2);writeToLog(\"index of 'o', search from position 7 : \" + str3); 最终控制台输出： 1232019/08/19 10:34:16 - JavaScript代码.0 - Input : Hello Pentaho!2019/08/19 10:34:16 - JavaScript代码.0 - Index of 'Pentaho' : 62019/08/19 10:34:16 - JavaScript代码.0 - index of 'o', search from position 7 : 12 首字母大写(initCap)对指定字符串首字母大写处理,来看代码示例： 1234var str1 = \"my home\"; writeToLog(initCap(str1));writeToLog(initCap('test a aaa cw'));writeToLog(initCap('myhome')); 此时,最终控制台输出如下： 1232019/08/19 10:41:27 - JavaScript代码.0 - My Home2019/08/19 10:41:27 - JavaScript代码.0 - Test A Aaa Cw2019/08/19 10:41:27 - JavaScript代码.0 - Myhome 字符串转小写(lower)将传入字符串全部转小写 代码如下： 12345var str1= \"Hello World!\";var str2= lower(str1);writeToLog(\"Input:\" + str1);writeToLog(\"Converted to LowerCase:\" + str2);writeToLog(lower('DDDHelloSWxss')) 响应内容 1232019/08/19 10:43:09 - JavaScript代码.0 - Input:Hello World!2019/08/19 10:43:09 - JavaScript代码.0 - Converted to LowerCase:hello world!2019/08/19 10:43:09 - JavaScript代码.0 - dddhelloswxss 字符串填充左侧(lpad(string,char,length))用指定长度的给定字符将字符串填充到左侧 参数定义： 1：传入字符串 2：填充单字符 3：填充单字符长度 如果length长度超过给定字符串的长度,将对填充字符串做减法，例如： 12var str1= \"Hello World!\"; writeToLog(\"Lpad:\" + lpad(str1, \"x\",20)); 此时,最终输出结果为： 12019/08/19 10:46:38 - JavaScript代码.0 - Lpad:xxxxxxxxHello World! 最终的完成长度是20个字符长度,因此填充的单字符x并没有填充20次 如果length长度小于给定字符串的长度,则默认返回原字符串,不做填充,代码示例： 12var str1= \"Hello World!\"; writeToLog(\"Lpad:\" + lpad(str1, \"x\",5)); 此时最终的输出结果为： 12019/08/19 10:46:38 - JavaScript代码.0 - Lpad:Hello World! 去空字符(ltrim)从左侧开始去除空字符串 数字转字符串(num2str)给定数字,转换为字符串,主要有3个构造函数： num2str(num):转换num数字为字符串 num2str(num,format):格式化数字为指定字符串 num2str(num,format,iso):按照本地ISO编码进行格式化 代码示例如下： 123456var d1 = 123.40;var d2 = -123.40;writeToLog(num2str(d1));writeToLog(num2str(d1, \"0.00\"));writeToLog(num2str(d1, \"0.00\", \"EN\"));writeToLog(num2str(d2, \"0.00;(0.00)\", \"EN\")); 最终控制台输出： 12342019/08/19 11:00:17 - JavaScript代码.0 - 123.42019/08/19 11:00:17 - JavaScript代码.0 - 123.402019/08/19 11:00:17 - JavaScript代码.0 - 123.402019/08/19 11:00:17 - JavaScript代码.0 - (123.40) XML保护标签函数转换(protectXMLCDATA)传入给定字符串,添加标准保护,代码示例 12var str1 = \"my home\"; writeToLog(protectXMLCDATA(str1)); 此时,将会给变量str1加上保护标签 12019/08/19 11:02:09 - JavaScript代码.0 - &lt;![CDATA[my home]]&gt; 移除字符串中CRLF字符(removeCRLF(str))给定字符串中删除CR END LF的字符串 替换字符串(replace)替换字符串主要包括两个构造函数： replace(str,searchStr,replaceStr):从指定字符串中查询，然后替换 replace(str,firstSearch,firstReplace,secondSearch,SecondReplace...)：无限查询替换 代码示例如下： 12345var str1 = \"Hello World, this is a nice function\"; var str2 = replace(str1,\"World\", \"Folk\");writeToLog(str2);var str2 = replace(str1,\"World\", \"Folk\", \"nice\",\"beautifull\");writeToLog(str2); 最终输出: 122019/08/19 11:10:21 - JavaScript代码.0 - Hello Folk, this is a nice function2019/08/19 11:10:21 - JavaScript代码.0 - Hello Folk, this is a beautifull function 字符串右侧填充(rpad(string,char,length))使用方法同lpad,只是一个是左侧，一个是右侧 去除空字符(右侧)(rtrim)正则切分(str2RegExp)出入一个正则表达式,对string字符串进行Split操作.代码如下： 123456789101112var strToMatch = \"info@proconis.de\";var strReg = \"^(\\\\w+)@([a-zA-Z_]+?)\\\\.([a-zA-Z]{2,3})$\";var xArr = str2RegExp(strToMatch, strReg);if ( xArr != null ) { for(i=0;i&lt;xArr.length;i++) { writeToLog(xArr[i]); }}else { writeToLog(\"no match\");} 最终控制台输出： 1232019/08/19 13:21:19 - JavaScript代码.0 - info2019/08/19 13:21:19 - JavaScript代码.0 - proconis2019/08/19 13:21:19 - JavaScript代码.0 - de 字符串截取(substr)通过制定索引开始对字符串进行截取操作,主要有两个重构参数： substr(string,from):指定from索引开始截取字符串 substr(string,from,to):指定开始和截止索引进行截取 代码示例： 123456var str1= \"Hello Pentaho!\";var str2= substr(str1, 6);var str3= substr(str1, 6, 7);writeToLog(\"Input : \" + str1);writeToLog(\"From position 6: \" + str2);writeToLog(\"From position 6 for 7 long : \" + str3); 控制台输出如下： 1232019/08/19 13:31:20 - JavaScript代码.0 - Input : Hello Pentaho!2019/08/19 13:31:20 - JavaScript代码.0 - From position 6: Pentaho!2019/08/19 13:31:20 - JavaScript代码.0 - From position 6 for 7 long : Pentaho 去除左右空格(trim)不转义HTML(unEscapeHtml(html))针对以转义的HTML字符进行解密,代码如下： 1234567var w='&lt;h2&gt;我是H2标题&lt;/h2&gt;';var esW=escapeHtml(w);var unesw=unEscapeHtml(esW);writeToLog(esW);writeToLog(unesw); 最终控制台输出： 122019/08/19 13:38:16 - JavaScript代码.0 - &amp;lt;h2&amp;gt;&amp;#25105;&amp;#26159;H2&amp;#26631;&amp;#39064;&amp;lt;/h2&amp;gt;2019/08/19 13:38:16 - JavaScript代码.0 - &lt;h2&gt;我是H2标题&lt;/h2&gt; 解码转义XML(unEscapeXml )字符串转大写(upper)将传入字符串全部转大写.例如: 12var str=\"Hello World\";writeToLog(upper(str)); 浮点型的函数(Numeric Functions)计算绝对值(abs(num))计算一个数值的绝对值,代码示例： 1234var d1 = -1234.01;var d2 = 1234.01;writeToLog(abs(d1));writeToLog(abs(d2)); 最终控制台输出为： 122019/08/19 13:51:00 - JavaScript代码.0 - 1234.012019/08/19 13:51:00 - JavaScript代码.0 - 1234.01 最小双精度值(ceil(num))返回最小的双精度值。该值将被四舍五入。代码示例： 1234var d1 = -1234.01;var d2 = 1234.01;writeToLog(ceil(d1));writeToLog(ceil(d2)); 最终控制台输出： 122019/08/19 13:52:40 - JavaScript代码.0 - -12342019/08/19 13:52:40 - JavaScript代码.0 - 1235 最大数值(floor(num))返回最大数值,该值将被四舍五入,代码示例： 1234var d1 = -1234.01;var d2 = 1234.01;writeToLog(floor(d1));writeToLog(floor(d2)); 运行结果如下： 122019/08/19 13:55:13 - JavaScript代码.0 - -12352019/08/19 13:55:13 - JavaScript代码.0 - 1234 字符串转数值(str2num(var))字符串转数值主要包含两个构造函数,分别是 str2num(str):传入数值字符串,进行格式化转换 str2num(str,format):通过指定格式进行数值转换 代码示例如下： 1234var str1 = \"1.234,56\";var str2 = \"12\";writeToLog((str2num(str1,\"#,##0.00\")));writeToLog((str2num(str2))); 最终控制台输出： 122019/08/19 14:02:19 - JavaScript代码.0 - 1.2342019/08/19 14:02:19 - JavaScript代码.0 - 12 截取数值(trunc)1trunc(1234.9); // 返回 1234 日期类型函数(Date Functions)日期相加(dateAdd)针对日期变量进行相应的添加时间,添加频率包括年、月、日、时、分、秒 等等 函数定义:dateAdd(date,format,plusNum) date:日期对象 format:要加的类型 plusNum:加的数值 相加类型主要包括： y:年 m：月 d:日 w:周 wd:工作日 hh:小时 mi:分钟 ss:秒 代码示例如下： 1234567var d1 = new Date();var fmt='yyyy-MM-dd HH:mm:ss';writeToLog(\"当前时间:\"+date2str(d1,fmt));var py=dateAdd(d1,'y',1);var fy=date2str(py,fmt);writeToLog(\"加1年：\"+fy); 最终控制台输出： 122019/08/19 14:17:41 - JavaScript代码.0 - 当前时间:2019-08-19 14:17:412019/08/19 14:17:41 - JavaScript代码.0 - 加1年：2020-08-19 14:17:41 日期比较(dateDiff)两个日期相互比较 函数定义:dateDiff(startDate,endDate,type) startDate:开始日期 endDate:截止日期 type：返回相差数值类型 类型主要包括： y:年 m：月 d:日 w:周 wd:工作日 hh:小时 mi:分钟 ss:秒 获取指定日期数值(getDayNumber)根据类型获取指定日期的数值 函数定义：getDayNumber(date,type) date:当前日期实例 type:类别 类别主要分四类 y:获取当年的天数 m:获取当月的天数 w:获取本周的天数 wm:获取当月中本周的天数 代码示例： 12345var d1 = new Date();writeToLog(getDayNumber(d1, \"y\"));writeToLog(getDayNumber(d1, \"m\"));writeToLog(getDayNumber(d1, \"w\"));writeToLog(getDayNumber(d1, \"wm\")); getFiscalDate12345678910111213141516// Returns the fiscal Date from the date value,// based on a given offset.//// Usage:// getFiscalDate(var);// 1: Date - The Variable with the Date.// 2: String - The Date/Month which represents// the fiscal Start Offset. Format allways \"dd.MM.\".//// 2006-11-15//var d1 = new Date();var str1 = \"01.07.\";var str2 = \"10.12.\";Alert(getFiscalDate(d1, str1));Alert(getFiscalDate(d1, str2)); 获取下一个工作日日期(getNextWorkingDay)传入当前日期,获取该日期后面一个工作日日期 函数定义getNextWorkingDay(date) 代码示例如下： 12345678910var d1 = new Date();// 周1var d2=str2date('2019-08-19 16:36:00',fmt);//周 6var d3=str2date('2019-08-17 16:36:00',fmt);writeToLog(date2str(getNextWorkingDay(d1),fmt));writeToLog(date2str(getNextWorkingDay(d2),fmt));writeToLog(date2str(getNextWorkingDay(d3),fmt)); 我们这d2和d3变量中定义了不同的日期实例,分别是周1和周6,最终通过getNextWorkingDay能获取得到下一个工作日日期，控制台输出如下： 1232019/08/19 16:37:38 - JavaScript代码.0 - 2019-08-20 16:37:382019/08/19 16:37:38 - JavaScript代码.0 - 2019-08-20 16:36:002019/08/19 16:37:38 - JavaScript代码.0 - 2019-08-19 16:36:00 获取当前月份数值(month(date))获取当前日期的月份数值,需要注意的是,该值的月份是从0开始的,因此我们最终得到的结果应该+1才是我们的真实月份数值，代码示例： 12var d1 = new Date();//2019/08/19writeToLog(month(d1)); //最终输出为7 获取当前时间的季度值(quarter(date))根据指定日期获取当前季度数值 12var d1 = new Date();//2019/08/19writeToLog(quarter(d1));//最终输出为3(代表第三季度) 字符串转日期(str2date)字符串转日期和日期转字符串有点类似,只不过主体对换了一下,但是传入的格式参数都是一样的，主要有4个重载函数: str2date(str):默认转换 str2date(str,format):传入format格式化参数 str2date(str,format,iso):根据iso编码及格式化参数进行转换 str2date(str,format,iso,timezone):根据不同时区的iso编码进行格式化转换 代码示例如下： 12345writeToLog(str2date(\"01.12.2006\",\"dd.MM.yyyy\"));writeToLog(str2date(\"01.12.2006 23:23:01\",\"dd.MM.yyyy HH:mm:ss\"));writeToLog(str2date(\"Tue.May.2006\",\"E.MMM.yyyy\",\"EN\"));writeToLog(str2date(\"22.02.2008 23:23:01\",\"dd.MM.yyyy HH:mm:ss\",\"DE\"));writeToLog(str2date(\"22.02.2008 23:23:01\",\"dd.MM.yyyy HH:mm:ss\",\"DE\", \"EST\")); 截取日期(truncDate(date,type))指定截取不同的日期部分,函数定义truncDate(date,type) date:当前日期实例 type:截取类型 类型主要有6中,分别是整型，从0-5： 5：截取月份 4：截取天数 3:截取小时 2：截取分钟 1：截取秒 0:截取毫秒 代码示例 如下： 1234567var dateTime = new Date();var date0 = truncDate(dateTime, 0); // gives back today at yyyy/MM/dd HH:mm:ss.000var date1 = truncDate(dateTime, 1); // gives back today at yyyy/MM/dd HH:mm:00.000var date2 = truncDate(dateTime, 2); // gives back today at yyyy/MM/dd HH:00:00.000var date3 = truncDate(dateTime, 3); // gives back today at yyyy/MM/dd 00:00:00.000var date4 = truncDate(dateTime, 4); // gives back today at yyyy/MM/01 00:00:00.000var date5 = truncDate(dateTime, 5); // gives back today at yyyy/01/01 00:00:00.000 获取当年的周数(week)获取指定日期的周数,代码示例： 123var d1 = new Date(); //2019/08/19 writeToLog(week(d1));// 返回34 获取年份(year)获取传入日期的年份,代码示例： 123var d1 = new Date(); //2019/08/19 writeToLog(year(d1));// 返回2019 逻辑判断型函数(Logic Functions)isCodepage判断字符串的codepage项,代码示例： 123var xStr = \"RÃ©al\";writeToLog(isCodepage(xStr, \"UTF-8\"));// truewriteToLog(isCodepage(xStr, \"windows-1250\"));// true 是否日期(isDate(str))判断当前字符串是否日期 1234var d1 = \"Hello World\"; var d2 = new Date();writeToLog(isDate(d1));//falsewriteToLog(isDate(d2));//true 是否为空(isEmpty(str))判断字符串是否为空 12var d = \"Hello World\"; Alert(isEmpty(d));//false 判断字符串是否为邮箱标准格式(isMailValid(str))判断一个字符串是否是邮箱 判断是否是数值(isNum(str))判断一个字符串是否是数值 1234var str1 = \"Hello World\"; var str2 = 123456;Alert(isNum(str1));//falseAlert(isNum(str2));//true 是否正则匹配(isRegExp)判断给定的正则表达式是否匹配当前的字符串，主要有2个函数定义： isRegExp(str,reg):给定正则判断字符串是否匹配 isRegExp(str,reg1,reg2,reg3…)；可以递归判断正则匹配 最终返回的是匹配的次数数值,如果不匹配,返回-1 代码示例如下： 12345678910var email1 =\"info@proconis.de\";var email2= \"support@proconis.co.uk\";var email3= \"HelloWorld@x\";var reg1=\"^\\\\w+@[a-zA-Z_]+?\\\\.[a-zA-Z]{2,3}$\";var reg2=\"^[\\\\w-\\.]+@([\\\\w-]+\\\\.)+[\\\\w-]{2,4}$\";writeToLog(isRegExp(email1, reg1,reg2) + \" Matches\"); //1writeToLog(isRegExp(email2, reg1,reg2) + \" Matches\"); //2writeToLog(isRegExp(email3, reg1,reg2) + \" Matches\");// 1 是否工作日(isWorkingDay(date))判断某日期是否是工作日,代码示例： 1234var d1 = new Date();//周1var d2=str2date('2019-08-17','yyyy-MM-dd') //周六writeToLog(isWorkingDay(d1));//truewriteToLog(isWorkingDay(d2));//false 特殊的函数(Special Functions)弹框信息(Alert(msg))在屏幕前弹出一个信息框 加载JavaScript文件(LoadScriptFile)将一个javascript文件加载到实际的运行上下文中。应该从定义的StartScript调用此函数，否则，每次处理都会加载javascript文件行。 代码示例如下： 12var xPfad = \"F:/bak/Hello.js\";LoadScriptFile(xPfad); 此时,我们的外部JS文件仅仅是包含一句简单的输出，如下： 1writeToLog(\"Hello LoadScriptFile,outSide JS File \"); 最终运行时,控制台会打印出我们在外部JS中的输出行 从当前Tab栏加载JS并运行(LoadScriptFromTab)如果我们在当前的JavaScript组件中通过模块化的方式编写了很多脚本代码,我们可以通过LoadScriptFromTab函数进行相互调用,这对于开发抽象来说是很好的,代码示例如下： 12writeToLog(\"外部Tab加载JS-------------------------\")LoadScriptFromTab('Item_1'); 有效卡号判断(LuhnCheck)如果给定的是一个有效的卡号,则返回true 123456var str1 = \"4444333322221111\"; writeToLog(str1 + \": \" + LuhnCheck(str1)); //truevar str2 = \"4444333322221110\"; writeToLog(str2 + \": \" + LuhnCheck(str2));//false 向文件中追加数据(appendToFile)向指定文件中追加数据,如果文件不存在则创建文件 1234567var file = \"F:/bak/log.txt\";for(var i=0;i&lt;100;i++){ appendToFile(file,'TEST'+i+\"\\r\\n\");} 此时,该代码会向log.txt文件输出100条数据行 decode函数decode函数有点类似于IF-THEN-ELSE语句，即表示通过给定查询的字符串是否存在，如果存在，即替换,否则返回默认值 代码示例： 123456var str1 = \"Hallo\";writeToLog(decode(str1, \"Hallo\", \"Hello\"));writeToLog(decode(str1, \"1\", \"Mr\", \"2\", \"Mrs\", \"N/A\"));writeToLog(decode(str1, \"1\", \"Mr\", \"2\", \"Mrs\"));str1 = \"Mrs\";writeToLog(decode(str1, \"1\", \"Mr\", \"2\", \"Mrs\")); 控制台输出： 12342019/08/19 17:39:01 - JavaScript代码.0 - Hello2019/08/19 17:39:01 - JavaScript代码.0 - N/A2019/08/19 17:39:01 - JavaScript代码.0 - Hallo2019/08/19 17:39:01 - JavaScript代码.0 - Mrs 执行命令(execProcess)代码如下： 12var t=execProcess('ping www.baidu.com');writeToLog(t) 调用命令行,ping百度的网址，最终输出返回数据 执行SQL语句(fireToDB)通过获取数据库连接名称，传递SQL语句,以返回SQL查询的值,函数定义： fireToDB(connectionName,SQL)；第一个参数为数据库连接名称，我们在JNDI中定义的名称，第二个参数为SQL语句 123var strConn = \"MY Connection\";var strSQL = \"SELECT COUNT(*) FROM ...\";var xArr = fireToDB(strConn, strSQL); 仅仅获取数值(getDigitsOnly)在给定的字符串中仅仅筛选过滤得到数值，代码如下： 12var str1 = \"abc123cde\"; writeToLog(getDigitsOnly(str1));//返回123 获取Kettle环境变量的值(getEnvironmentVar)获取在Kettle中的环境变量的值 12writeToLog(getEnvironmentVar(\"user.dir\"));writeToLog(getEnvironmentVar(\"user.name\")); 获取当前进程的受影响行数(getProcessCount(type))根据类型获取当前进程的受影响行数，类型如下： u:更新行数 i:插入行数 w:写入行数 r:读取行数 o:输出行数 12writeToLog(getProcessCount(\"u\"));writeToLog(getProcessCount(\"r\")); 获取当前转换名称(getTransformationName)获取当前的转换名称 12var xTranName = getTransformationName();writeToLog(xTranName); 获取Kettle环境中的变量值(getVariable)从当前的Kettle环境中获取指定的变量值,目前函数有2个重载： getVariable(varName)；根据变量名称获取变量值 getVariable(varName,defaultValue):根据变量名获取值,如果不存在则使用默认值 12345678var strVarName=\"getVariableTest\";var strVarValue=\"123456\";Alert(getVariable(strVarName, \"\"));setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\"));strVarValue=\"654321\";setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\")); 控制台打印(println)123var str = \"Hello World!\";print(str); 移除数值(removeDigits)移除给定字符串中的数值，代码示例： 123var str1 = \"abc123cde\"; writeToLog(removeDigits(str1));//返回abccde 发送邮件设置环境变量(setEnvironmentVar)通过在Script脚本组件中调用函数重新设置Kettle的环境变量 12345678var strVarName=\"setEnvTest\";var strVarValue=\"123456\";Alert(getEnvironmentVar(strVarName));setEnvironmentVar(strVarName,strVarValue);Alert(getEnvironmentVar(strVarName));strVarValue=\"654321\";setEnvironmentVar(strVarName,strVarValue);Alert(getEnvironmentVar(strVarName)); 设置变量(setVariable)通过setVariable函数设置环境变量,该用途可以用于重新赋值Kettle环境中已经存在的变量值或者重新生成变量值 函数定义setVariable(key,value,level) key:变量名称 value:变量值 level:级别,主要包括s(system)、r(root)、p(parent)、g(grandparent)四种类别 代码示例如下： 12345678var strVarName=\"setEnvTest\";var strVarValue=\"123456\";Alert(getVariable(strVarName, \"\"));setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\"));strVarValue=\"654321\";setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\")); 写入日志(writeToLog)打印并写入日志信息,该函数可能是我们用到的最多的函数,可以帮助我们调试信息,主要有两个重载： writeToLog(msg):写入msg日志信息 writeToLog(level,msg)：根据level基本写入msg信息 关于日志的级别,这里主要是简写的方式,主要如下： d(Debug):调试模式 l(Detailed):详细 e(Error):错误 m(Minimal):最小日志 r(RowLevel):行级日志 12writeToLog(\"Hello World!\");writeToLog(\"r\", \"Hello World!\"); 文件处理类函数(File Functions)复制文件(copyFile)复制一个文件到目标目录,函数定义如下： copyFile(sourceFile,targetFile,overwrite) sourceFile:源文件 targetFile:目标文件 overWrite:是否覆盖,如果目标文件存在的话,布尔类型 12345var file1 = \"F:/bak/log.txt\";var targetFile=\"F:/bak/logTarget.txt\";copyFile(file1,targetFile,false) 创建文件夹(createFolder)创建一个文件夹,代码示例如下： 12var strFolder = \"F:/bak/createFolder\";createFolder(strFolder); 删除文件(deleteFile)删除一个文件(不能删除文件夹) 123var targetFile=\"F:/bak/logTarget.txt\"; deleteFile(targetFile); 判断文件是否存在(fileExists())判断文件是否存在 123var targetFile=\"F:/bak/logTarget.txt\"; fileExists(targetFile); 获取文件扩展名(getFileExtension)如果文件不存在,则返回null,代码示例 1234var file1 = \"F:/bak/log.txt\"; var ext=getFileExtension(file1);writeToLog(\"扩展名：\"+ext) 获取文件大小(getFileSize)获取文件大小,结果是一个long类型的长整型数值 1234var file1 = \"F:/bak/log.txt\"; var ext=getFileSize(file1);writeToLog(\"大小：\"+ext) 获取文件最后修改日期(getLastModifiedTime)获取文件最后修改日期,函数定义： getLastModifiedTime(filePath,format) filePath:文件路径 format：日期格式化 123var file1 = \"F:/bak/log.txt\"; var ext=getLastModifiedTime(file1,\"yyyy-MM-dd HH:mm:ss\"); 获取文件的父文件夹名称(getParentFoldername)获取文件的父文件夹名称 12var file1 = \"F:/bak/log.txt\";var parentFolder=getParentFoldername(file1); 获取文件简称(getShortName)获取文件简称 12345var file1 = \"F:/bak/log.txt\";var shortName=getShortFilename(file1);writeToLog(\"简单名称:\"+shortName)//返回log.txt 判断是否是一个文件(isFile)判断是否是一个文件 12var file1 = \"F:/bak/log.txt\";var flag=isFile(file1) //true 判断是否是一个文件夹(isFolder)判断是否是一个文件夹 12var file1 = \"F:/bak/log.txt\";var flag=isFolder(file1) //false 加载一个文件的内容(loadFileContent)从指定文件中加载内容,主要有两个重载函数： loadFileContent(filePath):默认加载文件 loadFileContent(filePath,encoding):指定编码加载文件内容 代码示例： 1234var file1 = \"F:/bak/log.txt\";var content=loadFileContent(file1);var c1=loadFileContent(file1,\"UTF-8\")writeToLog(content) 移动文件(moveFile)移动指定文件，函数定义moveFile(source,target,overWrite) source:源文件 target:目标文件 overWrite；是否覆盖,如果目标文件存在,布尔类型值 12345var file1 = \"F:/bak/log.txt\";var targetFile=\"F:/bak/logTarget.txt\";moveFile(file1,targetFile,false) 创建一个空文件(touch)创建一个空文件 12var strFile = \"F:/bak/log.txt\";touch(strFile); 总结以上就是Kettle 8.3版本中的内置函数方法,方法很多,写这篇博客也是很累,算是全部都学习了一遍,脑子里已经记忆了一遍,但是我们也不需要死记硬背,就和我们学些Linux命令一样,如果你知道man命令，对某个命令不是很了解的话直接通过man命令学习即可. Kettle也是如此,对于某个函数不是很了解的话,右键点击该函数,会出现sample字样菜单,点击该菜单即可弹出该函数的介绍和使用信息,里面包含了该函数的调用示例和函数详细介绍,也是很人性化的.","link":"/2021/07/29/Kettle/"},{"title":"SQLite学习【一】","text":"SQLite学习.sql123456789101112131415161718192021222324252627282930313233343536373839404142434445--创建数据库(数据库名可以是任何名字，文件类型始终为sqlite类型)sqlite3 test.sqlitesqlite3 other.dbsqlite3 db.sqlite3--创建数据表 增删改查 SQLiteCREATE TABLE DEPARTMENT( ID INT PRIMARY KEY NOT NULL, DEPT CHAR(50) NOT NULL, EMP_ID INT NOT NULL);CREATE TABLE Test( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL);SELECT * FROM sqlite_master WHERE type = 'table';DROP TABLE DEPARTMENT;SELECT * FROM sqlite_master WHERE type = 'table';--增INSERT INTO `Test` (ID, NAME, AGE, ADDRESS, SALARY) VALUES (1,'测试人员',35,'东北那旮瘩',5000);INSERT INTO `Test` (ID, NAME, AGE, ADDRESS, SALARY)VALUES (2,'测试人员',35,'东北那旮瘩',10000);SELECT * from Test ;--删DELETE from `Test` where ID='1';SELECT * from Test ;--改update `Test` set Name ='测试人员2' where ID=2;SELECT * from `Test`;DROP TABLE Test;SELECT * FROM sqlite_master WHERE type = 'table';","link":"/2021/07/28/sqlite/"},{"title":"Dockerfile笔记","text":"","link":"/2021/08/14/Dockerfile%E7%AC%94%E8%AE%B0/"},{"title":"kettle填坑","text":"写在前面为了将MSSqlserver数据传输至MySql数据库，一开始的选择有很多,类似DataX、ES，但是碍于运行环境是windows server 2012,且服务器环境不方便更改，查阅一番后，决定使用kettle进行数据的同步。 环境 系统：windows server 2012R2 64位 内存：8GB JDK：1.8 kettle配置统一参数一、kettle的常用配置文件说明： ${user.home} 表示WINDOWS的当前用户的文档文件夹，在C:\\Users文件夹下 ${user.home}/ .kettle /repositories.xml: 该文件保存了用户设置的所有资源库信息,包括资源库名称,资源库需要的数据库连接参数等。该文件中定义的资源库将显示在spoon启动后出现的选择资源库下拉列表中,注意该文件的编码是UTF-8，资源库的名称尽量使用英文。 ${user.home}/ kettle/kettle.properties: 该文件保存了转换或作业中需要的变量, spoon启动后会自动加载该文件里定义的变量。 ${user.home}/.kettle/shared.xml: 该文件里保存了共享对象,共享对象可以是Database connections, Steps,Slave servers ,Partition schemas ,Cluster schemas。对象共享实质上就是将对象序列化的过程, spoon启动时,会加载shared.xml文件中定义的所有对象。 lib\\kettle-engine.jar\\kettle-jobs.xml: 该文件中定义了Spoon启动时需要加载的作业项。 lib\\kettle-engine.jarkettle-partition-plugins.xml: 该文件中定义了Spoon启动时需要加载的分区插件。 lib\\kettle-engine.jar\\kettle- plugins.xml: 该文件中定义了Spoon启动时步骤和作业项插件的加载路径。 lib\\kettle-engine.jar\\kettle-steps.xml: 该文件中定义了Spoon启动时需要加载的转换步骤。 二、修改repositories.xml的位置 找到kettle所在文件夹下的Spoon.bat 文件,在里面查找出Kettle home所在的代码段,在 cd %KETTLE_DIR%代码上一行加上代码：set KETTLE_HOME=D:/AAA/BBB/CCC 如上，表示把文件重新等位到D:/AAA/BBB/CCC这个文件夹下。(注意:文件夹的斜杠和WINDOWS的目录斜杠是反的） 复制 ${user.home} 文件夹下的 .kettle 文件夹到D:/AAA/BBB/CCC目录下。 启动kettle程序。 参考： Kettle日常使用汇总整理 Kettle使用统一的数据库配置 kettle学习笔记10—配置文件的使用 Kettle环境配置-kettle.properties部份配置: kettle配置作业、转换参考：Kettle—使用手册 在配置完成后,执行作业的方式有两种： 使用spoon.bat打开UI程序进行执行 优点：作业执行很稳定，不会异常退出。 缺点：吃内存，配置不高的服务器可能压力大。懂不懂1GB起步。😓 使用Kitchen.bat脚本执行作业 优点：可以结合windows的任务执行计划程序进行定时启动作业，占用内存少，完成后自动退出。 缺点：一些耗时长的任务会有闪退的情况，或者数据量太大，执行时只取了一部分，会造成数据丢失。 配置重抽作业的逻辑初始化时在作业里设置开始时间、结束时间变量值，执行转换前判断变量值，未到时间点，执行转换。执行一次转换后，更新变量，循环判断，实现重抽的需求。作业流程配置: 转换流程配置： 更新时间变量JavaScript代码： updatetime.js12345678910111213141516171819202122232425262728293031//Script here//var st =getVariable(\"StTime\",'2021-01-01')//var end =getVariable(\"End\",'2021-7-27')//Alert(\"st:\"+st+\"end:\"+end)var stDate =StTime;// str2date(st,'yyyy-MM-dd')var endDate =End;// str2date(end,'yyyy-MM-dd')if(stDate==null|| endDate==null) { //Alert(\"error\") false;}else{var diff = dateDiff(stDate,endDate,'d')var flag = false;if(diff&gt;=1){ var nextDate =dateAdd(stDate,'d',1); //Alert(\"next:\"+nextDate) var strDate=date2str(stDate,'yyyy-MM-dd'); var strNextDate = date2str(nextDate,'yyyy-MM-dd'); //setVariable(\"StTime\",strNextDate,‘p’) //Alert(\"开始时间:\"+strDate+\"结束时间:\"+strNextDate) return true}else {return false}} 定时启动无界面kettle任务使用CMD脚本+windows任务计划程序实现定时启动作业执行。耗时在2小时以内的作业可以使用脚本方式，执行时间长的作业最好使用spoon窗口程序执行，不会存在执行一半退出的情况。bat文件保存要按ANSI编码进行保存 Task.bat1234567891011121314@REM @echo off@REM if \"%1\" == \"h\" goto begin@REM mshta vbscript:createobject(\"wscript.shell\").run(\"%~nx0 h\",0)(window.close)&amp;&amp;exit@REM :begin:: Kitchen.bat所在路径盘符?D::: Kitchen.bat所在目录? ? ?cd D:\\PDI\\data-integration\\:: 作业（job）文件路径和日志文件路径:: 执行kitchen执行job，并写入日志Kitchen.bat /file:F:\\pdi-ce-9.1.0.0-324\\WorkSpace\\测试.kjb /level:Base &gt;F:\\pdi-ce-9.1.0.0-324\\Log Kitchen.bat参数详细说明：https://help.hitachivantara.com/Documentation/Pentaho/9.1/Products/Use_Command_Line_Tools_to_Run_Transformations_and_Jobs 参考资料Kettle系列教程-第一章kettle-数据同步比较数据（删除更新）Kettle之定时运行Jobkettle教程—kettle作业调度，根据更新时间增量更新Kettle实现循环增量抽取数据Learn About the PDI Client (Spoon)-官方文档Use Command Line Tools to Run Transformations and Jobs","link":"/2021/08/03/kettle%E5%A1%AB%E5%9D%91/"},{"title":"yapi-docker部署","text":"填坑docker images生成部署时。发现docker-entrypoint.sh没有初始化数据库，只有运行代码，没有添加初始化命令： npm run install-server //安装程序，初始化数据库索引和管理员账号，管理员账号名可在 config.json 配置` 补救措施： 123456[root@VM-4-16-centos /]# docker exec -it 2e43588c8b1f bashroot@2e43588c8b1f:/# node api/vendors/server/install.js (node:65) DeprecationWarning: current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.log: mongodb load success...初始化管理员账号成功,账号名：\"xxxxx@gmail.com\"，密码：\"ymfe.org\" config.json内容如下： 12345678910111213{\"port\": \"3000\", \"adminAccount\": \"admin@admin.com\",//yapi管理员账号 \"timeout\":120000, \"db\": { \"servername\": \"192.168.0.1\", \"DATABASE\": \"yapi\", \"port\": 27017, \"user\": \"yapi\", \"pass\": \"123456\", \"authSource\": \"\" }}","link":"/2021/08/14/yapi-docker%E9%83%A8%E7%BD%B2/"},{"title":"docker初识","text":"Docker容器与镜像的关系类似于面向对象编程中的对象与类。 Docker 面向对象 容器 对象 镜像 类 安装参考：Ubuntu Docker 安装 docker命令列出docker的命令帮助，在docker xx 后面 加上 --help 可以查看具体的命令用法和参数注解 cmd-help.sh1docker --help 创建镜像列出所有镜像： 1docker images -a 获取一个新的ubuntu 13.10版本镜像 1docker pull ubuntu:13.10 查找centos镜像 1docker search centos 删除ubuntu镜像 1docker rmi ubuntu 创建镜像1、从已经创建的容器中更新镜像，并且提交这个镜像2、使用 Dockerfile 指令来创建一个新的镜像 创建容器容器管理命令 code 操作 备注 docker ps 查看正在运行的容器 docker ps -s -a 查看当前所有容器 docker stop 容器名称 停止容器 docker restart 容器名称 重启容器 docker kill 容器名称 杀死容器 docker rm -f 镜像ID或者镜像名 删除已经停止的容器 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 运行容器 docker run --name mynginx -d nginx:latest 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。 OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 example运行一个新容器，映射至5600端口，挂载目录 1docker run -dit -v $PWD/ql/config:/ql/config -v $PWD/ql/log:/ql/log -v $PWD/ql/db:/ql/db -v $PWD/ql/repo:/ql/repo -v $PWD/ql/raw:/ql/raw -v $PWD/ql/scripts:/ql/scripts -v $PWD/ql/jbot:/ql/jbot -p 5600:5600 --name qinglong --hostname qinglong --restart always whyour/qinglong:latest 摘录docker镜像管理命令查看本地镜像 docker images #查看当前机器的所有镜像 docker images –q # 查看所用镜像的id docker search 镜像名称 #搜索镜像，网络中查找需要的镜像 docker pull 镜像名称 #从Docker仓库拉取镜像，名称:版本号 docker push 镜像名称 #推送镜像 docker rmi 镜像名称/镜像id #删除本地机器的镜像 docker rmi docker images -q # 删除所有本地镜像 docker tag 镜像名称:tag 镜像名称:tag #为一个镜像打tag docker save {image_name} &gt; {new_image_name}.tar #镜像打包成一个tar包 docker load &lt; {image_name}.tar #解压一个镜像tar包 docker查看日志信息docker logs -f 容器名称 #查看容器日志 docker info #查看docker服务的信息 docker inspect 容器名称 # 获取镜像的元信息，详细信息 与容器交互的命令进入正在运行的容器docker exec -it 容器ID或者容器名 /bin/bash exec的意思是在容器中运行⼀个命令。 /bin/bash是固有写法，作用是因为docker后台必须运行一个进程，否则容器就会退出，在这里表示启动容器后启动 bash。 退出容器exit #退出也关闭容器; Ctrl+P+Q #退出不关闭容器 创建启动容器时，使用–v参数设置数据卷docker run … –v 宿主机目录/文件:容器内目录/文件 数据卷宿主机的一个目录或文件 目录必须是绝对路径 如果目录不存在，会自动创建 可以挂载多个数据卷 拷贝文件docker cp 主机文件路径 容器ID或容器名:容器路径 #宿主机文件拷贝到容器中 docker cp 容器ID或容器名:容器路径 主机文件路径 #容器文件拷贝到宿主机中","link":"/2021/08/13/docker%E5%88%9D%E8%AF%86/"},{"title":"MongoDb初识","text":"https://www.cnblogs.com/my-blogs-for-everone/articles/9749842.html MongoDb 命令查询所有数据库列表 1show dbs 如果想查看当前连接在哪个数据库下面，可以直接输入dbdb 切换到test数据库下面use test 想查看test下有哪些表或者叫collection，可以输入show collections 想知道mongodb支持哪些命令，可以直接输入helphelp 想知道当前数据库支持哪些方法db.help(); 想知道当前数据库下的表或者表collection支持哪些方法，可以使用以下命令db.user.help(); user为表名 根据条件查找数据通过条件查询： db.foo.find( { x : 77 } , { name : 1 , x : 1 } ) 超级用户相关： #增加或修改用户密码 db.addUser('admin','pwd') #查看用户列表 db.system.users.find() #用户认证 db.auth('admin','pwd') #删除用户 db.removeUser('mongodb') #查看所有用户 show users #查看所有数据库 show dbs #查看所有的collection show collections #查看各collection的状态 db.printCollectionStats() #查看主从复制状态 db.printReplicationInfo() #修复数据库 db.repairDatabase() #设置记录profiling，0=off 1=slow 2=all db.setProfilingLevel(1) #查看profiling show profile #拷贝数据库 db.copyDatabase('mail_addr','mail_addr_tmp') #删除collection db.mail_addr.drop() #删除当前的数据库 db.dropDatabase() 客户端连接 /usr/local/mongodb/bin/mongo user_addr -u user -p 'pwd' 增删改 #存储嵌套的对象 db.foo.save({'name':'ysz','address':{'city':'beijing','post':100096},'phone':[138,139]}) #存储数组对象 db.user_addr.save({'Uid':'yushunzhi@sohu.com','Al':['test-1@sohu.com','test-2@sohu.com']}) #根据query条件修改，如果不存在则插入，允许修改多条记录 db.foo.update({‘yy’:5},{‘$set’:{‘xx’:2}},upsert=true,multi=true) #删除yy=5的记录 db.foo.remove({'yy':5}) #删除所有的记录 db.foo.remove() 索引 增加索引：1(ascending),-1(descending) db.things.ensureIndex({firstname: 1, lastname: 1}, {unique: true}); #索引子对象 db.user_addr.ensureIndex({'Al.Em': 1}) #查看索引信息 db.deliver_status.getIndexes() db.deliver_status.getIndexKeys() #根据索引名删除索引 db.user_addr.dropIndex(‘Al.Em_1’) 查询 查找所有 db.foo.find() #查找一条记录 db.foo.findOne() #根据条件检索10条记录 db.foo.find({'msg':'Hello 1'}).limit(10) #sort排序 db.deliver_status.find({'From':'yushunzhi@sohu.com'}).sort({'Dt',-1}) db.deliver_status.find().sort({'Ct':-1}).limit(1) #count操作 db.user_addr.count() #distinct操作 db.foo.distinct(‘msg’)#&gt;操作 db.foo.find({“timestamp”: {“$gte” : 2}}) #子对象的查找 db.foo.find({‘address.city’:’beijing’}) 管理 查看collection数据的大小 db.deliver_status.dataSize() #查看colleciont状态 db.deliver_status.stats() #查询所有索引的大小 db.deliver_status.totalIndexSize()","link":"/2021/09/01/MongoDb%E5%88%9D%E8%AF%86/"},{"title":"sql server 中的数组和列表（转载）","text":"转载自：Arrays and Lists in SQL Server-The Short Version 原文摘录Two Simple Multi-Statement FunctionsIf you search the web, there is no end of functions to split strings into table format. Here, I will present two simple functions that run on SQL 2008 or later, one for a list of integers and one for a list of strings. I should immediately warn you that these functions are not the most efficient and therefore not suitable if you have long lists with thousands of elements. But they are perfectly adequate if you are passing the contents of a multi-choice checkbox from a client where you would rarely have as many as 50 elements. I opted to share these functions because they are simple and you can easily adapt them if you want different behaviour with regards to the choices that I have made. In my long article, I describe methods that are faster, but they all require extra setup than just a function. Below is a function to split a delimited list of integers. The function accepts a parameter for the delimiter which can be up to 10 characters long. The function returns the list positions for the elements. An empty element is returned as NULL. If there is a non-numeric value in the list, there will be a conversion error. sql12345678910111213141516171819202122CREATE FUNCTION intlist_to_tbl (@list nvarchar(MAX), @delim nvarchar(10)) RETURNS @tbl TABLE (listpos int NOT NULL IDENTITY(1,1), n int NULL) ASBEGIN DECLARE @pos int = 1, @nextpos int = 1, @valuelen int, @delimlen int = datalength(@delim) / 2 WHILE @nextpos &gt; 0 BEGIN SELECT @nextpos = charindex(@delim COLLATE Czech_BIN2, @list, @pos) SELECT @valuelen = CASE WHEN @nextpos &gt; 0 THEN @nextpos ELSE len(@list) + 1 END - @pos INSERT @tbl (n) VALUES (convert(int, nullif(substring(@list, @pos, @valuelen), ''))) SELECT @pos = @nextpos + @delimlen END RETURNEND You are likely to be puzzled by the COLLATE clause. This is a small speed booster. By forcing a binary collation, we avoid that SQL Server employs the full Unicode rules when searching for the delimiter. This pays off when scanning long strings. Why Czech? The language does not matter here, so I just picked one with a short name. And why datalength divided by 2 and not len? datalength returns the length in bytes, whence the division. len does not count trailing spaces, so it does not work if the delimiter is a space. Here are two examples: sql12SELECT * FROM intlist_to_tbl('1,2,3, 677,7 , ,-1', ',')SELECT * FROM intlist_to_tbl('1&lt;-&gt;2&lt;-&gt;3&lt;-&gt; 677&lt;-&gt;7&lt;-&gt;&lt;-&gt;-1', '&lt;-&gt;') Since the values are the same in both lists, the output is the same: listpos n 1 1 2 2 3 3 4 677 5 7 6 NULL 7 -1 Here is an example of how you would use it in a simple query: sql123SELECT ...FROM tbl WHERE col IN (SELECT n FROM intlist_to_tbl('1,2,3,4', ',')) If you find that you are only using comma-separated lists, you may grow tired of having to specify the delimiter every time. To that end, this wrapper can be handy: sql1234CREATE FUNCTION intlisttotbl (@list nvarchar(MAX)) RETURNS TABLE ASRETURN ( SELECT listpos, n FROM intlist_to_tbl(@list, ',')) I leave it as an exercise to the reader to come up with a better name. Here is a function for a list of strings. It accepts an input parameter of the type nvarchar(MAX), but the return table has both a varchar and an nvarchar column. I will return to why in a second. Like intlist_to_tbl it returns the list position. It trims leading and trailing spaces. In difference to intlist_to_tbl, empty elements are returned as empty strings and not as NULL. sql12345678910111213141516171819202122232425CREATE FUNCTION strlist_to_tbl (@list nvarchar(MAX), @delim nvarchar(10)) RETURNS @tbl TABLE (listpos int NOT NULL IDENTITY(1,1), str varchar(4000) NOT NULL, nstr nvarchar(4000) NOT NULL) ASBEGIN DECLARE @pos int = 1, @nextpos int = 1, @valuelen int, @nstr nvarchar(4000), @delimlen int = datalength(@delim) / 2 WHILE @nextpos &gt; 0 BEGIN SELECT @nextpos = charindex(@delim COLLATE Czech_BIN2, @list, @pos) SELECT @valuelen = CASE WHEN @nextpos &gt; 0 THEN @nextpos ELSE len(@list) + 1 END - @pos SELECT @nstr = ltrim(rtrim(substring(@list, @pos, @valuelen))) INSERT @tbl (str, nstr) VALUES (@nstr, @nstr) SELECT @pos = @nextpos + @delimlen END RETURNEND Here are two examples: sql12SELECT * FROM strlist_to_tbl(N'Alpha (α) | Beta (β)|Gamma (γ)|Delta (δ)|', '|')SELECT * FROM strlist_to_tbl(N'a///b///c///v///x', '///') Here is the output: listpos | str | nstr|:–:|:–:|:–:|1 | Alpha (a)| Alpha (α)2 | Beta (ß) | Beta (β)3 | Gamma (?)| Gamma (γ)4 | Delta (d)| Delta (δ)5 | | | listpos | str | nstr|:–:|:–:|:–:|1 | a | a2 | b | b3 | c | c4 | v | v5 | x | x Note in the first result set that the Greek characters has been replaced by fallback characters in the str column. They are unchanged in the nstr column. (If you have a Greek or a UTF-8 collation, the two columns will be identical, though.) Here are two examples of using this function: sql1234567SELECT ...FROM tbl WHERE varcharcol IN (SELECT str FROM strlist_to_tbl('a,b,c', ','))SELECT ...FROM tbl WHERE nvarcharcol IN (SELECT nstr FROM strlist_to_tbl('a,b,c', ',')) These examples illustrate why there are two columns. If you are going to use the list against a varchar column, you need to use the str column. This is important because of the type-conversion rules in SQL Server. If you mistakenly compare varcharcol to nstr, varcharcol will be converted to nvarchar, and this can render any index on varcharcol ineligible for the query, leading to a performance disaster as the table must be scanned. And conversely, if you have an nvarchar column, you need to compare it to the nvarchar value, since else the result can be incorrect because of the character replacement with the conversion to varchar. I like to point out that these functions are by no means cast in stone, but see them as suggestions. Feel free to modify them according to your preferences and needs.","link":"/2021/10/21/sqlserver%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"},{"title":"判断文件类型【一】","text":"现有一文件，其扩展名未知或标记错误。假设它是一个正常的、非空的文件，且将扩展名更正后可以正常使用，那么，如何判断它是哪种类型的文件？在后缀未知，或者后缀被修改的文件，依然通过文件头来判断该文件究竟是什么文件类型。 C#实现参考： example.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class MimeType{ private static readonly byte[] BMP = { 66, 77 }; private static readonly byte[] DOC = { 208, 207, 17, 224, 161, 177, 26, 225 }; private static readonly byte[] EXE_DLL = { 77, 90 }; private static readonly byte[] GIF = { 71, 73, 70, 56 }; private static readonly byte[] ICO = { 0, 0, 1, 0 }; private static readonly byte[] JPG = { 255, 216, 255 }; private static readonly byte[] MP3 = { 255, 251, 48 }; private static readonly byte[] OGG = { 79, 103, 103, 83, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0 }; private static readonly byte[] PDF = { 37, 80, 68, 70, 45, 49, 46 }; private static readonly byte[] PNG = { 137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82 }; private static readonly byte[] RAR = { 82, 97, 114, 33, 26, 7, 0 }; private static readonly byte[] SWF = { 70, 87, 83 }; private static readonly byte[] TIFF = { 73, 73, 42, 0 }; private static readonly byte[] TORRENT = { 100, 56, 58, 97, 110, 110, 111, 117, 110, 99, 101 }; private static readonly byte[] TTF = { 0, 1, 0, 0, 0 }; private static readonly byte[] WAV_AVI = { 82, 73, 70, 70 }; private static readonly byte[] WMV_WMA = { 48, 38, 178, 117, 142, 102, 207, 17, 166, 217, 0, 170, 0, 98, 206, 108 }; private static readonly byte[] ZIP_DOCX = { 80, 75, 3, 4 }; public static string GetMimeType(byte[] file, string fileName) { string mime = \"application/octet-stream\"; //DEFAULT UNKNOWN MIME TYPE //Ensure that the filename isn't empty or null if (string.IsNullOrWhiteSpace(fileName)) { return mime; } //Get the file extension string extension = Path.GetExtension(fileName) == null ? string.Empty : Path.GetExtension(fileName).ToUpper(); //Get the MIME Type if (file.Take(2).SequenceEqual(BMP)) { mime = \"image/bmp\"; } else if (file.Take(8).SequenceEqual(DOC)) { mime = \"application/msword\"; } else if (file.Take(2).SequenceEqual(EXE_DLL)) { mime = \"application/x-msdownload\"; //both use same mime type } else if (file.Take(4).SequenceEqual(GIF)) { mime = \"image/gif\"; } else if (file.Take(4).SequenceEqual(ICO)) { mime = \"image/x-icon\"; } else if (file.Take(3).SequenceEqual(JPG)) { mime = \"image/jpeg\"; } else if (file.Take(3).SequenceEqual(MP3)) { mime = \"audio/mpeg\"; } else if (file.Take(14).SequenceEqual(OGG)) { if (extension == \".OGX\") { mime = \"application/ogg\"; } else if (extension == \".OGA\") { mime = \"audio/ogg\"; } else { mime = \"video/ogg\"; } } else if (file.Take(7).SequenceEqual(PDF)) { mime = \"application/pdf\"; } else if (file.Take(16).SequenceEqual(PNG)) { mime = \"image/png\"; } else if (file.Take(7).SequenceEqual(RAR)) { mime = \"application/x-rar-compressed\"; } else if (file.Take(3).SequenceEqual(SWF)) { mime = \"application/x-shockwave-flash\"; } else if (file.Take(4).SequenceEqual(TIFF)) { mime = \"image/tiff\"; } else if (file.Take(11).SequenceEqual(TORRENT)) { mime = \"application/x-bittorrent\"; } else if (file.Take(5).SequenceEqual(TTF)) { mime = \"application/x-font-ttf\"; } else if (file.Take(4).SequenceEqual(WAV_AVI)) { mime = extension == \".AVI\" ? \"video/x-msvideo\" : \"audio/x-wav\"; } else if (file.Take(16).SequenceEqual(WMV_WMA)) { mime = extension == \".WMA\" ? \"audio/x-ms-wma\" : \"video/x-ms-wmv\"; } else if (file.Take(4).SequenceEqual(ZIP_DOCX)) { mime = extension == \".DOCX\" ? \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" : \"application/x-zip-compressed\"; } return mime; }} 资料：Mime-Detective 文件签名表格：GCK’S FILE SIGNATURES TABLE 参考资料：Magic numberList of file signatures","link":"/2021/12/01/%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"【C#】SqlBulkCopy实现SQLSRVER批量插入","text":"参考： SqlBulkCopy 类http://raylei.cn/index.php/archives/74/https://www.cxybb.com/article/weixin_30333885/96361368 问题 来自数据源的 Decimal 类型的给定值不能转换为指定目标列的类型 datetime 实际情况可能很复杂，使用的是泛型进行实体类转DataTable,可能会出现各种类型错误提示。 自己使用的是调用Copy()方法。 demo: demo.cs1234567891011121314151617var TableStruct = dal.GetTableStruct();DataTable dataTable = TableStruct.Clone();foreach (var item in oD.ToList&lt;StdYpkcday&gt;()){ DataRow dataRow = dataTable.NewRow(); dataRow[\"id\"] = DBNull.Value;//自增主键。赋值DBNull.Value dataRow[\"code\"] = item.Hoscode; if (item.Gqsj == null ) { dataRow[\"time\"] = DBNull.Value; } else { dataRow[\"time\"] = item.Gqsj; } dataTable.Rows.Add(dataRow);} 参考：https://stackoverflow.com/questions/18140012/sqlbulkcopy-the-given-value-of-type-string-from-the-data-source-cannot-be-conv Demo删除并批量插入.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/// &lt;summary&gt;/// 删除并批量插入/// &lt;/summary&gt;/// &lt;param name=\"_Type\"&gt;&lt;/param&gt;/// &lt;param name=\"TableName\"&gt;批量插入数据的表名&lt;/param&gt;/// &lt;param name=\"Dt\"&gt;批量插入的数据&lt;/param&gt;/// &lt;param name=\"SqlDeleteText\"&gt;删除的sql语句&lt;/param&gt;public void DeleteAndBulkCopy(string Type,string TableName, DataTable Dt, string SqlDeleteText,bool isIncreaPK){ using (SqlConnection conn = new SqlConnection(DBUtility.DbCommon.GetConnectString(Type))) { conn.Open(); using (SqlTransaction transaction = conn.BeginTransaction()) { SqlCommand sqlcom = conn.CreateCommand(); sqlcom.Transaction = transaction; sqlcom.CommandText = SqlDeleteText; var BulkCopyOptions = SqlBulkCopyOptions.KeepIdentity; //自增主键，使用系统生成主键 if (isIncreaPK) { BulkCopyOptions = SqlBulkCopyOptions.Default; } using (SqlBulkCopy bulk = new SqlBulkCopy(conn, BulkCopyOptions, transaction)) { if (Dt.Rows.Count &gt; 0) { for (int i = 0; i &lt; Dt.Columns.Count; i++) { bulk.ColumnMappings.Add(Dt.Columns[i].ColumnName, Dt.Columns[i].ColumnName); } bulk.BatchSize = Dt.Rows.Count; bulk.DestinationTableName = TableName; } try { sqlcom.ExecuteNonQuery(); bulk.WriteToServer(Dt); transaction.Commit(); } catch (Exception ex) { transaction.Rollback(); } finally { bulk.Close(); conn.Close(); } } } }} 批量更新.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#region 批量更新/// &lt;summary&gt;/// 批量更新/// &lt;/summary&gt;/// &lt;param name=\"dataTable\"&gt;&lt;/param&gt;/// &lt;param name=\"crateTemplateSql\"&gt;/// eg:/// [xxx] varchar(255) NOT NULL,[xxx] varchar(10) NOT NULL/// &lt;/param&gt;/// &lt;param name=\"updateSql\"&gt;/// eg:/// UPDATE bulktest set bulktest.name=Temp.tempname /// FROM bulktest INNER JOIN #TmpTable Temp /// ON Temp.temprdn = bulktest.rdn ; /// DROP TABLE #TmpTable/// &lt;/param&gt;public void SqlBulkCopyUpdate(DataTable dataTable, string crateTemplateSql, string updateSql){ using (SqlConnection conn = new SqlConnection(DBUtility.DbCommon.GetConnectString(DBType))) { using (var command = new SqlCommand(\"\", conn)) { try { conn.Open(); //数据库并创建一个临时表来保存数据表的数据 command.CommandText = $\" CREATE TABLE #TmpTable ({crateTemplateSql})\"; command.ExecuteNonQuery(); //使用SqlBulkCopy 加载数据到临时表中 using (var bulkCopy = new SqlBulkCopy(conn)) { foreach (DataColumn dcPrepped in dataTable.Columns) { bulkCopy.ColumnMappings.Add(dcPrepped.ColumnName, dcPrepped.ColumnName); } bulkCopy.BulkCopyTimeout = 660; bulkCopy.DestinationTableName = \"#TmpTable\"; bulkCopy.WriteToServer(dataTable); bulkCopy.Close(); } // 执行Command命令 使用临时表的数据去更新目标表中的数据 然后删除临时表 command.CommandTimeout = 300; command.CommandText = updateSql; int rows = command.ExecuteNonQuery(); } catch(Exception ex) { throw ex; } finally { conn.Close(); } } }}#endregion","link":"/2021/12/11/SqlBulkCopy%E5%AE%9E%E7%8E%B0SQLSRVER%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/"},{"title":"【Csharp】Thread匿名方法初识","text":"片段代码笔记 12345678910111213141516171819202122232425262728293031323334353637383940414243/// &lt;summary&gt;/// 停止创建运行新任务和新线程，等待所有任务和线程执行完成。/// &lt;/summary&gt;private void StopRuningTaskOrThreadAndExitOrRestart(bool restartFlag){ timer1.Enabled = false;//停止触发 if (switchstr == \"1\" &amp;&amp; threadswitchstr == \"1\") { Thread t = new Thread((flag) =&gt; { while (threadUseNum &gt; 0) { Thread.Sleep(5000); RefreshMsgBox(DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\") + $\"\\t=&gt;\\t等待子任务执行完成退出：子任务数量：{threadUseNum}\"); } if ((bool)flag) { Process.Start(Application.ExecutablePath); } Environment.Exit(0); }); t.IsBackground = true; t.Start(restartFlag); } else if (switchstr == \"1\") { Thread t = new Thread((flag) =&gt; { if (taskThread != null) { taskThread.Wait();//等待执行完成 } if ((bool)flag) { Process.Start(Application.ExecutablePath); } Environment.Exit(0); }); t.IsBackground = true; t.Start(restartFlag); }}","link":"/2022/01/06/%E3%80%90Csharp%E3%80%91Thread%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E5%88%9D%E8%AF%86/"},{"title":"VUE初识","text":"安装安装方式： CDN NPM VUE-CLI CDN1234&lt;!-- V2.x --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- V3.x最新版本 --&gt;&lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt; NPM1234# V2.x最新稳定版npm install vue# V3.x最新稳定版$ npm install vue@next VUE-CLI123npm install -g @vue/cli# 升级npm update -g @vue/cli 创建项目VUE-CLIVUE Create12# 创建一个新项目,跳过 git 初始化vue create hello-world -n 123456789101112131415161718192021vue create --help用法：create [options] &lt;app-name&gt;创建一个由 `vue-cli-service` 提供支持的新项目选项： -p, --preset &lt;presetName&gt; 忽略提示符并使用已保存的或远程的预设选项 -d, --default 忽略提示符并使用默认预设选项 -i, --inlinePreset &lt;json&gt; 忽略提示符并使用内联的 JSON 字符串预设选项 -m, --packageManager &lt;command&gt; 在安装依赖时使用指定的 npm 客户端 -r, --registry &lt;url&gt; 在安装依赖时使用指定的 npm registry -g, --git [message] 强制 / 跳过 git 初始化，并可选的指定初始化提交信息 -n, --no-git 跳过 git 初始化 -f, --force 覆写目标目录可能存在的配置 -c, --clone 使用 git clone 获取远程预设选项 -x, --proxy 使用指定的代理创建项目 -b, --bare 创建项目时省略默认组件中的新手指导信息 -h, --help 输出使用帮助信息 VUE UI1vue ui 拉取 2.x 模板 (旧版本)Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具： 123npm install -g @vue/cli-init# `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同vue init webpack my-project 运行VUE-CLI在一个 Vue CLI 项目中，@vue/cli-service 安装了一个名为 vue-cli-service 的命令。你可以在 npm scripts 中以 vue-cli-service、或者从终端中以 ./node_modules/.bin/vue-cli-service 访问这个命令。 这是你使用默认 preset 的项目的 package.json： package.json123456{ \"scripts\": { \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\" }} 123npm run serve# ORnpx vue-cli-service serve 123456789101112vue-cli-service serve用法：vue-cli-service serve [options] [entry]选项： --open 在服务器启动时打开浏览器 --copy 在服务器启动时将 URL 复制到剪切版 --mode 指定环境模式 (默认值：development) --host 指定 host (默认值：0.0.0.0) --port 指定 port (默认值：8080) --https 使用 https (默认值：false) 123456789101112131415vue-cli-service build用法：vue-cli-service build [options] [entry|pattern]选项： --mode 指定环境模式 (默认值：production) --dest 指定输出目录 (默认值：dist) --modern 面向现代浏览器带自动回退地构建应用 --target app | lib | wc | wc-async (默认值：app) --name 库或 Web Components 模式下的名字 (默认值：package.json 中的 \"name\" 字段或入口文件名) --no-clean 在构建项目之前不清除目标目录 --report 生成 report.html 以帮助分析包内容 --report-json 生成 report.json 以帮助分析包内容 --watch 监听文件变化 构建部署","link":"/2022/02/14/VUE%E5%88%9D%E8%AF%86/"},{"title":"Markdown语法速查表","text":"总览此 Markdown 语法速查表提供了所有 Markdown 语法元素的快速参考。但是此速查表无法涵盖所有极限用法，因此，如果您需要某些语法元素的详细信息，请参阅我们的 basic syntax 和 extended syntax 手册。 基本语法这些是 John Gruber 的原始设计文档中列出的元素。所有 Markdown 应用程序都支持这些元素。 元素 Markdown 语法 Heading # H1## H2### H3 Bold **bold text** Italic *italicized text* Blockquote &gt; blockquote Ordered List 1. First item 2. Second item 3. Third item Unordered List - First item - Second item - Third item Code `code` Horizontal Rule --- Link [title](https://www.example.com) Image ![alt text](image.jpg) 扩展语法这些元素通过添加额外的功能扩展了基本语法。但是，并非所有 Markdown 应用程序都支持这些元素。 Element Markdown Syntax Table | Syntax | Description | | ----------- | ----------- | | Header | Title | | Paragraph | Text | Fenced Code Block ``` { &nbsp;&nbsp;\"firstName\": \"John\", &nbsp;&nbsp;\"lastName\": \"Smith\", &nbsp;&nbsp;\"age\": 25 } ``` Footnote Here's a sentence with a footnote. [^1] [^1]: This is the footnote. Heading ID ### My Great Heading","link":"/2021/10/21/Markdown%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%E8%A1%A8/"},{"title":"redis初识","text":"Windows安装Redis下载地址：https://github.com/tporadowski/redis 部署为服务命令行进入安装目录/解压目录 安装服务: redis-server.exe –service-install redis.windows.conf –loglevel verbose 卸载服务：redis-server –service-uninstall 开启服务：redis-server –service-start 停止服务：redis-server –service-stop 重命名服务：redis-server –service-name name 以下将会安装并启动三个不同的Redis实例作服务： 1234567891011redis-server --service-install --service-name redisService1 --port 10001redis-server --service-start --service-name redisService1redis-server --service-install --service-name redisService2 --port 10002redis-server --service-start --service-name redisService2redis-server --service-install --service-name redisService3 --port 10003redis-server --service-start --service-name redisService3","link":"/2022/01/05/redis%E5%88%9D%E8%AF%86/"},{"title":"当按下回车时发生了什么？","text":"这个仓库试图回答一个古老的面试问题：当你在浏览器中输入 google.com 并且按下回车之后发生了什么？ 不过我们不再局限于平常的回答，而是想办法回答地尽可能具体，不遗漏任何细节。 这将是一个协作的过程，所以深入挖掘吧，并且帮助我们一起完善它。仍然有大量的细节等待着你来添加，欢迎向我们发送 Pull Requset！ 这些内容使用 Creative Commons Zero_ 协议发布。 目录按下”g”键接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 “google.com”，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 “google.com” 建议给你。 回车键按下为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。 USB键盘： 键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压 键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内 USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供 键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包 这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance） 这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层 虚拟键盘（触屏设备）： 在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标 然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮 虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息 这个消息又返回来向当前活跃的应用通知一个“按键按下”事件 产生中断[非USB键盘]键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。 (Windows)一个 WM_KEYDOWN 消息被发往应用程序HID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。 Win32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。 Windows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。 当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。 (Mac OS X)一个 KeyDown NSEvent被发往应用程序中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。 (GNU/Linux)Xorg 服务器监听键码值当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。 解析URL 浏览器通过 URL 能够知道下面的信息： Protocol “http” 使用HTTP协议 Resource “/“ 请求的资源是主页(index) 输入的是 URL 还是搜索的关键字？当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。 转换非 ASCII 的 Unicode 字符 浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符 这里主机名是 google.com ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode_ 编码 检查 HSTS 列表 浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站 如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送 注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack_ 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。 DNS 查询 浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns &lt;chrome://net-internals/#dns&gt;_）。 如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。 gethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同_ 如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。 查询本地 DNS 服务器 如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询 如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询 ARP 过程要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。 首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC 如果缓存没有命中： 查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。 查询选择的网络接口的 MAC 地址 我们发送一个二层（ OSI 模型_ 中的数据链路层）ARP 请求： ARP Request:: Sender MAC: interface:mac:address:here Sender IP: interface.ip.goes.here Target MAC: FF:FF:FF:FF:FF:FF (Broadcast) Target IP: target.ip.goes.here 根据连接主机和路由器的硬件类型不同，可以分为以下几种情况： 直连： 如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。 集线器： 如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。 交换机： 如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。 如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求 如果路由器也“连接”在其中，它会返回一个 ARP Reply ARP Reply:: Sender MAC: target:mac:address:here Sender IP: target.ip.goes.here Target MAC: interface:mac:address:here Target IP: interface.ip.goes.here 现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了： 使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议 如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回 使用套接字当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个TCP流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。 这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range) TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。 这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。 到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输： 以太网_ WiFi_ 蜂窝数据网络_ 对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点_ 处理。节点的目标地址和源地址将在后面讨论。 大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点_ 进行处理。 最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域(autonomous system, 缩写 AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部 time to live (TTL) 域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。 上面的发送和接受过程在 TCP 连接期间会发生很多次： 客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号 服务器端接收到 SYN 包，如果它可以建立连接： 服务器端选择它自己的初始序列号 服务器端设置 SYN 位，表明自己选择了一个初始序列号 服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包 客户端通过发送下面一个封包来确认这次连接： 自己的序列号+1 接收端 ACK+1 设置 ACK 位 数据通过下面的方式传输： 当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N 另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号 关闭连接时： 要关闭连接的一方发送一个 FIN 包 另一方确认这个 FIN 包，并且发送自己的 FIN 包 要关闭的一方使用 ACK 包来确认接收到了 FIN TLS 握手 客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。 服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥 客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥 服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥 客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值 服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密 从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容 HTTP 协议如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。 如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:: GET / HTTP/1.1 Host: google.com Connection: close [其他头部] “其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。） HTTP/1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开。例如： Connection:close 不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含 “close” 选项。 在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。 服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:: 200 OK [响应头部] 然后是一个换行，接下来有效载荷(payload)，也就是 www.google.com 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。 如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:: 304 Not Modified [响应头部] 这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。 在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET /$(相对www.google.com的URL) HTTP/1.1 。 如果HTML引入了 www.google.com 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。 HTTP 服务器请求处理HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。 HTTPD 接收请求 服务器把请求拆分为以下几个参数： HTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法 域名：google.com 请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径) 服务器验证其上已经配置了 google.com 的虚拟主机 服务器验证 google.com 接受 GET 方法 服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等) 如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求 服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。 服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者 浏览器背后的故事当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作： 解析 —— HTML，CSS，JS 渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制 浏览器浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。 浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。 不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素： 一个地址栏 后退和前进按钮 书签选项 刷新和停止按钮 主页按钮 浏览器高层架构 组成浏览器的组件有： 用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分 浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作 渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上 网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现 UI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现 Javascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码 数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制 HTML 解析浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。 HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。 解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。 解析算法 HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点: 语言本身的“宽容”特性 HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们 解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容 由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。 解析结束之后 浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。 此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。 注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。 CSS 解析 根据 CSS词法和句法_ 分析CSS文件和 &lt;style&gt; 标签包含的内容以及 style 属性的值 每个CSS文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象 CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器 页面渲染 通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值 通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点的首选(preferred)宽度 通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度 通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度 使用上面的计算结果构建每个节点的坐标 当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见http://dev.w3.org/csswg/css2/ 和 http://www.w3.org/Style/CSS/current-work 创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层 页面上的每个层都被分配了纹理(?) 每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制 上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量 计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。 GPU 渲染 在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU 当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。 Window Server后期渲染与用户引发的处理渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。 _Creative Commons Zero: https://creativecommons.org/publicdomain/zero/1.0/_CSS词法和句法: http://www.w3.org/TR/CSS2/grammar.html_Punycode: https://en.wikipedia.org/wiki/Punycode_以太网: http://en.wikipedia.org/wiki/IEEE_802.3_WiFi: https://en.wikipedia.org/wiki/IEEE_802.11_蜂窝数据网络: https://en.wikipedia.org/wiki/Cellular_data_communication_protocol_analog-to-digital converter: https://en.wikipedia.org/wiki/Analog-to-digital_converter_网络节点: https://en.wikipedia.org/wiki/Computer_network#Network_nodes不同的操作系统有所不同 : https://en.wikipedia.org/wiki/Hosts%28file%29#Location_in_the_file_system_downgrade attack: http://en.wikipedia.org/wiki/SSL_stripping_OSI 模型: https://en.wikipedia.org/wiki/OSI_model","link":"/2022/02/18/%E5%BD%93%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"},{"title":"前端模块化开发中webpack、npm、node、nodejs之间的关系","text":"webpack Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 webpack是一个工具，这个工具可以帮你处理好各个包/模块之间的依赖关系（modules with dependencies），并将这些复杂依赖关系的静态文件打包成一个或很少的静态文件，提供给浏览器访问使用；除此之外，webpack因为可以提高兼容性，可以将一些浏览器尚不支持的新特性转换为可以支持格式，进而减少由新特性带来的浏览器的兼容性问题 好，我们通过介绍，我们有个概念，webpack是一个打包工具，可以帮你把你的项目这里的项目其实就是指通过模块化开发的项目 打包为简洁版的浏览器可识别的静态资源 npm介绍了webpack，我们可能会疑问，我的JS，CSS，HTML文件分开写，挺好的呀，为什么要使用webpack工具，进行复杂的各项配置。在传统前端开发模式下，我们确实是按照JS/CSS/HTML文件分开写的模式就可以，但是随着前端的发展，社区的壮大，各种前端的库和框架层出不穷，我们项目中可能会使用很多额外的库，如何有效管理这些引入的库文件是一个大问题，而且我们知道基于在HTML中使用&lt;script&gt;引入的方式，有两个弊端，一个是会重复引入，二是当库文件数量很多时管理成为一个大难题。面对这样的局面，为了简化开发的复杂度，前端社区涌现了很多实践方法。模块化就是其中一项成功实践，而npm就是这样在社区 其实就是node社区中产生的 npm 为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。npm 由三个独立的部分组成： 网站 注册表（registry） 命令行工具 (CLI) 网站 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。注册表 是一个巨大的数据库，保存了每个包（package）的信息。CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。 这是npm的官方网站给出的介绍，一般来说提起npm有两个含义，一个是说npm官方网站，一个就是说npm包管理工具。npm社区或官网是一个巨大的Node生态系统，社区成员可以随意发布和安装npm生态中的包，也就是不用在重复造轮子了，别人造好了，你直接安装到你的项目中就可以使用，但是因为前面说了，当包引入数量很多时管理就成为了一个问题，这个就是npm为开发者行了方便之处，npm已经为你做好了依赖和版本的控制，也就是说使用npm可以让你从繁杂的依赖安装和版本冲突中解脱出来，进而关注你的业务而不是库的管理。 而webpack就是将你从npm中安装的包打包成更小的浏览器可读的静态资源，这里需要注意的是，webpack只是一个前端的打包工具，打包的是静态资源，和后台没有关系，虽然webpack依赖于node环境 what is node or nodejs？其实node和nodejs两个概念没有太大差别，我个人认为唯一的区别就是，人们说起node的时候语境更多的是再说node环境，而说nodejs时更多的是在说node是一门可以提供后端能力的技术。本质上来说，node就是nodejs，nodejs就是node 简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行&gt;Javascript的速度非常快，性能非常好。 node环境基于V8引擎提供了一种可以让JS代码跑在后端的能力，这就是node。其实这里的node本身和我们这篇讲的前端模块化没啥关系。但是因为npm是产生与node社区，node中也是通过npm来加载模块的，所以有必要说一下他们之间的关系。 npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制 webpack npm node之间关系？ webpack是npm生态中的一个模块，我们可以通过全局安装webpack来使用webpack对项目进行打包； webpack的运行依赖于node的环境，没有node是不能打包的，但是webpack打包后的项目本身只是前端静态资源和后台没有关系，也就是说不依赖与node，只要有后台能力的都可以部署项目 npm是于Node社区中产生的，是nodejs的官方包管理工具，当你下载安装好node的时候，npm cli就自动安装好了 正是因为npm的包管理，使得项目可以模块化的开发，而模块化的开发带来的这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别，而手动处理又是非常繁琐的，这就是webpack工具存在的意义 参考： 前端模块化开发中webpack、npm、node、nodejs之间的关系 摘录：Node.js介绍,摘自官网 Node.js12345678910111213Node.js is an open-source and cross-platform JavaScript runtime environment. It is a popular tool for almost any kind of project!Node.js runs the V8 JavaScript engine, the core of Google Chrome, outside of the browser. This allows Node.js to be very performant.A Node.js app runs in a single process, without creating a new thread for every request. Node.js provides a set of asynchronous I/O primitives in its standard library that prevent JavaScript code from blocking and generally, libraries in Node.js are written using non-blocking paradigms, making blocking behavior the exception rather than the norm.When Node.js performs an I/O operation, like reading from the network, accessing a database or the filesystem, instead of blocking the thread and wasting CPU cycles waiting, Node.js will resume the operations when the response comes back.This allows Node.js to handle thousands of concurrent connections with a single server without introducing the burden of managing thread concurrency, which could be a significant source of bugs.Node.js has a unique advantage because millions of frontend developers that write JavaScript for the browser are now able to write the server-side code in addition to the client-side code without the need to learn a completely different language.In Node.js the new ECMAScript standards can be used without problems, as you don't have to wait for all your users to update their browsers - you are in charge of deciding which ECMAScript version to use by changing the Node.js version, and you can also enable specific experimental features by running Node.js with flags. Introduction to npmnpm is the standard package manager for Node.js. In January 2017 over 350000 packages were reported being listed in &gt;the npm registry, making it the biggest single language code &gt;repository on Earth, and you can be sure there is a package for &gt;(almost!) everything. It started as a way to download and manage dependencies of Node.js &gt;packages, but it has since become a tool used also in frontend &gt;JavaScript. There are many things that npm does. Yarn and pnpm are alternatives to npm cli. You can check them out as &gt;well.","link":"/2022/02/15/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%ADwebpack%E3%80%81npm%E3%80%81node%E3%80%81nodejs%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"nodejs单线程？非阻塞I&#x2F;O？异步？","text":"像java、python这个可以具有多线程的语言。多线程同步模式是这样的，将cpu分成几个线程，每个线程同步运行。 而node.js采用单线程异步非阻塞模式，也就是说每一个计算独占cpu，遇到I/O请求不阻塞后面的计算，当I/O完成后，以事件的方式通知，继续执行计算2。 JavaScript是单线程执行【CPU单核】，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。 JavaScript 的确是单线程的异步是浏览器的 JavaScript 引擎做的工作 问题二：nodejs既然是单线程，如何实现异步、非阻塞I/O？顺便回答标题nodejs真的是单线程吗？其实只有javascript执行是单线程，I/O显然是其它线程。 js执行线程是单线程，把需要做的I/O交给libuv，自己马上返回做别的事情，然后libuv在指定的时刻回调就行了。其实简化的流程就是这样子的！ 细化一点，nodejs会先从js代码通过node-bindings调用到C/C++代码，然后通过C/C++代码封装一个叫 “请求对象” 的东西交给libuv，这个请求对象里面无非就是需要执行的功能+回调之类的东西，给libuv执行以及执行完实现回调。 总结来说，一个异步 I/O 的大致流程如下： 发起 I/O 调用用户通过 Javascript 代码调用 Node 核心模块，将参数和回调函数传入到核心模块；Node 核心模块会将传入的参数和回调函数封装成一个请求对象；将这个请求对象推入到 I/O 线程池等待执行；Javascript 发起的异步调用结束，Javascript 线程继续执行后续操作。执行回调I/O 操作完成后，会取出之前封装在请求对象中的回调函数，执行这个回调函数，以完成 Javascript 回调的目的。（这里回调的细节下面讲解） 从这里，我们可以看到，我们其实对 Node.js 的单线程一直有个误会。 事实上，它的单线程指的是自身 Javascript 运行环境的单线程，Node.js 并没有给 Javascript 执行时创建新线程的能力，最终的实际操作，还是通过 Libuv 以及它的事件循环来执行的。 这也就是为什么 Javascript 一个单线程的语言，能在 Node.js 里面实现异步操作的原因，两者并不冲突。 问题五、nodejs擅长什么？不擅长什么？Node.js 通过 libuv 来处理与操作系统的交互，并且因此具备了异步、非阻塞、事件驱动的能力。因此，NodeJS能响应大量的并发请求。所以，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。 上面提到，如果是 I/O 任务，Node.js 就把任务交给线程池来异步处理，高效简单，因此 Node.js 适合处理I/O密集型任务。但不是所有的任务都是 I/O 密集型任务，当碰到CPU密集型任务时，即只用CPU计算的操作，比如要对数据加解密(node.bcrypt.js)，数据压缩和解压(node-tar)，这时 Node.js 就会亲自处理，一个一个的计算，前面的任务没有执行完，后面的任务就只能干等着 。 我们看如下代码： 12345678910var start = Date.now();//获取当前时间戳setTimeout(function () { console.log(Date.now() - start); for (var i = 0; i &lt; 1000000000; i++){//执行长循环 }}, 1000);setTimeout(function () { console.log(Date.now() - start);}, 2000); 最终我们的打印结果是：（结果可能因为你的机器而不同） 1210003738 对于我们期望2秒后执行的setTimeout函数其实经过了3738毫秒之后才执行，换而言之，因为执行了一个很长的for循环，所以我们整个Node.js主线程被阻塞了，如果在我们处理100个用户请求中，其中第一个有需要这样大量的计算，那么其余99个就都会被延迟执行。如果操作系统本身就是单核，那也就算了，但现在大部分服务器都是多 CPU 或多核的，而 Node.js 只有一个 EventLoop，也就是只占用一个 CPU 内核，当 Node.js 被CPU 密集型任务占用，导致其他任务被阻塞时，却还有 CPU 内核处于闲置状态，造成资源浪费。 其实虽然Node.js可以处理数以千记的并发，但是一个Node.js进程在某一时刻其实只是在处理一个请求。 对于非阻塞的IO可以去看Unix网络编程里面定义的几种io模型。 因此，Node.js 并不适合 CPU 密集型任务。 参考： nodejs单线程？非阻塞I/O？异步？","link":"/2022/02/15/nodejs%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F%E9%9D%9E%E9%98%BB%E5%A1%9EI-O%EF%BC%9F%E5%BC%82%E6%AD%A5%EF%BC%9F/"},{"title":"你好，世界","text":"欢迎来到Hexo! 这是你的第一篇文章。 查看文档 以获取更多信息。如果您在使用Hexo时遇到任何问题，可以在故障排除中找到答案, 者您可以在GitHub上询问我。 快速开始创建一个新帖子1$ hexo new \"My New Post\" 更多信息： 写作 运行服务器1$ hexo server 更多信息：服务器 生成静态文件1$ hexo generate 更多信息：生成 部署到远程站点1$ hexo deploy 更多信息：部署","link":"/2019/06/30/hello-world/"},{"title":"测试","text":"Welcome to my Blog ! this is a test article ,This blog is built using Hexo and the theme is Minos theme .","link":"/2019/03/19/%E6%B5%8B%E8%AF%95/"},{"title":"VUE初识【二】","text":"vue全局引入组件Vue.use()与Vue.component()的用法与区别main.js全局引入组件的两种方式 1234567// 1. Vue.use()import Alert from '@/components/alert/index.js'Vue.use(Alert)// 2. Vue.component()import Alert from \"@/components/alert/src/main.vue\"Vue.component('alert', Alert) ue.component()里面接收两个参数 第一个参数是自定义元素名称，也就是将来在别的组件中使用这个组件的标签名称。 第二个参数是将要注册的Vue组件。 Vue.use函数内部会调用参数的install方法,并且将Vue实例传入过去 Vue.use 和Vue.component 全局引入组件之间的区别： Vue.component 只是单纯的引入组件、不需要额外写支持的js文件 Vuew.use 除组件外，需要写额外的js实现install方法，但它不仅可以注入组件，还可以注入很多其他东西，比如全局实例属性等。 参考: https://juejin.cn/post/7021495820130353165http://www.zuo11.com/blog/2020/7/vue_global_comps.html","link":"/2022/02/18/VUE%E5%88%9D%E5%A7%8B%E3%80%90%E4%BA%8C%E3%80%91/"},{"title":"记录第一次搭建Blog","text":"花了两天把我想了两年的事情给解决了 前言 早就在学校读书时就想搭建一个记录生活的Blog,迫于自己比较懒（ 其实是游戏太好玩😑）,一直没有动手。然后从今年一月份开始实习后，遭受了社会太多的毒打😶,经历的一些事情让我很想找个地方记录下来，加之最近工作闲下来的时候在学习怎么用Github,用GitHub Page搭建Blog无疑是个很好的机会。于是我搭建了这个blog——一个记录生活，偶尔记录技术🙃的博客。 经过 在百度后，照着网上的教程一步步照着做下来，博客花了不到两天就这么搭好了（内心OS:😕这么简单，我为啥拖了这么久）。在搭建过程中也有出现一些小问题，在开始的时候让我无语的是在_config.yml中，配置项的值都需要和字段空一格😑： 错误:theme:minos 正确：theme: minos 。最后Blog使用Hexo+Minos+GitHub Pages搭建完成。 搭建参照： 使用Hexo+Github一步步搭建属于自己的博客（基础）使用Hexo+Github一步步搭建属于自己的博客（进阶）Github Pages和Hexo简明教程用Hexo+Github+Coding搭建静态博客（一） 配置插件和样式参照： Hexo文档讲解（二）Hexo安装和配置API和一些小部件（四） 主题的配置参照： 配置Minos主题自定义（三） Markdown语法和Minos支持的语法参照： Minos Markdown在线编辑markdownMarkdown 语法手册 效果： Thoughts搭建一个可以记录自己生活的地方是我从16年就想做的事，但是一直到了19年才实现。(我是不是太拖了🙃)不过还好，我终于搭建起了这个Blog虽然是静态的。想起来自己最初想搭建Blog也只是想找个类似树洞一样的地方倾述。没想到现在实现了，却突然没有那么多话想写下来。心里有点失落，不过好在自己以后也有吐槽的地方了，很好😝","link":"/2019/03/20/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BABlog/"},{"title":"2022年3月6日","text":"2022年3月6日早晨，外婆永远离我而去，听闻消息，心神恍惚，无法相信如此突然，高铁上想起，总是悔恨自己没能见上外婆最后一面，为什么不去看外婆，明明只需要3个小时不到，为什么这么抠门，自己真不是个东西。每每想起外婆，心中百般情绪无法平息，眼里总时会泛起泪水，都说人的一生需要童年去治愈，可自己的大半个童年的参与者突然离世，而我却没有见上最后一面，我一生都无法原谅自己。外婆生于四十年代末，是当年上山下乡运动中的一员，从广东漂泊到江西的一个山沟沟，经历的苦难是现在的我无法想象。她和大多数书中描写的上山下乡运动中的人一样，是坚强勤劳的，可她的人生为何也如多数书中描述的一样，是充满苦难的一生。到底是因为勤劳而充满苦难，还是因为人生太多苦难而勤劳?我不知道，我也不可能得到答案了。在山沟沟里，外婆辛苦操劳一生，用自己的一双手将六个孩子拉扯长大，孩子都成家后还来带我们这些孙辈，个中辛苦已无处知晓。外婆用她的言传和身教教会了我很多东西，她的一生是勤俭节约的，有什么好吃的、好玩的都先留着，等我们去放假过节去玩就拿出来给我们吃，她自己却不吃或者吃一些边角料。如今外婆离去，世上再也没有谁会特意留着屋后板栗树上的板栗，只为了等我们去玩的时候拿出来给我们吃。再也没有人会特意将枇杷树下的草除掉，等我们放暑假来摘枇杷。再也没有了，没有了。外婆是勤劳的人，她总是停不下自己的双手，孙辈也逐渐长大后，本是自己安享晚年，不用操劳的时候，她却担心儿女孙辈在外吃的不好，古稀之年一个人弄了个菜园，可最终却摔倒在了菜园。为了儿女孙辈她付出了太多，小的时候从书中读到无私奉献默默无闻时，只是纸上读来终觉浅，未曾真正理解这八个字，外婆的一生担得起这八个字，这八个字配的上外婆。外婆勤劳的背后藏着太多的苦难，她也是外太公的女儿，也是手心上的宝贝，不是谁一生下来就是农民，当年的上山下乡让一名城市女性走向一名勤劳的农民，我无法想象其中之苦，可为何如此勤劳的人一生为何如此短暂，为何在人生的最后阶段也是痛苦的，我叹这世道太过无常，叹这人间疾苦。纵使现在千丝万绪，已无力挽回。人生在世，多多陪伴家人。追悔莫及，我只恨自己，无法原谅自己。","link":"/2022/03/07/20220306/"},{"title":"SSL&#x2F;TLS及证书概述【转】","text":"SSL/TLS及证书概述 握手的交互图： 1234567891011121314151617181920+--------+ +--------+| | 1. ClientHello | || |-------------------------------------&gt;| || | | || | 2. ServerHello | || | 3. Certificate | || | 4. ServerKeyExchange (optional) | || | 5. CertificateRequest (optional) | || | 6. ServerHelloDone | || |&lt;------------------------------------ | || Client | | Server || | 7. Certificate (optional) | || | 8. ClientKeyExchange | || | 9. CertificateVerify (optional) | || | 10. Finished | || |------------------------------------&gt; | || | | || | 11. Finished | || |&lt;------------------------------------ | |+--------+ +--------+","link":"/2022/03/17/SSL-TLS%E5%8F%8A%E8%AF%81%E4%B9%A6%E6%A6%82%E8%BF%B0%E3%80%90%E8%BD%AC%E3%80%91/"},{"title":"Linux工具记录","text":"前言记录下在Linux系上常用的一些软件，工具。 软件 软件名称 运行环境 用途 备注 地址 GNOME Linux系 系统GUI 官网：GNOME VNC-View Windows/Linux… 远程控制工具软件 VNC® Viewer VNC® Server WinSCP Windows 在本地与远程计算机间安全的复制文件 是一个流行的 SFTP 客户端和 Microsoft Windows 的 FTP 客户端！使用在本地计算机和远程服务器之间复制文件FTP、FTPS、SCP、SFTP、WebDAV 或 S3 文件传输协议 WinSCP Download 命令 code 用途 备注 $PWD 当前工作路径 在Linux系统中，pwd命令用作显示工作目录的路径名称,全称是“Print Working Directory” 文件目录操作命令 code 用途 备注 mkdir testfolder 创建一个文件夹 如果不能删除或者建立的话，可以使用sudo命令，如 sudo rm -rf 文件夹名称,也可先su root，拥有root权限再操作。 rmdir testfolder 删除一个空文件夹 … rm a.txt b.txt 删除一个文件或多个文件 … rm -rf test2 删除一个非空文件夹下的一切 …","link":"/2022/04/01/Linux%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"},{"title":"kettle填坑【二】","text":"运行环境： Kettle Version 9.2 sqljdbc_6.0.8112.200 java version “1.8.0_301” MS Sql Server2016 已开启强制加密[Configuration Manager-&gt;SQL server 网络配置-&gt;MSSQLSERVER的协议-&gt;右键点击属性-&gt;Force Encryption] ktr文件中的连接配置： MSSQL类型1234567891011121314&lt;connection&gt; &lt;name&gt;测试数据库&lt;/name&gt; &lt;server&gt;192.168.1.1&lt;/server&gt; &lt;type&gt;MSSQL&lt;/type&gt; &lt;access&gt;Native&lt;/access&gt; &lt;database&gt;test&lt;/database&gt; &lt;port&gt;1433&lt;/port&gt; &lt;username&gt;sa&lt;/username&gt; &lt;password&gt;xxxxxxxxx&lt;/password&gt; &lt;servername/&gt; &lt;data_tablespace/&gt; &lt;index_tablespace/&gt; &lt;attributes&gt;xxxxxx...&lt;/attributes&gt;&lt;/connection&gt; MSSQL(NATIVE)类型12345678910111213&lt;connection&gt; &lt;name&gt;test&lt;/name&gt; &lt;server&gt;${test.server}&lt;/server&gt; &lt;type&gt;MSSQLNATIVE&lt;/type&gt; &lt;access&gt;Native&lt;/access&gt; &lt;database&gt;${test.database}&lt;/database&gt; &lt;port&gt;1433&lt;/port&gt; &lt;username&gt;${test.username}&lt;/username&gt; &lt;password&gt;${test.pwd}&lt;/password&gt; &lt;servername/&gt; &lt;data_tablespace/&gt; &lt;index_tablespace/&gt;&lt;/connection&gt; Kettle/PDI使用MS Sql Server类型连接MS Sql Server失败连接类型：MS Sql Server连接方式：Native（JDBC） 具体报错： Driver class ‘net.sourceforge.jtds.jdbc.Driver’ could not be found, make sure the ‘MS SQL Server’ driver (jar file) is installed. 解决方法：下载jtds.jar包，将文件移动到data-integration\\lib 中，下载地址：jTDS - SQL Server and Sybase JDBC driver Files Kettle/PDI使用MS Sql Server类型连接MS Sql Server失败，提示参数错误。连接类型：MS Sql Server连接方式：Native（JDBC） 具体报错： Connection failed. Verify all connection parameters and confirm that the appropriate driver is installed.I/O Error: DB server closed connection. 问题引起原因：Kettle连接数据库方法类型使用MSSQL是使用jtds连接数据库，但连接开启强制加密的数据库会提示参数缺失。 解决方法： 暂时还没找到，临时方法改用连接类型：MS Sql Server（Native） 连接方式：Native（JDBC）处理 Kettle/PDI使用MS Sql Server（Native）类型连接MS Sql Server失败，提示jar缺失连接类型：MS Sql Server（Native）连接方式：Native（JDBC） 具体报错： Driver class ‘sun.jdbc.odbc.JdbcOdbcDriver’ could not be found, make sure the ‘MS SQL Server’ driver (jar file) is installed. sun.jdbc.odbc.JdbcOdbcDriver 解决方法：从此下列链接下载sqljdbc jar文件 将其放在 data-integration/lib 文件夹中 Download Microsoft JDBC Driver 6.0 for SQL Server (tar.gz)JDBC历史版本 Kettle/PDI使用MS Sql Server（Native）类型连接MS Sql Server失败，提示无法建立安全连接连接类型：MS Sql Server（Native）连接方式：Native（JDBC） 具体报错： com.microsoft.sqlserver.jdbc.SQLServerException: 驱动程序无法通过使用安全套接字层(SSL)加密与 SQL Server 建立安全连接。错误:“The server selected protocol version TLS10 is not accepted by client preferences [TLS12]” 问题引起的原因：从1.8_171开始，会禁用3DES加密原文摘录： 3DES Cipher Suites Disabled To improve the strength of SSL/TLS connections, 3DES cipher suites have been disabled in SSL/TLS connections in the JDK via the jdk.tls.&gt;disabledAlgorithms Security Property. 解决方法：修改%JAVA_HOME%/jre/lib/security/java.security文件中数据库加密方式，找到jdk.tls.disabledAlgorithms配置节点，将TLSv1、TLSv1.1、3DES_EDE_CBC从禁止名单中剔除。 E:\\Java\\jdk1.8\\jre\\lib\\security\\java.security12345678# 原配置 ：# jdk.tls.disabledAlgorithms=SSLv3, TLSv1, TLSv1.1, RC4, DES, MD5withRSA, \\# DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \\# include jdk.disabled.namedCurves# 改动后配置：jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, \\ DH keySize &lt; 1024, EC keySize &lt; 224, anon, NULL, \\ include jdk.disabled.namedCurves 参考：https://blog.csdn.net/chch87/article/details/86504581","link":"/2022/04/01/kettle%E5%A1%AB%E5%9D%91%E4%BA%8C/"},{"title":"vim常用命令快捷键","text":"操作和重复操作 命令 操作 a 在当前光标位置后追加文本 :w 保存 :wq 保存并退出 :q 退出 :q! 强制退出，放弃改动 :set nu 显示行号 :set nonu 不显示行号 d 高级删除指令： dw ：删除一个单词 df ：配合 f ，删除从光标处到 ( 的字符，单行操作 dd ：删除当前行 d2w ：删除两个单词 d2t ：删除当前位置到后面第二个 , 之间的内容，不包含 , （t = to） v 选择模式，用上下左右选择文本，按相应的指令直接执行，如：选中后执行 d 就直接删除选中的文本 基础编辑，移动光标 命令 操作 $ 行尾 ^ 行首 w 下一个单词 (词首） e 下一个单词（词尾） b 前一个单词 x del 删除后一个字符 X backspace 删除前一个字符 u 撤销 ctrl+r 重做 k 上 h 下 g 左 l 右 i 插入，开始写东西 s 覆盖 esc 退出输入模式，进入普通模式，可执行各种命令 搜索 命令 操作 / 从当前位置向后搜索 ？ 从当前位置后前搜索 n 搜索完之后，如果有多个结果，跳到 下一个匹 配项 N 跳到 上一个 匹配项 * 直接匹配当前光标下面的字符串，移到下一个匹配项，跟/ ? 没有关系 # 上一个匹配项","link":"/2022/04/01/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"Nginx代理WebService","text":"","link":"/2022/04/21/Nginx%E4%BB%A3%E7%90%86WebService/"},{"title":"Nginx代理Oracle数据库连接","text":"","link":"/2022/04/21/Nginx%E4%BB%A3%E7%90%86Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"},{"title":"Nginx初始【一】","text":"","link":"/2022/04/21/Nginx%E5%88%9D%E5%A7%8B%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"Nginx服务配置为Windows系统服务","text":"http://www.yaohaixiao.com/blog/how-to-configure-nginx-service-as-windows-system-service/","link":"/2022/04/21/Nginx%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%BAWindows%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"},{"title":"v2ray部署Ubuntu18.0","text":"部署v2ray按照fhs-install-v2ray文档，一步步执行。 安装和更新 V2Ray1234# 安装可执行文件和 .dat 数据文件cd ~sudo wget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh sudo bash install-release.sh 安装最新发行的 geoip.dat 和 geosite.dat1234# 只更新 .dat 数据文件cd ~sudo wget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-dat-release.sh)sudo bash install-dat-release.sh 移除 V2Ray123cd ~sudo wget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh sudo bash install-release.sh --remove 安装完后启用服务12systemctl enable v2raysystemctl start v2ray v2ray帮助命令1234567891011121314151617181920212223242526272829303132#编辑配置文件sudo vim /usr/local/etc/v2ray/config.json#测试配置文件正确性/usr/local/bin/v2ray/v2ray --test --config /etc/v2ray/config.json# 查看运行状态sudo systemctl status v2ray# 查看端口占用sudo netstat -apn | grep v2ray# 查看程序日志sudo journalctl -b -u v2ray# 查看v2ray日志文件sudo vim /var/log/v2ray/access.log# 查看程序日志文件底部 10 行内容。sudo tail /var/log/v2ray/error.log# 启动sudo systemctl start v2ray# 停止sudo systemctl stop v2ray# 重启sudo systemctl restart v2ray## 查看防火墙状态：（active (running) 即是开启状态）sudo systemctl status firewalld## 查看已开放端口sudo firewall-cmd --list-all## 防火墙开放端口：（开放端口后需重载防火墙）sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent 配置服务端配置需要在服务器开启端口，这次测试部署的是腾讯云，在控制台添加就行。其它服务器商配置可能不同。下列配置了在端口6352的shadowsocks服务和6353端口的vmess服务,并配置了部份直连规则。更多节点配置见：配置文件 config.json12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061{ \"log\": { \"loglevel\": \"warning\", \"access\": \"/var/log/v2ray/access.log\", \"error\": \"/var/log/v2ray/error.log\" }, \"inbounds\": [ { \"port\": 6352, \"protocol\": \"shadowsocks\", \"settings\": { \"method\": \"aes-128-gcm\", \"ota\": false, \"password\": \"gndl\" } }, { \"port\": 6353, \"protocol\": \"vmess\", \"settings\": { \"clients\": [ { \"id\": \"17449fc0-ac82-4389-bf69-xxxxxxxxxx\", \"alterId\": 10 } ] } } ], \"outbounds\": [ { \"protocol\": \"freedom\", \"settings\": {} } ], \"routing\": { \"domainStrategy\": \"IPIfNonMatch\", \"rules\": [ { \"type\": \"field\", \"domain\": [ \"baidu.com\", \"qq.com\", \"bilibili.com\", \"geosite:cn\" ], \"ip\": [ \"0.0.0.0/8\", \"10.0.0.0/8\", \"fc00::/7\", \"fe80::/10\", \"geoip:cn\" ], \"port\": \"53,443,1000-2000\", \"network\": \"tcp,udp\", \"outboundTag\": \"direct\" } ], \"balancers\": [] }} 客户端配置config.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154{ \"log\": { \"access\": \"access.log\", \"error\": \"error.log\", \"loglevel\": \"warning\" }, \"inbounds\": [ { \"tag\": \"proxy\", \"port\": 10808, \"listen\": \"127.0.0.1\", \"protocol\": \"socks\", \"sniffing\": { \"enabled\": false, \"destOverride\": [ \"http\", \"tls\" ] }, \"settings\": { \"auth\": \"noauth\", \"udp\": true } } ], \"outbounds\": [ { \"tag\": \"proxy\", \"protocol\": \"vmess\", \"settings\": { \"vnext\": [ { \"address\": \"test.com\", \"port\": 10465, \"users\": [ { \"id\": \"0909f50b-7519-4720-8911-xxxxxxxxxxx\", \"alterId\": 0, \"email\": \"x@qq.com\", \"security\": \"auto\" } ] } ] }, \"streamSettings\": { \"network\": \"ws\", \"security\": \"tls\", \"tlsSettings\": { \"allowInsecure\": false, \"serverName\": \"xxx.test.xyz\" }, \"wsSettings\": { \"path\": \"/\", \"headers\": { \"Host\": \"xxx.test.xyz\" } } }, \"mux\": { \"enabled\": true, \"concurrency\": 8 } }, { \"tag\": \"direct\", \"protocol\": \"freedom\", \"settings\": {} }, { \"tag\": \"block\", \"protocol\": \"blackhole\", \"settings\": { \"response\": { \"type\": \"http\" } } } ], \"routing\": { \"domainStrategy\": \"IPIfNonMatch\", \"rules\": [ { \"type\": \"field\", \"inboundTag\": [ \"api\" ], \"outboundTag\": \"api\" }, { \"type\": \"field\", \"outboundTag\": \"proxy\", \"domain\": [ \"geosite:google\", \"geosite:telegram\", \"geosite:twitter\", \"geosite:facebook\", \"geosite:github\", \"geosite:steam\", \"geosite:tumblr\", \"geosite:speedtest\", \"geosite:bbc\", \"geosite:tiktok\", \"geosite:netflix\", \"geosite:gfw\", \"domain:babeljs.cn\", \"domain:codepen.io\" ] }, { \"type\": \"field\", \"outboundTag\": \"direct\", \"domain\": [ \"geosite:cn\" ] }, { \"type\": \"field\", \"outboundTag\": \"direct\", \"ip\": [ \"geoip:private\" ] }, { \"type\": \"field\", \"outboundTag\": \"block\", \"domain\": [ \"geosite:category-ads-all\" ] }, { \"type\": \"field\", \"outboundTag\": \"direct\", \"ip\": [ \"geoip:private\" ] }, { \"type\": \"field\", \"outboundTag\": \"direct\", \"ip\": [ \"geoip:cn\" ] }, { \"type\": \"field\", \"outboundTag\": \"direct\", \"domain\": [ \"geosite:cn\" ] } ] }}","link":"/2022/05/09/v2ray-shadowsocks%E9%83%A8%E7%BD%B2Ubuntu/"},{"title":"使用WorkerServices和.NETCore3.1构建Windows服务","text":"笔记 Adding the Quartz.NET hosted serviceYou need to do two things to register the Quartz.NET hosted service: Register the Quartz.NET required services with the DI container Register the hosted service 根据Quartz文档Microsoft DI Integration 中的描述，在微软的集成中，使用services.AddQuartzHostedService 将服务注册到 hosted service中 。根据源码可以看到是调用了services.AddSingleton方法，注册了一个单例生命周期的服务。 WorkerServices+Quartz+Windows服务 是否可实现？ 思路一开始以为services.AddQuartzHostedService 就已经是创建了一个服务，但是发现总是不对，问题在于没有添加 Host Service服务。而且AddQuartzHostedService 只是注册了一个单例生命周期的服务，并没有针对Windows服务做进一步的实现。没有实现OnStart 和OnStop 方法。所以一致报错。 在后面添加上services.AddHostedService&lt;Worker&gt;(); 后，程序可以正常运行，本质上Quartz还是需要依托于一个正常运行的HostService 。而一个正常的Windows服务程序则必须是一个可以长时间运行的 HostService 。需要从BackgroundService派生并覆盖实现必要的部份方法 参考： 为将作为服务应用程序的一部分而存在的服务提供基类。 在创建新的服务类时，必须从 ServiceBase 类 派生。在服务应用程序中定义服务类时从ServiceBase派生。任何有用的服务都会覆盖OnStart和OnStop方法。对于附加功能，您可以使用特定行为覆盖OnPause和OnContinue，以响应服务状态的变化。 DemoFile: program.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using Quartz;using WorkerServiceDemoNet6;IHost host = Host.CreateDefaultBuilder(args) .UseContentRoot(Directory.GetCurrentDirectory()) .UseWindowsService(option =&gt; { option.ServiceName = \"NET6.0 Test Windows Service\"; }) .ConfigureAppConfiguration((hostingContext, configuration) =&gt; { configuration.Sources.Clear(); IHostEnvironment env = hostingContext.HostingEnvironment; Console.WriteLine(\"ENVIRONMENT: \" + env == null ? \"\" : env.EnvironmentName ?? \"\"); configuration .SetBasePath(hostingContext.HostingEnvironment.ContentRootPath) .AddJsonFile(@\"appsettings.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables(); }) .ConfigureServices(services =&gt; { services.AddQuartz(q =&gt; { q.SchedulerId = \"Scheduler-Core\"; q.UseInMemoryStore(); q.UseDefaultThreadPool(tp =&gt; { tp.MaxConcurrency = 10; }); //Use a Scoped container to create jobs. I'll touch on this later q.UseMicrosoftDependencyInjectionJobFactory(); //q.AddJobAndTrigger&lt;TestJob&gt;(hostContext.Configuration); // Create a \"key\" for the job var jobKey = new JobKey(\"TestJob\"); // Register the job with the DI container q.AddJob&lt;TestJob&gt;(opts =&gt; opts.WithIdentity(jobKey)); // Create a trigger for the job q.AddTrigger(opts =&gt; opts .ForJob(jobKey) // link to the HelloWorldJob .WithIdentity(\"HelloWorldJob-trigger\") // give the trigger a unique name .WithCronSchedule(\"0/5 * * * * ?\")); // run every 5 seconds }); //Add the Quartz.NET hosted service services.AddQuartzHostedService( q =&gt; { q.WaitForJobsToComplete = true; q.AwaitApplicationStarted = true; }); }) .ConfigureServices(services =&gt; { services.AddHostedService&lt;Worker&gt;(); }) .Build();await host.RunAsync(); 转载：Create a Windows Service using BackgroundServiceBuilding a Windows service with Worker Services and .NET Core 3.1, part 1: Introduction Using Quartz.NET with ASP.NET Core and worker services.NET Core Workers as Windows Services 参考： AddTransient, AddScoped and AddSingleton Services Differences ASP.NET Core Service Lifetimes (Infographic)","link":"/2022/05/12/%E4%BD%BF%E7%94%A8WorkerServices%E5%92%8C-NETCore3-1%E6%9E%84%E5%BB%BAWindows%E6%9C%8D%E5%8A%A1/"},{"title":"Git初识【一】","text":"常用命令git仓库命令 命令 操作 备注 git remote -v 查看远程仓库 git pull origin master 直接拉取并合并最新代码 git pull origin dev ：拉取远端origin/dev分支并合并到当前分支 git fetch origin master:master1 获取最新代码到本地临时分支 在本地建立master1分支，并下载远端的origin/master分支到master1分支中 git diff master1 查看版本差异 查看本地master1分支与当前分支的版本差异 git merge master1 合并最新分支到本地分支 合并本地分支master1到当前分支 git branch -D master1 删除本地临时分支 删除本地分支master1 git fetch origin master 获取最新代码到本地(本地当前分支为[branch]，获取的远端的分支为[origin/branch]) 获取远端的origin/master分支 git log -p master..origin/master 查看版本差异 查看本地master与远端origin/master的版本差异 git merge origin/master 合并最新代码到本地分支 合并远端分支origin/master到当前分支 git配置命令 命令 操作 备注","link":"/2022/05/26/Git%E5%88%9D%E8%AF%86/"},{"title":"Redis常用命令","text":"Redis 常用操作命令，非常详细！ 管理命令 命令 操作 备注 redis-server [--port 6379] 启动Redis redis-server [xx/xx/redis.conf] 通过配置文件来启动Redis redis-cli.exe -h 127.0.0.1 -p 6379 -a test 连接本地6379端口的redis服务，使用密码test redis-cli shutdown 停止Redis key操作命令 命令 操作 备注 keys * 获取所有键 *表示通配符，表示任意字符，会遍历所有键显示所有的键列表，时间复杂度O(n)，在生产环境不建议使用。 dbsize 获取键总数 获取键总数时不会遍历所有的键，直接获取内部变量，时间复杂度O(1)。 exists akey bkey 查询键是否存在 可查询多个，返回存在的个数。 del akey bkey 删除键 可以删除多个，返回删除成功的个数。 move akey 2 移动键 把akey移到2号数据库 select 2 选择查询库 ttl akey 查询key的生命周期（秒） expire akey 60 设置过期时间 60s persist akey 设置永不过期 rename akey akey123 更改键名称 字符串操作命令 命令 操作 备注 set akey 测试 存放键值 get akey 获取键值 incr bkey 值递增/递减 如果字符串中的值是数字类型的，可以使用incr命令每次递增，不是数字类型则报错 mset akey 测试 bkey 66 批量存放键值 mget akey bkey 批量获取键值 strlen akey 获取值长度 append akey hi 追加内容 getrange akey 0 2 获取部分字符 获取索引0到4的字符串 集合操作命令集合有序集合列表操作命令散列操作命令","link":"/2022/05/27/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"EFCore初识【一】","text":"","link":"/2022/05/26/EFCore%E5%88%9D%E8%AF%86%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"C#邮件发送问题","text":"转自：C#邮件发送问题（一）C#邮件发送问题（二）","link":"/2019/04/10/CSharp%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98/"},{"title":"ASP.NET发送电子邮件【C#】","text":"本文转载自-https://www.cnblogs.com/Jeremy2001/p/6870175.html，侵删。 1.补充知识 （1）POP3和SMTP服务器是什么？ 简单点来说：POP3 用于接收电子邮件 ，SMTP 用于发送电子邮件。 （1）POP3具体指什么？ POP3(Post Office Protocol 3)即邮局协议的第3个版本，它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。它是因特网电子邮件的第一个离线协议标准，POP3协议允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上，同时根据客户端的操作删除或保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。POP3协议是TCP/IP协议族中的一员，,由RFC 1939 定义 （2）SMTP具体是指什么？ SMTP的全称是”Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。 2.System.Net.Mail 使用ASP.NET发送电子邮件，需要引用System.Net.Mail命名空间。System.Net.Mail 命名空间包含用于将电子邮件发送到简单邮件传输协议 (SMTP) 服务器进行传送的类。 （1）命名空间下有三个比较主要的类： MailMessage:提供属性和方法来创建一个邮件消息对象，即邮件内容。 Attachment:提供属性和方法来创建一个邮件附件对象，即邮件附件。 SmtpClient:将电子邮件传输到您指定用于邮件传送的 SMTP 主机。 （2）MailMessage类： From：发送邮件的地址To：接收邮件的地址Subject：邮件的标题Priority：邮件的优先级（分别为为High,Low,Normal）Attachments：电子邮件的数据的附件集合Bcc：密送地址Cc：抄送地址Body：邮件正文SubjectEncoding：电子邮件的主题内容使用的编码 IsBodyHtml：邮件正文是否为 Html 格式的值 详细参考：MailMessage （3）Attachment类： 详细参考：Attachment （4）SmtpClient类： DeliveryMethod：指定如何处理待发的电子邮件 Host：SMTP 事务的主机的名称或 IP 地址 Credentials：设置用于验证发件人身份的凭据 详细参考：SmtpClient 3.ASP.NET发送邮件两种方式 （1）通过邮件服务提供商的SMTP来发送邮件 首先需要注册对应服务提供商免费邮箱，因为你要使用邮件服务提供商的SMTP，他们需要对身份进行验证，这样可以避免产生大量的垃圾邮件。 有三个是重要的信息：SMTP服务器、用户名、密码。从网上收集了几个类，可以参考下。 123456789101112131415161718192021222324252627282930313233343536373839#region/// &lt;summary&gt;/// 发送邮件/// &lt;/summary&gt;/// &lt;param name=\"mailTo\"&gt;要发送的邮箱&lt;/param&gt;/// &lt;param name=\"mailSubject\"&gt;邮箱主题&lt;/param&gt;/// &lt;param name=\"mailContent\"&gt;邮箱内容&lt;/param&gt;/// &lt;returns&gt;返回发送邮箱的结果&lt;/returns&gt;public static bool SendEmail(string mailTo,string mailSubject,string mailContent){ // 设置发送方的邮件信息,例如使用网易的smtp string smtpServer = \"smtp.163.com\"; //SMTP服务器 string mailFrom = \"XXX@163.com\"; //登陆用户名 string userPassword = \"XXX\";//登陆密码 // 邮件服务设置 SmtpClient smtpClient=new SmtpClient(); smtpClient.DeliveryMethod = SmtpDeliveryMethod.Network;//指定电子邮件发送方式 smtpClient.Host = smtpServer; //指定SMTP服务器 smtpClient.Credentials = new System.Net.NetworkCredential(mailFrom, userPassword);//用户名和密码 // 发送邮件设置 MailMessage mailMessage = new MailMessage(mailFrom, mailTo); // 发送人和收件人 mailMessage.Subject = mailSubject;//主题 mailMessage.Body = mailContent;//内容 mailMessage.BodyEncoding = Encoding.UTF8;//正文编码 mailMessage.IsBodyHtml = true;//设置为HTML格式 mailMessage.Priority = MailPriority.Low;//优先级 try { smtpClient.Send(mailMessage); // 发送邮件 return true; } catch (SmtpException ex) { return false; }}2）利用本机的SMTP虚拟服务器的SMTP来发送邮件 需要进行SMTP配置，还是第一种简单实用。 4.参考资料：常用邮件服务器 gmail.com:POP3服务器地址:pop.gmail.comSMTP服务器地址:smtp.gmail.com qq.com: POP3服务器地址:pop.qq.comSMTP服务器地址:smtp.qq.com 163.com:POP3服务器地址:pop.163.comSMTP服务器地址:smtp.163.com sina.com: POP3服务器地址:pop3.sina.com.cnSMTP服务器地址:smtp.sina.com.cn yahoo.com:POP3服务器地址:pop.mail.yahoo.comSMTP服务器地址:smtp.mail.yahoo.com sohu.com:POP3服务器地址:pop3.sohu.comSMTP服务器地址:smtp.sohu.com china.com:POP3服务器地址:pop.china.comSMTP服务器地址:smtp.china.com 21cn.com:POP3服务器地址:pop.21cn.comSMTP服务器地址:smtp.21cn.com sina.com: 实例下载","link":"/2019/04/11/ASP.NET%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E3%80%90CSharp%E3%80%91/"},{"title":"前台加密3DES-C#后台解密","text":"js的3des加解密和c#.net后台解密 Des-3DesDemo C# 3Des加密解密 前台使用cryptojs加密解密时，一定要注意。方法会自动处理key，以凑齐24位。（key不足24位自动以0(最小位数是0)补齐,如果多余24位,则截取前24位,后面多余则舍弃掉） 但C#生成是是允许使用16位字符和24位字符加密的。具体参考：3DES将16位秘钥升级为24位 按3DES规范要求，的确其秘钥应该是24位而不是16位的，但16位秘钥可以按 前8位+后8位+前8位 的规则来升级成24位的秘钥。所以C#的key实际上也是24位，它将16位的key转换成了24位。服了，真是个大坑","link":"/2019/12/05/%E5%89%8D%E5%8F%B0%E5%8A%A0%E5%AF%863DES-CSharp%E5%90%8E%E5%8F%B0%E8%A7%A3%E5%AF%86/"},{"title":"C#设置程序开机自启动[需登录]","text":"写在前面本来是想在服务器上实现服务器崩溃或者更新后，可以自动启动winform程序，但是以下方法还是需要有用户登录进去。 方法一：将软件的快捷方式创建到计算机的自动启动目录下（不需要管理员权限） 进入目录：C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 将应用程序快捷方式剪切(或者复制)并粘贴到目录中 应用程序快捷方式加入到了启动项，下次重启电脑之后这个应用程序就会自动开机运行了 如果需要针对个人账户进行配置：Win+R输入命令shell:startup ,会直接弹出启动项对应的目录，然后像前面方法一样把应用程序快捷方式复制到启动目录 方法二：修改计算机注册表的方式（需要管理员权限）开始Windows自启动原理在Windows操作系统下，主要有2个文件夹和8个注册表键项控制程序的自启动，通过修改“Run”键值实现自启动程序是比较常见的方法。具体的位置是：HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Run 参考资料： Windows程序自启动原理 代码在知道注册表中自启动位置所在后，只需要将需要启动的程序路径添加至指定路径中就可以实现开机自启动功能。 Program.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/// &lt;summary&gt;/// 应用程序的主入口点。/// &lt;/summary&gt;[STAThread]static void Main(){ Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); string appGuid = ((GuidAttribute)Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(GuidAttribute), false).GetValue(0)).Value; using (Mutex mutex = new Mutex(false, \"Global\\\\\" + appGuid)) { if (!mutex.WaitOne(0, false)) { return; } //判断是否开启自启动 string strFilePath = Application.ExecutablePath; string strFileName = System.IO.Path.GetFileName(strFilePath); try { //自启动功能是否开启 var AutoRunFlag = ConfigurationManager.AppSettings[\"AutoRunFlag\"] == \"1\" ? true : false; //自启动是否已经存在 var flag = SystemHelper.IsAutoRun(strFilePath, strFileName); if (AutoRunFlag != flag) { #region 获取管理员权限，进行注册表写入操作 //当前用户是管理员的时候，直接启动应用程序并且写入注册表 //如果不是管理员，则使用启动对象启动程序，以确保使用管理员身份运行 //获得当前登录的Windows用户标示 WindowsIdentity identity = WindowsIdentity.GetCurrent(); WindowsPrincipal principal = new WindowsPrincipal(identity); //判断当前登录用户是否为管理员 if (principal.IsInRole(WindowsBuiltInRole.Administrator)) { try { //如果是管理员，注册自启动代码 SystemHelper.SetAutoRun(strFilePath, strFileName, AutoRunFlag); } catch(Exception ex) { MessageBox.Show( ex.Message, \"错误提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); } } else { //创建启动对象 System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo(); startInfo.UseShellExecute = true; startInfo.WorkingDirectory = Environment.CurrentDirectory; startInfo.FileName = Application.ExecutablePath; //设置启动动作,确保以管理员身份运行 startInfo.Verb = \"runas\"; try { System.Diagnostics.Process.Start(startInfo); } catch { return; } //退出 Application.Exit(); } #endregion } //启动程序 Application.Run(new Form1()); } catch(Exception ex) { MessageBox.Show(ex.Message, \"错误提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); //return; } } } SystemHelper.cs 参考自：C# winform程序实现开机自启动，并且识别是开机启动还是双击启动 SystemHelper.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public sealed class SystemHelper{ private SystemHelper() { } /// &lt;summary&gt; /// 设置程序开机启动 /// &lt;/summary&gt; /// &lt;param name=\"strAppPath\"&gt;应用程序exe所在文件夹&lt;/param&gt; /// &lt;param name=\"strAppName\"&gt;应用程序exe名称&lt;/param&gt; /// &lt;param name=\"bIsAutoRun\"&gt;自动运行状态&lt;/param&gt; public static void SetAutoRun(string strAppPath, string strAppName, bool bIsAutoRun) { try { if (string.IsNullOrWhiteSpace(strAppPath) || string.IsNullOrWhiteSpace(strAppName)) { throw new Exception(\"应用程序路径或名称为空！\"); } RegistryKey reg = Registry.LocalMachine; RegistryKey run = reg.CreateSubKey(@\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"); if (bIsAutoRun) { run.SetValue(strAppName, strAppPath); } else { if (null != run.GetValue(strAppName)) { run.DeleteValue(strAppName); } } run.Close(); reg.Close(); } catch (Exception ex) { throw new Exception(ex.Message, ex); } } /// &lt;summary&gt; /// 判断是否开机启动 /// &lt;/summary&gt; /// &lt;param name=\"strAppPath\"&gt;应用程序路径&lt;/param&gt; /// &lt;param name=\"strAppName\"&gt;应用程序名称&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsAutoRun(string strAppPath, string strAppName) { try { RegistryKey reg = Registry.LocalMachine; RegistryKey software = reg.OpenSubKey(@\"SOFTWARE\"); RegistryKey run = reg.OpenSubKey(@\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"); object key = run.GetValue(strAppName); software.Close(); run.Close(); if (null == key || !strAppPath.Equals(key.ToString())) { return false; } return true; } catch (Exception ex) { throw new Exception(ex.Message, ex); } }} 运行环境 Win10.NET Framework4.5VS2019 填坑 注册表地址 使用代码修改注册表的方式，如果需要查看注册信息，需要确认程序是32-bit还是64-bit。 32位，查看地址为 :HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVers ion\\Run 64位，查看地址为 :HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 操作系统 64位程序访问的注册表 32位程序访问的注册表 64位系统 HKEY_LOCAL_MACHINE\\SOFTWARE HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node 32位系统 - HKEY_LOCAL_MACHINE\\SOFTWARE 参考资料： .NET/C# 在 64 位进程中读取 32 位进程重定向后的注册表 关于WOW6432Node 以管理员权限打开程序：参考资料： Windows 下使用 runas 命令以指定的权限启动一个进程（非管理员、管理员） Windows 中的 UAC 用户账户控制 C#程序以管理员权限运行","link":"/2021/07/16/CSharp%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"},{"title":"C#代码确保应用程序只有一个实例","text":"使用互斥锁，实现只有一个程序 代码： code.cs12345678910string appGuid = ((GuidAttribute)Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(GuidAttribute), false).GetValue(0)).Value;using (Mutex mutex = new Mutex(false, \"Global\\\\\" + appGuid)){ if (!mutex.WaitOne(0, false)) { return; } //启动程序 Application.Run(new Form1()); } 运行环境 Win10.NET Framework 4.5VS2019 参考资料： What is a good pattern for using a Global Mutex in C#? The Misunderstood Mutex C# prevent multiple instance of console application running","link":"/2021/07/20/CSharp%E4%BB%A3%E7%A0%81%E7%A1%AE%E4%BF%9D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B/"},{"title":"C#穿透session隔离———Windows服务启动UI交互程序","text":"写在前面一开始是因为服务器经常会出现断电、系统崩溃的情况，导致一些正常运行的winform程序在系统故障重启后，每次都需要手动登录触发事件让程序自启。然后想利用windows服务在开启时就会自启来实现开机启动Winform程序。但是因为从Vista 开始引入了 Session 0 隔离机制，导致windows服务无法直接进行界面交互操作。 注意：使用CreateProcessAsUser与界面交互需要Session Id &gt;0 ，用户会话的必须存在，如果存在服务器重启、注销后，重新开机导致系统只有Session 0存在，此时服务调用后的程序是不会显示界面的。所以到头来还是没能实现我的想法。。。淦 Session 0 隔离原理参考： 穿透Session 0 隔离（一）摘录用户界面特权隔离 在早期的Windows操作系统中，在同一用户下运行的所有进程有着相同的安全等级，拥有相同的权限。例如，一个进程可以自由地发送一个Windows消息到另外一个进程的窗口。从Windows Vista开始，当然也包括Windows 7、Windows 10，对于某些Windows消息，这一方式再也行不通了。进程(或者其他的对象)开始拥有一个新的属性——特权等级(Privilege Level)。一个特权等级较低的进程不再可以向一个特权等级较高的进程发送消息，虽然他们在相同的用户权限下运行。这就是所谓的用户界面特权隔离(User Interface Privilege Isolation ，UIPI)。 UIPI的引入，最大的目的是防止恶意代码发送消息给那些拥有较高权限的窗口以对其进行攻击，从而获取较高的权限等等，在计算机系统中，这却是一种维护系统安全的合适方式。 windows服务启动UI程序、对于简单的交互，服务可以通过WTSSendMessage 函数，在用户Session 上显示消息窗口。对于一些复杂的UI 交互，必须调用CreateProcessAsUser 或其他方法（WCF、.NET远程处理等）进行跨Session 通信，在桌面用户上创建一个应用程序界面。 解决思路是：window service创建一个和与当前登陆用户可以交互的进程，这个进程运行在admin权限下，能够调起应用程序的UI 具体的做法是：widow service复制winlogon.exe进程句柄，然后通过调用api函数CreateProcessAsUser（）以winlogon.exe权限创建新进程，新创建的进程有winlogon.exe的权限（winlogon.exe运行在system权限下），负责调用程序。 作者原文： First, we are going to create a Windows Service that runs under the System account. This service will be responsible for spawning an interactive process within the currently active User’s Session. This newly created process will display a UI and run with full admin rights. When the first User logs on to the computer, this service will be started and will be running in Session0; however the process that this service spawns will be running on the desktop of the currently logged on User. We will refer to this service as the LoaderService. Next, the winlogon.exe process is responsible for managing User login and logout procedures. We know that every User who logs on to the computer will have a unique Session ID and a corresponding winlogon.exe process associated with their Session. Now, we mentioned above, the LoaderService runs under the System account. We also confirmed that each winlogon.exe process on the computer runs under the System account. Because the System account is the owner of both the LoaderService and the winlogon.exe processes, our LoaderService can copy the access token (and Session ID) of the winlogon.exe process and then call the Win32 API function CreateProcessAsUser to launch a process into the currently active Session of the logged on User. Since the Session ID located within the access token of the copied winlogon.exe process is greater than 0, we can launch an interactive process using that token. 参考：交互式服务C#开发Windows服务详细流程C#穿透session隔离———Windows服务启动UI交互程序Subverting Vista UAC in Both 32 and 64 bit Architectures 问题windows服务启动winform程序不显示UI问题解决原因：xp系统的用户和window service运行在一个session下，在xp以后，windows系统改变了用户会话管理的策略，window service独立运行在session0下，依次给后续的登录用户分配sessionX(X =1,2,3…)，session0没有权限运行UI。所以在window xp以后的系统下，window service调用有UI的application时只能看到程序进程但不能运行程序的UI。 参考：C# windows服务启动winform程序不显示UI问题解决How can a Windows service execute a GUI application?穿透Session 0 隔离（二）","link":"/2021/07/21/CSharp%E7%A9%BF%E9%80%8Fsession%E9%9A%94%E7%A6%BB%E2%80%94%E2%80%94%E2%80%94Windows%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8UI%E4%BA%A4%E4%BA%92%E7%A8%8B%E5%BA%8F/"},{"title":"CSS选择器","text":"","link":"/2022/06/10/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"},{"name":"live2d","slug":"live2d","link":"/tags/live2d/"},{"name":"emoji","slug":"emoji","link":"/tags/emoji/"},{"name":"记录","slug":"记录","link":"/tags/%E8%AE%B0%E5%BD%95/"},{"name":"软件版本号","slug":"软件版本号","link":"/tags/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7/"},{"name":"ASP.Net MVC","slug":"ASP-Net-MVC","link":"/tags/ASP-Net-MVC/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Mail","slug":"Mail","link":"/tags/Mail/"},{"name":"发送邮件","slug":"发送邮件","link":"/tags/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"name":"ASP.NET","slug":"ASP-NET","link":"/tags/ASP-NET/"},{"name":"System.Net.Mail","slug":"System-Net-Mail","link":"/tags/System-Net-Mail/"},{"name":"邮件发送","slug":"邮件发送","link":"/tags/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"},{"name":"吐槽","slug":"吐槽","link":"/tags/%E5%90%90%E6%A7%BD/"},{"name":"感想","slug":"感想","link":"/tags/%E6%84%9F%E6%83%B3/"},{"name":"负能量","slug":"负能量","link":"/tags/%E8%B4%9F%E8%83%BD%E9%87%8F/"},{"name":"教育","slug":"教育","link":"/tags/%E6%95%99%E8%82%B2/"},{"name":"成长","slug":"成长","link":"/tags/%E6%88%90%E9%95%BF/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Oracle","slug":"Oracle","link":"/tags/Oracle/"},{"name":"Technology","slug":"Technology","link":"/tags/Technology/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"命令行","slug":"命令行","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"Gmail","slug":"Gmail","link":"/tags/Gmail/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"Postman","slug":"Postman","link":"/tags/Postman/"},{"name":"sqlserver","slug":"sqlserver","link":"/tags/sqlserver/"},{"name":"死锁","slug":"死锁","link":"/tags/%E6%AD%BB%E9%94%81/"},{"name":"kettle","slug":"kettle","link":"/tags/kettle/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"SQLlite","slug":"SQLlite","link":"/tags/SQLlite/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"ADO.NET","slug":"ADO-NET","link":"/tags/ADO-NET/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"速查表","slug":"速查表","link":"/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"转载","slug":"转载","link":"/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"v2ray","slug":"v2ray","link":"/tags/v2ray/"},{"name":"shadowsocks","slug":"shadowsocks","link":"/tags/shadowsocks/"},{"name":"vmess","slug":"vmess","link":"/tags/vmess/"},{"name":"css","slug":"css","link":"/tags/css/"}],"categories":[{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"转载","slug":"转载","link":"/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"cranky","slug":"cranky","link":"/categories/cranky/"},{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"VUE","slug":"VUE","link":"/categories/VUE/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"node","slug":"node","link":"/categories/node/"},{"name":"other","slug":"other","link":"/categories/other/"}]}