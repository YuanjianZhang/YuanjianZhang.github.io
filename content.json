{"pages":[{"title":"关于","text":"这是一个用来记录生活为主的Blog,请不要转载。声明：本博客中部分图片、文章来源于网络，版权归原作者所有， 如有侵权请联系删除。Email：selectitemc@gmail.com","link":"/about/index.html"},{"title":"other","text":"","link":"/other/index.html"}],"posts":[{"title":"在hexo文章里使用emoji🤔","text":"记录如何然hexo文章支持emojiHexo 默认的 markdown 渲染引擎不支持将 Github emoji 渲染到静态的 html 页面中，我们换一个支持 emoji 的引擎，再增加一个 emoji 插件即可.","link":"/2019/03/25/%E5%9C%A8hexo%E6%96%87%E7%AB%A0%E9%87%8C%E4%BD%BF%E7%94%A8emoji/"},{"title":"在hexo上添加Live 2D看板娘","text":"博客美化—给Hexo博客添加萌萌的康娜（Kanna） 前言 在逛V站时，看到了一个帖子，然后就被她的看板娘吸引，但是想我也算是有Blog的人(虽然才刚建)，我是不是也可以弄一个呢，说干就干，立马开始捣鼓起来。 过程开始 因为看板娘在WordPress、Typecho、Typecho等用户群体大的博客上应用广泛，所以Live2d 看板娘在WordPress这些博客上能被更好的应用，在网上找的的教程大部分也是关于WordPress等的教程，所以我自己也是懵懵懂懂的去实现这个功能，这篇文章仅记录过程。 经过 在查看下列几篇文章后,开始动手搭建 在Hexo博客上添加可爱的Live 2D模型hexo 添加live2d看板动画 安装模块 hexo博客根目录选择cmd命令窗口或者git bash 输入以下代码，安装插件 1npm install --save hexo-helper-live2d 下载模型1npm install live2d-widget-model-shizuku 配置 打开个人Hexo博客文件根目录下的 _config.yml 文件，在最后添加一下代码 _config.yml12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true再打开cmd键入hexo g -d 就大功告成了😁🎉🎉🎉 DIY资料 资源模型插件:hexo-helper-live2d模型插件作者各种模型包展示hexo模型插件作者各种模型包合集Live2d模型资源：梦象-Live2D 模型资源收集站 适用于WordPress、Typecho、Typecho等强烈推荐：为你的博客博客/网页添加Live2d二次元老婆的插件/手动方法给博客添加能动的看板娘(Live2D)-关于模型的二三事网页添加 Live2D 看板娘","link":"/2019/03/25/%E5%9C%A8hexo%E4%B8%8A%E6%B7%BB%E5%8A%A0Live-2D/"},{"title":"各种软件版本号的含义","text":"今天在逛spring的文档repo时， 常见软件版本编辑软件版本：包含两种不同含义（1）为满足不同用户的不同使用要求，如适用于不同运行环境或不同平台的系列产品。（2）软件产品投入使用以后，经过一段时间运行提出了变更的要求，需要做较大的修正或纠错，增强功能或提高性能。 Alpha版（内部测试版）：Alpha版本通常会送交到开发软件的组织或社群中的各个软件测试者，用作内部测试。在市场上，越来越多公司会邀请外部的客户或合作伙伴参与其软件的Alpha测试阶段。这令软件在此阶段有更大的可用性测试。在测试的第一个阶段中，开发者通常会进行白盒测试。其他测试会在稍后时间由其他测试团体以黑盒或灰盒技术进行，不过有时会同时进行。 Beta版（外部测试版）：软件开发公司为对外宣传，将非正式产品免费发送给具有典型性的用户，让用户测试该软件的不足之处及存在问题，以便在正式发行前进一步改进和完善 。一般可通过Internet免费下载，也可以向软件公司索取。Beta版本是第一个对外公开的软件版本，是由公众参与的测试阶段。一般来说，Beta包含所有功能，但可能有一些已知问题和较轻微的臭虫（Bug）。Beta版本的测试者通常是开发软件的组织的客户，他们会以免费或优惠价钱得到软件，但会成为组织的免费测试者。Beta版本主要测试产品的支援和市场反应（在邀请Beta用户时）等。 Demo版（演示版）：主要是演示正式软件的部分功能，用户可以从中得知软件的基本操作，为正式产品的发售扩大影响。如果是游戏的话，则只有一两个关卡可以玩。该版本也可以从Internet上免费下载。Enhanced版（增强版或加强版）：如果是一般软件，一般称作“增强版”，会加入一些实用的新功能。如果是游戏，一般称作“加强版”，会加入一些新的游戏场景和游戏情节等。这是正式发售的版本。 Free版（自由版）：这一般是个人或自由软件联盟组织的成员制作的软件，希望免费给大家使用，没有版权，一般也是通过Internet免费下载。Full Version版（完全版）：也就是正式版，是最终正式发售的版本。 Shareware版（共享版）：有些公司为了吸引客户，对于他们制作的某些软件，可以让用户通过Internet免费下载的方式获取。不过，此版本软件多会带有一些使用时间或次数的限制，但可以利用在线注册或电子注册成为正式版用户。 Release版（发行版）：稳定的发行版，可从Internet上免费下载。Release Candidate（简称RC）指可能成为最终产品的版本，如果没有再出现问题则可释出正式版本。在此阶段，产品包含所有功能亦不会出现严重问题。通常此阶段的产品是接近完整的。微软公司很多时会使用此名称。在1990年代，苹果电脑把在这阶段的产品称为“Golden Master”，而最后的Golden Master为正式版本。这阶段亦称Gamma（更后期的称为Delta，及其后的希腊字母）。 Upgrade版（升级版）：当你有某个软件以前的正式版本时，可以购买升级版，将你的软件升级为最新版。升级后的软件与正式版在功能上相同，但价格会低些，这主要是为了给原有的正版用户提供优惠。 Retail版 零售版，一般只针对个人的功能不是很全的版本，价格比较低，升级时间也有限制。Cardware版 属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。Plus版 属增强版，不过这种大部分是在程序界面及多媒体功能上增强。Preview版 预览版，软件作者为了满足那些对新版本很关注的人，发布的可以看到大部分功能的测试软件。Corporation &amp; Enterprise版 企业版，只针对企业发布的全功能版本，价格比较昂贵，服务非常齐全。Standard版 标准版，软件商推荐大家使用的版本，这种版本一般比较稳定，BUG少。Mini版 迷你版也叫精简版只有最基本的功能，为那些想节省硬盘空间或者不追求华丽的人准备的。Premium——超值版Professional——专业版Express——简易版（比如Outlook express 和outlook 相比，前者更精简；Sql Server Express版表示免费精简版）Deluxe——豪华版Regged——已注册版CN——简体中文版CHT——繁体中文版EN——英文版Multilanguage——多语言版Rip 是指从原版文件（一般是指光盘或光盘镜像文件）直接将有用的内容（核心内容）分离出来，剔除无用的文档，例如PDF说明文件啊，视频演示啊之类的东西，也可以算做是精简版吧…但主要内容功能是一点也不能缺少的！另：DVDrip是指将视频和音频直接从DVD光盘里以文件方式分离出来。trial 试用版（含有某些限制，如时间、功能，注册后也有可能变为正式版）RC 版 是 Release Candidate 的缩写，意思是发布倒计时，该版本已经完成全部功能并清除大部分的BUG。到了这个阶段只会除BUG，不会对软件做任何大的更改。RTM 版 这基本就是最终的版本，英文是 Release To Manufacture，意思是发布到生产商。版本号编辑V（Version）即版本，通常用数字表示版本号。（如：EVEREST Ultimate v4.20.1188 Beta） Build：用数字或日期标示版本号的一种方式。（如：VeryCD eMule v0.48a Build 071112）SP：Service Pack，升级包。（如：WindowsXP SP2/Vista SP1）授权和功能划分： Trial：试用版，通常都有时间限制，有些试用版软件还在功能上做了一定的限制。可注册或购买成为正式版Unregistered未注册版，通常没有时间限制，在功能上相对于正式版做了一定的限制。可注册或购买成为正式版。Demo：演示版，仅仅集成了正式版中的几个功能，不能升级成正式版。Lite：精简版。Full version：完整版，属于正式版。 语言划分编辑SC：Simplified Chinese简体中文版。CN：简体中文版GBK：简体中文汉字内码扩展规范版。TC：Traditional Chinese繁体中文版。CHT：繁体中文版BIG5：繁体中文大五码版。EN：英文版Multilanguage：多语言版UTF8： Unicode Transformation Format 8 bit，对现有的中文系统不是好的解决方案。 开发阶段划分编辑α（Alpha）版：内测版，内部交流或者专业测试人员测试用。Bug较多，普通用户最好不要安装。β（Beta）版：公测版，专业爱好者大规模测试用，存在一些缺陷，该版本也不适合一般用户安装。γ（Gamma）版：相当成熟的测试版，与即将发行的正式版相差无几。RC版：Release Candidate。RC版。是Release Candidate的缩写，意思是发布倒计时，候选版本，处于Gamma阶段，该版本已经完成全部功能并清除大部分的BUG。到了这个阶段只会除BUG，不会对软件做任何大的更改。从Alpha到Beta再到Gamma是改进的先后关系，但RC1、RC2往往是取舍关系。SR版：Service Release的缩写，修正版或更新版，修正了正式版推出后发现的Bug。Final版：正式版。 其他版本编辑Enhance：增强版或者加强版，属于正式版Free：自由版（免费版）Release：发行版Upgrade：升级版Retail：零售版Cardware：属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。/SPlus：属增强版，不过这种大部分是在程序界面及多媒体功能上增强。Preview：预览版Corporation&amp;Enterprise：企业版Standard：标准版Mini：迷你版也叫精简版只有最基本的功能Professional/pro：专业版Express：特别版Deluxe： 豪华版Regged：已注册版Rip： 是指从原版文件（一般是指光盘或光盘镜像文件）直接将有用的内容（核心内容）分离出来，剔除无用的文档，例如PDF说明文件啊，视频演示啊之类的东西，也可以算做是精简版吧…但主要内容功能是一点也不能缺少的！另：DVDrip是指将视频和音频直接从DVD光盘里以文件方式分离出来。RTM：这基本就是最终的版本，英文是Release To Manufactur，意思是发布到生产商。OEM：Original Equipment Manufacturer，是给电脑生产厂的版本，软件发行商于电脑生产厂家的定制版本。FPP：Full Packaged Product（FPP）/Retail，就是零售版（盒装软件），这种产品的光盘的卷标都带有“FPP”字样，比如英文WXP Pro的FPP版本的光盘卷标就是WXPFPP_EN，其中WX表示是Windows XP，P是Professional（H是Home），FPP表明是零售版本，EN是表明是英语。获得途径除了在商店购买之外，某些MSDN用户也可以得到。VOL：Volume Licensing for Organizations（VLO），团体批量许可证（大量采购授权合约），这是为团体购买而制定的一种优惠方式。这种产品的光盘的卷标都带有“VOL”字样，取“Volume”前3个字母，以表明是批量，比如英文WXP Pro的VOL版本的光盘卷标就是WXPVOL_EN，其中WX表示是Windows XP，P是Professional（VOL没有Home版本），VOL表明是团体批量许可证版本，EN是表明是英语。获得途径主要是集团购买，某些MSDN用户也可以得到。","link":"/2019/03/26/%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/"},{"title":"只是一个普通人","text":"","link":"/2019/04/08/%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E4%BA%BA/"},{"title":"ASP.Net MVC action 同时支持Get和Post","text":"项目中遇到一个action，有post和get请求，特此记录方法：在action 上加上 AcceptVerbs标签: 12[AcceptVerbs(HttpVerbs.Get | HttpVerbs.Post)]public ActionResult Index() 转自：https://blog.csdn.net/Helloantoherday/article/details/85007344","link":"/2019/04/10/ASP-Net-MVC-action-%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81Get%E5%92%8CPost/"},{"title":"C#邮件发送问题","text":"转自：C#邮件发送问题（一）C#邮件发送问题（二）","link":"/2019/04/10/C#%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98/"},{"title":"C# ASP.NET发送电子邮件System.Net.Mail","text":"本文转载自-https://www.cnblogs.com/Jeremy2001/p/6870175.html，侵删。 1.补充知识 （1）POP3和SMTP服务器是什么？ 简单点来说：POP3 用于接收电子邮件 ，SMTP 用于发送电子邮件。 （1）POP3具体指什么？ POP3(Post Office Protocol 3)即邮局协议的第3个版本，它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。它是因特网电子邮件的第一个离线协议标准，POP3协议允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上，同时根据客户端的操作删除或保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。POP3协议是TCP/IP协议族中的一员，,由RFC 1939 定义 （2）SMTP具体是指什么？ SMTP的全称是”Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。 2.System.Net.Mail 使用ASP.NET发送电子邮件，需要引用System.Net.Mail命名空间。System.Net.Mail 命名空间包含用于将电子邮件发送到简单邮件传输协议 (SMTP) 服务器进行传送的类。 （1）命名空间下有三个比较主要的类： MailMessage:提供属性和方法来创建一个邮件消息对象，即邮件内容。 Attachment:提供属性和方法来创建一个邮件附件对象，即邮件附件。 SmtpClient:将电子邮件传输到您指定用于邮件传送的 SMTP 主机。 （2）MailMessage类： From：发送邮件的地址To：接收邮件的地址Subject：邮件的标题Priority：邮件的优先级（分别为为High,Low,Normal）Attachments：电子邮件的数据的附件集合Bcc：密送地址Cc：抄送地址Body：邮件正文SubjectEncoding：电子邮件的主题内容使用的编码 IsBodyHtml：邮件正文是否为 Html 格式的值 详细参考：MailMessage （3）Attachment类： 详细参考：Attachment （4）SmtpClient类： DeliveryMethod：指定如何处理待发的电子邮件 Host：SMTP 事务的主机的名称或 IP 地址 Credentials：设置用于验证发件人身份的凭据 详细参考：SmtpClient 3.ASP.NET发送邮件两种方式 （1）通过邮件服务提供商的SMTP来发送邮件 首先需要注册对应服务提供商免费邮箱，因为你要使用邮件服务提供商的SMTP，他们需要对身份进行验证，这样可以避免产生大量的垃圾邮件。 有三个是重要的信息：SMTP服务器、用户名、密码。从网上收集了几个类，可以参考下。 123456789101112131415161718192021222324252627282930313233343536373839#region/// &lt;summary&gt;/// 发送邮件/// &lt;/summary&gt;/// &lt;param name=\"mailTo\"&gt;要发送的邮箱&lt;/param&gt;/// &lt;param name=\"mailSubject\"&gt;邮箱主题&lt;/param&gt;/// &lt;param name=\"mailContent\"&gt;邮箱内容&lt;/param&gt;/// &lt;returns&gt;返回发送邮箱的结果&lt;/returns&gt;public static bool SendEmail(string mailTo,string mailSubject,string mailContent){ // 设置发送方的邮件信息,例如使用网易的smtp string smtpServer = \"smtp.163.com\"; //SMTP服务器 string mailFrom = \"XXX@163.com\"; //登陆用户名 string userPassword = \"XXX\";//登陆密码 // 邮件服务设置 SmtpClient smtpClient=new SmtpClient(); smtpClient.DeliveryMethod = SmtpDeliveryMethod.Network;//指定电子邮件发送方式 smtpClient.Host = smtpServer; //指定SMTP服务器 smtpClient.Credentials = new System.Net.NetworkCredential(mailFrom, userPassword);//用户名和密码 // 发送邮件设置 MailMessage mailMessage = new MailMessage(mailFrom, mailTo); // 发送人和收件人 mailMessage.Subject = mailSubject;//主题 mailMessage.Body = mailContent;//内容 mailMessage.BodyEncoding = Encoding.UTF8;//正文编码 mailMessage.IsBodyHtml = true;//设置为HTML格式 mailMessage.Priority = MailPriority.Low;//优先级 try { smtpClient.Send(mailMessage); // 发送邮件 return true; } catch (SmtpException ex) { return false; }}2）利用本机的SMTP虚拟服务器的SMTP来发送邮件 需要进行SMTP配置，还是第一种简单实用。 4.参考资料：常用邮件服务器 gmail.com:POP3服务器地址:pop.gmail.comSMTP服务器地址:smtp.gmail.com qq.com: POP3服务器地址:pop.qq.comSMTP服务器地址:smtp.qq.com 163.com:POP3服务器地址:pop.163.comSMTP服务器地址:smtp.163.com sina.com: POP3服务器地址:pop3.sina.com.cnSMTP服务器地址:smtp.sina.com.cn yahoo.com:POP3服务器地址:pop.mail.yahoo.comSMTP服务器地址:smtp.mail.yahoo.com sohu.com:POP3服务器地址:pop3.sohu.comSMTP服务器地址:smtp.sohu.com china.com:POP3服务器地址:pop.china.comSMTP服务器地址:smtp.china.com 21cn.com:POP3服务器地址:pop.21cn.comSMTP服务器地址:smtp.21cn.com sina.com: 实例下载","link":"/2019/04/11/C#-ASP.NET%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6System.Net.Mail/"},{"title":"突发奇想：对于人类进化的优胜劣汰","text":"最近实习越来越发现自己","link":"/2019/04/16/%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%EF%BC%9A%E5%AF%B9%E4%BA%8E%E4%BA%BA%E7%B1%BB%E8%BF%9B%E5%8C%96%E7%9A%84%E4%BC%98%E8%83%9C%E5%8A%A3%E6%B1%B0/"},{"title":"彻底清除Github上某个文件的历史（对于误传密码等隐私信息等情况）","text":"Removing sensitive data from a repository","link":"/2019/04/26/%E5%BD%BB%E5%BA%95%E6%B8%85%E9%99%A4Github%E4%B8%8A%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%88%E5%AF%B9%E4%BA%8E%E8%AF%AF%E4%BC%A0%E5%AF%86%E7%A0%81%E7%AD%89%E9%9A%90%E7%A7%81%E4%BF%A1%E6%81%AF%E7%AD%89%E6%83%85%E5%86%B5%EF%BC%89/"},{"title":"Asp.net MVC在Razor中输出Html的两种方式","text":"Razor中所有的Html都会自动编码，这样就不需要我们手动去编码了（安全），但在需要输出Html时就是已经转义过的Html文本了，如下所示： 1234@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\";}@thisTest; 这样在页面输出的文本就是：&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;而不是红色的字体了，要输出红色的字体，有下面常用的两种方式： 1、使用Razor中的Html.Raw（推荐使用这种方式）： 1234@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\";}@Html.Raw(thisTest); 2、使用MvcHtmlString类来实现： 12345@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\"; var thisResult = new MvcHtmlString(thisTest);}@thisResult 或 @(new HtmlString(thisTest))","link":"/2019/05/07/Asp-net-MVC%E5%9C%A8Razor%E4%B8%AD%E8%BE%93%E5%87%BAHtml%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"jQuery的Ajax的dataType设置问题","text":"在Asp.Net MVC的前台页面使用Ajax获取数据，当Ajax方法中设置了dataType: \"json\"后，Ajax无法使用data.ret的方式处理数据。Controller.Json Method (Object)Json(Object) 方法返回的是继承自System.Object的类型值System.Web.Mvc.JsonResult在前台获取到的是object，而不是json字符串 http://www.cnblogs.com/zhangcybb/p/6604380.htmlhttps://docs.microsoft.com/en-us/previous-versions/aspnet/dd504936%28v%3dvs.100%29#see-alsohttps://docs.microsoft.com/en-us/previous-versions/aspnet/dd504936%28v%3dvs.100%29https://docs.microsoft.com/zh-cn/previous-versions/aspnet/dd470569%28v%3dvs.100%29https://www.cnblogs.com/fire-dragon/p/5889400.html","link":"/2019/05/09/jQuery%E7%9A%84Ajax%E7%9A%84dataType%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"},{"title":"SQL语句使用技巧","text":"记录一下自己在使用PL/SQL的编写SQL语句的注意点和技巧 记录工作中遇到的在统计一张数据表中一个数据类型为Char(2) 的字段的值为空的数量时，使用 `select count(1) from table1 where EHR_PAT_GEN = ''`，查询出的结果为0（数据库中数据已经确认有空的）。 然后将语句换成`select count(1) from table1 where EHR_PAT_GEN &lt;&gt; ''`执行后，结果仍然为0，然后查询数据表，发现不为空的的数据为数字时，使用`select count(1) from table1 where EHR_PAT_GEN &gt; 0`查出该字段不为空的数据量。然后百度到char类型是","link":"/2019/05/20/SQL%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"对当今教育的一些感想","text":"今天是2019年5月24日，工作了一段时间后，逐渐发现","link":"/2019/05/24/%E5%AF%B9%E5%BD%93%E4%BB%8A%E6%95%99%E8%82%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/"},{"title":"'nginx缓存页面+cookie后-串会话问题'","text":"https://blog.csdn.net/clevercode/article/details/75145258","link":"/2019/05/31/nginx%E7%BC%93%E5%AD%98%E9%A1%B5%E9%9D%A2-cookie%E5%90%8E-%E4%B8%B2%E4%BC%9A%E8%AF%9D%E9%97%AE%E9%A2%98/"},{"title":"终究还是毕业了","text":"","link":"/2019/06/05/%E7%BB%88%E7%A9%B6%E8%BF%98%E6%98%AF%E6%AF%95%E4%B8%9A%E4%BA%86/"},{"title":"hexo指令列表","text":"为了方便使用hexo，将一些hexo指令记录下来 hexo指令 hexo 提示 hexo 官方文档 Hexo起步安装（-g为全局安装） 1npm install hexo -g 升级（-g为全局升级） 1npm update hexo -g 初始化，生成文件夹为blog 1hexo init blog 安装依赖库 1npm install 简写hexo n \"我的博客\"== hexo new \"我的博客\" #新建文章hexo p== hexo publish #将草稿帖子从_drafts移动到_posts文件夹。hexo g== hexo generate#生成hexo s== hexo server #启动服务预览hexo d == hexo deploy#部署hexo s -g == hexo server --generate#生成静态页面并启动服务预览 生成静态网页后部署到GitHub上 两个命令的作用是相同的hexo g -d == hexo generate --deployhexo d -g == hexo deploy --generate 模板hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate --watch #监视文件变动 hexo提示在CMD中输入hexo help后，获得的命令行列表 1234567891011121314151617181920212223用法: hexo &lt;command&gt;Commands: clean 删除生成的文件和缓存。 config 获取或设置配置 deploy 部署你的网站。 可简写成 `hexo d` generate 生成静态文件。 可简写成 `hexo g` help 获取有关命令的帮助。 init 创建一个新的Hexo文件夹。 list 列出网站的信息 migrate 将您的站点从其他系统迁移到Hexo。 new 创建一个新帖子。 可简写成 `hexo n` publish 将草稿帖子从_drafts移动到_posts文件夹。 render 使用渲染器插件渲染文件。 server 启动服务器。 可简写成 `hexo s` version 显示版本信息。全局选项: --config 指定配置文件而不是使用_config.yml --cwd 指定CWD --debug 显示终端中的所有详细消息 --draft 显示草稿帖子 --safe 禁用所有插件和脚本 --silent 隐藏控制台上的输出 官方文档的一些指令init1hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new1hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1hexo new \"post title with whitespace\" generate1hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 该命令可以简写为 1hexo g publish1hexo publish [layout] &lt;filename&gt; 发表草稿。 server1hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 deploy1hexo deploy 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 该命令可以简写为： 1hexo d render1hexo render &lt;file1&gt; [file2] ... 渲染文件。 参数 描述 -o, --output 设置输出路径 migrate1hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1hexo list &lt;type&gt; 列出网站资料。 version1hexo version 显示 Hexo 版本。 选项安全模式1hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式1hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式1hexo --silent 隐藏终端信息。 自定义配置文件的路径1hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿1hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD1hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。","link":"/2019/06/12/hexo%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A8/"},{"title":"a标签的target的用法","text":"记录一下今天在学习项目时遇到的一个低级问题🙃 HTML&lt;a&gt;标签的target属性 参考地址：http://www.w3school.com.cn/tags/att_a_target.asp 定义和用法&lt;a&gt; 标签的 target 属性规定在何处打开链接文档。 如果在一个 &lt;a&gt; 标签内包含一个 target 属性，浏览器将会载入和显示用这个标签的 href 属性命名的、名称与这个目标吻合的框架或者窗口中的文档。如果这个指定名称或 id 的框架或者窗口不存在，浏览器将打开一个新的窗口，给这个窗口一个指定的标记，然后将新的文档载入那个窗口。从此以后，超链接文档就可以指向这个新的窗口。 打开新窗口 被指向的超链接使得创建高效的浏览工具变得很容易。例如，一个简单的内容文档的列表，可以将文档重定向到一个单独的窗口： 12&lt;a href=\"https://www.bing.com\" target=\"view_window\"&gt;打开一个新的窗口，显示必应的首页HTML文档&lt;/a&gt;&lt;a href=\"https://www.baidu.com\" target=\"view_window\"&gt;在已经打开的窗口上，将必应的文档取代。显示百度的首页HTML文档&lt;/a&gt; 打开一个新的窗口，指向必应的新窗口 在已经打开的窗口上，将必应的文档取代。显示百度的首页HTML文档 当用户第一次选择内容列表中的某个链接时，浏览器将打开一个新的窗口，将它标记为 “view_window”，然后在其中显示希望显示的文档内容。如果用户从这个内容列表中选择另一个链接，且这个 “view_window” 仍处于打开状态，浏览器就会再次将选定的文档载入那个窗口，取代刚才的那些文档。 在整个过程中，这个包含了内容列表的窗口是用户可以访问的。通过单击窗口中的一个连接，可使另一个窗口的内容发生变化。 在框架中打开窗口不用打开一个完整的浏览器窗口，使用 target 更通常的方法是在一个 &lt;frameset&gt; 显示中将超链接内容定向到一个或者多个框架中。可以将这个内容列表放入一个带有两个框架的文档的其中一个框架中，并用这个相邻的框架来显示选定的文档： 12&lt;frame name=\"view\" src=\"\"&gt;&lt;a href=\"https://bing.com\" target=\"view\"&gt;在右边窗口打开必应首页&lt;/a&gt; 在右边窗口打开必应首页在右边窗口打开一张图片 语法1&lt;a target=&quot;value&quot;&gt; 属性值 值 描述 _blank 在新窗口中打开被链接文档。 _self 默认。在相同的框架中打开被链接文档。 _parent 在父框架集中打开被链接文档。 _top 在整个窗口中打开被链接文档。 framename 在指定的框架中打开被链接文档。 特殊的目标有 4 个保留的目标名称用作特殊的文档重定向操作： _blank浏览器总在一个新打开、未命名的窗口中载入目标文档。 _self这个目标的值对所有没有指定目标的 &lt;a&gt; 标签是默认目标，它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的，除非和文档标题 &lt;base&gt; 标签中的 target 属性一起使用。 _parent这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。 _top这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。 提示：这些 target 的所有 4 个值都以下划线开始。任何其他用一个下划线作为开头的窗口或者目标都会被浏览器忽略，因此，不要将下划线作为文档中定义的任何框架 name 或 id 的第一个字符。","link":"/2019/06/24/a%E6%A0%87%E7%AD%BE%E7%9A%84target%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"在Gmail地址上填个加号","text":"本文转载自：在Gmail地址上填个加号 在Gmail地址上填个加号 我在使用Gmail邮箱时，还有一个很好的功能经常用到，那就是给电子邮件地址填上“+”。给别人发邮件的时候，在自己Gmail邮箱地址上添加一个“+”，这种方法可以自动过滤掉那些未必是垃圾邮件却由于来自不同的邮箱而难以过滤的电子邮件。 考虑一下网上购物时的情况。你买东西的每一个网站都想留下你的电子邮件地址，以便给你发送货款收据、送货通知之类信息。不过可以肯定，它们也会利用你提供的邮件地址向你发送打折票券、促销信息之类内容，甚至发送垃圾邮件。由于来自这些网站的邮件可能包含有关你购买产品的重要信息，因此把这些网站加入垃圾邮件的黑名单并不是一个好的解决办法。此外，这些邮件可能来自多个邮箱（当然都出自同一个网站），因而难以事先预知，也不容易设置过滤条件。另一方面，你又不愿意让电子商务网站发送的垃圾邮件充斥自己的邮箱。 在这种情况下，你可以有别的选择。你可以针对每一个购物公司创建一个电子邮箱。这个办法效率不高，容易造成混乱，而且也会占用别人想用的邮箱地址。其实你不必这么办，只要在Gmail邮箱地址后面填个加号就可以了。 操作要领如下：如果你的Gmail邮箱地址是yourname@gmail.com，提供给购物网站的邮箱就可以是yourname+shopping@gmail.com，无须开设新的电子邮箱。 接下来，你可以设置过滤条件，把所有发向yourname+shopping@gmail.com的邮件自动存档。通过这种操作，所有来自电子商务网站的邮件会自动从当前收件箱中转移出去，成为Gmail邮箱里的历史邮件。结果，那些邮件就不会分散你的注意力，也不会让你恼怒，因为眼不见心不烦。然而，当你搜索邮件或者查看收件箱的时候，这些邮件都还在。另一个办法是，你可以给所有发向yourname+shopping@gmail.com的邮件自动加上诸如“购物”之类的标签。然后可以根据需要，对与电子商务活动有关的邮件进行查看或归类。 所有这些办法的关键是什么呢？对于你想看或不想看的邮件，这是一种简单易行的自动化组织方式。“+”是一个自动过滤器，马上就能作用于所有的网上购物邮件，需要你做的不过是设置一下而已。","link":"/2019/06/25/%E5%9C%A8Gmail%E5%9C%B0%E5%9D%80%E4%B8%8A%E5%A1%AB%E4%B8%AA%E5%8A%A0%E5%8F%B7/"},{"title":"XML文档笔记（一）","text":"转载自： https://www.cnblogs.com/catgatp/p/6403382.html &lt;![CDATA[]]&gt;和转义字符被&lt;![CDATA[]]&gt;这个标记所包含的内容将表示为纯文本，比如&lt;![CDATA[&lt;]]&gt;表示文本内容“&lt;”。 此标记用于xml文档中，我们先来看看使用转义符的情况。我们知道，在xml中，”&lt;”、”&gt;”、”&amp;”等字符是不能直接存入的，否则xml语法检查时会报错，如果想在xml中使用这些符号，必须将其转义为实体，如”&lt;”、”&gt;”、”&amp;”，这样才能保存进xml文档。 在使用程序读取的时候，解析器会自动将这些实体转换回”&lt;”、”&gt;”、”&amp;”。举个例子： &lt;age&gt; age &lt; 30 &lt;/age&gt; 上面这种写法会报错，应该这样写： &lt;age&gt; age&amp;lt;30 &lt;/age&gt; 值得注意的是： (1)转义序列字符之间不能有空格； (2) 转义序列必须以”;”结束； (3) 单独出现的”&amp;”不会被认为是转义的开始； (4) 区分大小写。 在XML中，需要转义的字符有： (1)&amp; &amp;amp; (2)&lt; &amp;lt; (3)&gt; &amp;gt; (4)＂ &amp;quot; (5)＇ &amp;apos; 但是严格来说，在XML中只有”&lt;”和”&amp;”是非法的，其它三个都是可以合法存在的，但是，把它们都进行转义是一个好的习惯。 不管怎么样，转义前的字符也好，转义后的字符也好，都会被xml解析器解析，为了方便起见，使用&lt;![CDATA[]]&gt;来包含不被xml解析器解析的内容。但要注意的是： (1) 此部分不能再包含”]]&gt;”； (2) 不允许嵌套使用； (3)”]]&gt;”这部分不能包含空格或者换行。 最后，说说&lt;![CDATA[]]&gt;和xml转移字符的关系，它们两个看起来是不是感觉功能重复了？ 是的，它们的功能就是一样的，只是应用场景和需求有些不同： (1)&lt;![CDATA[]]&gt;不能适用所有情况，转义字符可以； (2) 对于短字符串&lt;![CDATA[]]&gt;写起来啰嗦，对于长字符串转义字符写起来可读性差； (3) &lt;![CDATA[]]&gt;表示xml解析器忽略解析，所以更快。","link":"/2019/07/02/XML%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"使用Postman测试SOAP接口","text":"使用Postman发出SOAP请求我们知道它说的是Postman“REST”客户端，但这并不意味着我们不能将其用于发出SOAP请求。通过执行以下简单步骤，可以轻松地使用Postman发出任何HTTP SOAP请求： 链接地址Making SOAP requests using PostmanPostman makes SOAP requests too","link":"/2019/10/25/%E4%BD%BF%E7%94%A8Postman%E6%B5%8B%E8%AF%95SOAP%E6%8E%A5%E5%8F%A3/"},{"title":"为什么一到毕业就要经历生离死别","text":"","link":"/2019/07/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%88%B0%E6%AF%95%E4%B8%9A%E5%B0%B1%E8%A6%81%E7%BB%8F%E5%8E%86%E7%94%9F%E7%A6%BB%E6%AD%BB%E5%88%AB/"},{"title":"sqlserver查询使用with(nolock)","text":"sqlserver中，一张表会因为频繁的进行select、delete、insert操作而导致死锁。 记录一次数据库死锁在自己负责的一个业务中，有一张表因为会进行频繁的select、delete、insert。导致报了死锁的错：检验结果存储失败：事务(进程 ID 56)与另一个进程被死锁在 锁 | 通信缓冲区 资源上，并且已被选作死锁牺牲品。请重新运行该事务。SQL:delete LIS_RESULT_CG where JYLSH=’************’ 参考文章 select死锁问题sqlserver查询使用with(nolock)详解WITH(NOLOCK)与WITH(READPAST)共享锁（S锁）和排它锁（X锁）SQL SERVER SELECT语句中加锁选项的详细说明","link":"/2019/11/18/sqlserver%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8with-nolock/"},{"title":"前台加密3DES-C#后台解密","text":"js的3des加解密和c#.net后台解密 Des-3DesDemo C# 3Des加密解密 前台使用cryptojs加密解密时，一定要注意。方法会自动处理key，以凑齐24位。（key不足24位自动以0(最小位数是0)补齐,如果多余24位,则截取前24位,后面多余则舍弃掉） 但C#生成是是允许使用16位字符和24位字符加密的。具体参考：3DES将16位秘钥升级为24位 按3DES规范要求，的确其秘钥应该是24位而不是16位的，但16位秘钥可以按 前8位+后8位+前8位 的规则来升级成24位的秘钥。所以C#的key实际上也是24位，它将16位的key转换成了24位。服了，真是个大坑","link":"/2019/12/05/%E5%89%8D%E5%8F%B0%E5%8A%A0%E5%AF%863DES-C#%E5%90%8E%E5%8F%B0%E8%A7%A3%E5%AF%86/"},{"title":"关于json.stringfy不兼容ie8操作","text":"IE低版本 JSON.parse 和stringify 的兼容 （IE8以下）解决IE8以下低版本实现JSON.parse()与JSON.stringify()的兼容关于 json.stringfy不兼容ie8操作","link":"/2019/12/10/%E5%85%B3%E4%BA%8Ejson-stringfy%E4%B8%8D%E5%85%BC%E5%AE%B9ie8%E6%93%8D%E4%BD%9C/"},{"title":"SQL语句中的N'xxxx'是什么意思","text":"https://www.cnblogs.com/wanshutao/p/4128016.html","link":"/2020/06/01/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84N-xxxx-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"},{"title":"最近感受到的压力","text":"","link":"/2020/09/10/%E6%9C%80%E8%BF%91%E6%84%9F%E5%8F%97%E5%88%B0%E7%9A%84%E5%8E%8B%E5%8A%9B/"},{"title":"拖延症的改善(一)","text":"拖延症在意识到拖延症已经严重影响到了生活后，我开始尝试改善这个十几年的毛病。 养成一个小习惯改善拖延症，尝试过制定每天的行程，通过闹钟严格控制自己。刚开始的时候确实有成效，但都坚持不了几周，自己慢慢失去动力。这种方式的中，人是被动的。 健身 拖延一个很简单只需要花费几分钟的动作，在坚持一到两天就能看到效果，或者感受到效果。这会给与我一个很强大的正反馈。付出和收获反馈很及时，这会在一定程度上，促使我主动去做，以为在我潜意识里只要我今天做了这个动作，我明天身体的某块地方就会改变，并且能被我感受到，捕捉到这个变化，一个很健康的正反馈循环会是我转守为攻，自己会监督自己去每天做这个动作。它在很大程度上改善了我的拖延。 这样的习惯养成后，能改善我自身的思维和心态。它会促使我潜意识觉得，每天坚持做一些事情，是会有益与我的，自身能接受的付出和收获的间隔长度也会慢慢变长。 健身改善了我的生活。 [EOF]","link":"/2020/08/07/%E6%8B%96%E5%BB%B6%E7%97%87%E7%9A%84%E6%94%B9%E5%96%84-%E4%B8%80/"},{"title":"转载—数据库锁的概念","text":"锁的概述一. 为什么要引入锁多个用户同时对数据库的并发操作时会带来以下数据不一致的问题: 丢失更新A,B两个用户读同一数据并进行修改,其中一个用户的修改结果破坏了另一个修改的结果,比如订票系统 脏读A用户修改了数据,随后B用户又读出该数据,但A用户因为某些原因取消了对数据的修改,数据恢复原值,此时B得到的数据就与数据库内的数据产生了不一致 不可重复读A用户读取数据,随后B用户读出该数据并修改,此时A用户再读取数据时发现前后两次的值不一致 并发控制的主要方法是封锁,锁就是在一段时间内禁止用户做某些操作以避免产生数据不一致 二 锁的分类锁的类别有两种分法： 从数据库系统的角度来看：分为独占锁（即排它锁），共享锁和更新锁 MS-SQL Server 使用以下资源锁模式。 锁模式描述:共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。更新 (U) 用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。排它 (X) 用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。意向锁 用于建立锁的层次结构。意向锁的类型为：意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。架构锁 在执行依赖于表架构的操作时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)。大容量更新 (BU) 向表中大容量复制数据并指定了 TABLOCK 提示时使用。共享锁共享 (S) 锁允许并发事务读取 (SELECT) 一个资源。资源上存在共享 (S) 锁时，任何其它事务都不能修改数据。一旦已经读取数据，便立即释放资源上的共享 (S) 锁，除非将事务隔离级别设置为可重复读或更高级别，或者在事务生存周期内用锁定提示保留共享 (S) 锁。 更新锁更新 (U) 锁可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享 (S) 锁，然后修改行，此操作要求锁转换为排它 (X) 锁。如果两个事务获得了资源上的共享模式锁，然后试图同时更新数据，则一个事务尝试将锁转换为排它 (X) 锁。共享模式到排它锁的转换必须等待一段时间，因为一个事务的排它锁与其它事务的共享模式锁不兼容；发生锁等待。第二个事务试图获取排它 (X) 锁以进行更新。由于两个事务都要转换为排它 (X) 锁，并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。 若要避免这种潜在的死锁问题，请使用更新 (U) 锁。一次只有一个事务可以获得资源的更新 (U) 锁。如果事务修改资源，则更新 (U) 锁转换为排它 (X) 锁。否则，锁转换为共享锁。 排它锁排它 (X) 锁可以防止并发事务对资源进行访问。其它事务不能读取或修改排它 (X) 锁锁定的数据。 意向锁意向锁表示 SQL Server 需要在层次结构中的某些底层资源上获取共享 (S) 锁或排它 (X) 锁。例如，放置在表级的共享意向锁表示事务打算在表中的页或行上放置共享 (S) 锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它 (X) 锁。意向锁可以提高性能，因为 SQL Server 仅在表级检查意向锁来确定事务是否可以安全地获取该表上的锁。而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。 意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。 锁模式 描述意向共享 (IS) 通过在各资源上放置 S 锁，表明事务的意向是读取层次结构中的部分（而不是全部）底层资源。意向排它 (IX) 通过在各资源上放置 X 锁，表明事务的意向是修改层次结构中的部分（而不是全部）底层资源。IX 是 IS 的超集。与意向排它共享 (SIX) 通过在各资源上放置 IX 锁，表明事务的意向是读取层次结构中的全部底层资源并修改部分（而不是全部）底层资源。允许顶层资源上的并发 IS 锁。例如，表的 SIX 锁在表上放置一个 SIX 锁（允许并发 IS 锁），在当前所修改页上放置 IX 锁（在已修改行上放置 X 锁）。虽然每个资源在一段时间内只能有一个 SIX 锁，以防止其它事务对资源进行更新，但是其它事务可以通过获取表级的 IS 锁来读取层次结构中的底层资源。 独占锁：只允许进行锁定操作的程序使用，其他任何对他的操作均不会被接受。执行数据更新命令时，SQL Server会自动使用独占锁。当对象上有其他锁存在时，无法对其加独占锁。共享锁：共享锁锁定的资源可以被其他用户读取，但其他用户无法修改它，在执行Select时，SQL Server会对对象加共享锁。更新锁：当SQL Server准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到SQL Server确定要进行更新数据操作时，他会自动将更新锁换为独占锁，当对象上有其他锁存在时，无法对其加更新锁。 从程序员的角度看：分为乐观锁和悲观锁。乐观锁：完全依靠数据库来管理锁的工作。悲观锁：程序员自己管理数据或对象上的锁处理。 MS-SQLSERVER 使用锁在多个同时在数据库内执行修改的用户间实现悲观并发控制 三 锁的粒度锁粒度是被封锁目标的大小,封锁粒度小则并发性高,但开销大,封锁粒度大则并发性低但开销小 SQL Server支持的锁粒度可以分为为行、页、键、键范围、索引、表或数据库获取锁 资源 描述RID 行标识符。用于单独锁定表中的一行。键 索引中的行锁。用于保护可串行事务中的键范围。页 8 千字节 (KB) 的数据页或索引页。扩展盘区 相邻的八个数据页或索引页构成的一组。表 包括所有数据和索引在内的整个表。DB 数据库。 四 锁定时间的长短锁保持的时间长度为保护所请求级别上的资源所需的时间长度。 用于保护读取操作的共享锁的保持时间取决于事务隔离级别。采用 READ COMMITTED 的默认事务隔离级别时，只在读取页的期间内控制共享锁。在扫描中，直到在扫描内的下一页上获取锁时才释放锁。如果指定 HOLDLOCK 提示或者将事务隔离级别设置为 REPEATABLE READ 或 SERIALIZABLE，则直到事务结束才释放锁。 根据为游标设置的并发选项，游标可以获取共享模式的滚动锁以保护提取。当需要滚动锁时，直到下一次提取或关闭游标（以先发生者为准）时才释放滚动锁。但是，如果指定 HOLDLOCK，则直到事务结束才释放滚动锁。 用于保护更新的排它锁将直到事务结束才释放。如果一个连接试图获取一个锁，而该锁与另一个连接所控制的锁冲突，则试图获取锁的连接将一直阻塞到： 将冲突锁释放而且连接获取了所请求的锁。 连接的超时间隔已到期。默认情况下没有超时间隔，但是一些应用程序设置超时间隔以防止无限期等待 五 SQL Server 中锁的自定义1 处理死锁和设置死锁优先级 死锁就是多个用户申请不同封锁,由于申请者均拥有一部分封锁权而又等待其他用户拥有的部分封锁而引起的无休止的等待 可以使用SET DEADLOCK_PRIORITY控制在发生死锁情况时会话的反应方式。如果两个进程都锁定数据，并且直到其它进程释放自己的锁时，每个进程才能释放自己的锁，即发生死锁情况。 2 处理超时和设置锁超时持续时间。 @@LOCK_TIMEOUT 返回当前会话的当前锁超时设置，单位为毫秒 SET LOCK_TIMEOUT 设置允许应用程序设置语句等待阻塞资源的最长时间。当语句等待的时间大于 LOCK_TIMEOUT 设置时，系统将自动取消阻塞的语句，并给应用程序返回”已超过了锁请求超时时段”的 1222 号错误信息 示例下例将锁超时期限设置为 1,800 毫秒。SET LOCK_TIMEOUT 1800 设置事务隔离级别。 4 ) 对 SELECT、INSERT、UPDATE 和 DELETE 语句使用表级锁定提示。 配置索引的锁定粒度可以使用 sp_indexoption 系统存储过程来设置用于索引的锁定粒度 六 查看锁的信息1 执行 EXEC SP_LOCK 报告有关锁的信息2 查询分析器中按Ctrl+2可以看到锁的信息 七 使用注意事项如何避免死锁1 使用事务时，尽量缩短事务的逻辑处理过程，及早提交或回滚事务；2 设置死锁超时参数为合理范围，如：3分钟-10分种；超过时间，自动放弃本次操作，避免进程悬挂；3 优化程序，检查并避免死锁现象出现；4 .对所有的脚本和SP都要仔细测试，在正是版本之前。5 所有的SP都要有错误处理（通过@error）6 一般不要修改SQL SERVER事务的默认级别。不推荐强行加锁 解决问题 如何对行 表 数据库加锁 八 几个有关锁的问题1 如何锁一个表的某一行 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED SELECT * FROM table ROWLOCK WHERE id = 1 2 锁定数据库的一个表 SELECT * FROM table WITH (HOLDLOCK) 加锁语句：sybase:update 表 set col1=col1 where 1=0 ;MSSQL:select col1 from 表 (tablockx) where 1=0 ;oracle:LOCK TABLE 表 IN EXCLUSIVE MODE ；加锁后其它人不可操作，直到加锁用户解锁，用commit或rollback解锁 几个例子帮助大家加深印象设table1(A,B,C)A B Ca1 b1 c1a2 b2 c2a3 b3 c3 1）排它锁新建两个连接在第一个连接中执行以下语句begin tranupdate table1set A=’aa’where B=’b2’waitfor delay ‘00:00:30’ –等待30秒commit tran在第二个连接中执行以下语句 1234begin tran select * from table1 where B='b2' commit tran 若同时执行上述两个语句，则select查询必须等待update执行完毕才能执行即要等待30秒 2）共享锁在第一个连接中执行以下语句 12345begin tran select * from table1 holdlock -holdlock人为加锁 where B='b2' waitfor delay '00:00:30' --等待30秒 commit tran 在第二个连接中执行以下语句 1234567begin tran select A,C from table1 where B='b2' update table1 set A='aa' where B='b2' commit tran 若同时执行上述两个语句，则第二个连接中的select查询可以执行而update必须等待第一个事务释放共享锁转为排它锁后才能执行 即要等待30秒 3）死锁 1234增设table2(D,E) D E d1 e1 d2 e2 在第一个连接中执行以下语句 123456789begin tran update table1 set A='aa' where B='b2' waitfor delay '00:00:30' update table2 set D='d5' where E='e1' commit tran 在第二个连接中执行以下语句 123456789begin tran update table2 set D='d5' where E='e1' waitfor delay '00:00:10' update table1 set A='aa' where B='b2' commit tran 同时执行，系统会检测出死锁，并中止进程 补充一点:Sql Server2000支持的表级锁定提示 HOLDLOCK 持有共享锁，直到整个事务完成，应该在被锁对象不需要时立即释放，等于SERIALIZABLE事务隔离级别 NOLOCK 语句执行时不发出共享锁，允许脏读 ，等于 READ UNCOMMITTED事务隔离级别 PAGLOCK 在使用一个表锁的地方用多个页锁 READPAST 让sql server跳过任何锁定行，执行事务，适用于READ UNCOMMITTED事务隔离级别只跳过RID锁，不跳过页，区域和表锁 ROWLOCK 强制使用行锁 TABLOCKX 强制使用独占表级锁，这个锁在事务期间阻止任何其他事务使用这个表 UPLOCK 强制在读表时使用更新而不用共享锁 应用程序锁:应用程序锁就是客户端代码生成的锁，而不是sql server本身生成的锁 处理应用程序锁的两个过程 sp_getapplock 锁定应用程序资源 sp_releaseapplock 为应用程序资源解锁 注意: 锁定数据库的一个表的区别 123SELECT * FROM table WITH (HOLDLOCK) 其他事务可以读取表，但不能更新删除 SELECT * FROM table WITH (TABLOCKX) 其他事务不能读取表,更新和删除","link":"/2020/11/27/%E8%BD%AC%E8%BD%BD%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5/"},{"title":"CMD start command","text":"by SRINI Start command可用于在另一个命令窗口中运行command/batch（批处理文件）或从命令行启动应用程序。您可以在下面找到该命令的语法和一些示例。 启动另一个命令窗口： 1start cmd 该命令将打开一个新的命令提示符窗口。 在单独的窗口中运行命令 1Start command 该命令将打开一个新的命令窗口，并运行指定的命令。如果命令是GUI应用程序，则将在没有任何新命令窗口的情况下启动该应用程序。 例子：启动新的命令窗口并运行dir命令： 1Start dir 在另一个窗口中运行命令，并在命令执行后终止： 1234567start cmd /c command````例如，要在另一个命令窗口中运行批处理文件并在批处理文件执行完成后关闭该窗口，命令将为：``` CMDStart cmd /c C:\\mybatchfile.bat 在同一窗口中运行命令： 1Start /b command 像在Linux中使用”&amp;”一样，在后台运行命令： 在Windows中，我们可以使用start命令执行类似的操作。但是在这里它不是在后台运行的。一个新的命令窗口将执行指定的命令，而当前窗口将返回以提示执行下一个命令。 123Start command(or)Start batchfile.bat 启动GUI应用程序： 1Start application 例如，要启动Chrome，我们可以使用以下命令: 1Start Chrome 在当前目录中打开Windows资源管理器：: 1start .","link":"/2021/05/07/CMD-Start-Command/"},{"title":"2020人口普查随笔","text":"男女比例的不平衡，以及人口出生率的降低，感觉一定程度上可以使用进化论的来解释。从古至今，人类都存在淘汰，野人时期，身体素质不够高，打不到足够的猎物就是饿死，到了封建时期，第一看投胎，第二就看自己够不够努力（只看生存能力,坑蒙拐骗也算本领）。而到了现在也是如此，第一看投胎，第二看自身。自古如此，人类的基因也在随着时间的变化而被筛选，更能适应社会的，能够获取到异性的注意力的人，他们的基因将会更好的流传下去，而一些从经济、思想、为人上无法获取到异性的青睐时，他们的基因从某种意义上来讲，也算是被自然所淘汰。 没钱的人只能单身","link":"/2021/05/11/2020%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5%E9%9A%8F%E7%AC%94/"},{"title":"一句话","text":"自己下定决心到达成某个目标时，不要和别人说，等自己完成后再说","link":"/2021/05/17/%E4%B8%80%E5%8F%A5%E8%AF%9D/"},{"title":"C#设置程序开机自启动[需登录]","text":"## 写在前面 本来是想在服务器上实现服务器崩溃或者更新后，可以自动启动winform程序，但是以下方法还是需要有用户登录进去。 方法一：将软件的快捷方式创建到计算机的自动启动目录下（不需要管理员权限） 进入目录：C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 将应用程序快捷方式剪切(或者复制)并粘贴到目录中 应用程序快捷方式加入到了启动项，下次重启电脑之后这个应用程序就会自动开机运行了 如果需要针对个人账户进行配置：Win+R输入命令shell:startup ,会直接弹出启动项对应的目录，然后像前面方法一样把应用程序快捷方式复制到启动目录 方法二：修改计算机注册表的方式（需要管理员权限）开始Windows自启动原理在Windows操作系统下，主要有2个文件夹和8个注册表键项控制程序的自启动，通过修改“Run”键值实现自启动程序是比较常见的方法。具体的位置是：HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Run 参考资料： Windows程序自启动原理 代码在知道注册表中自启动位置所在后，只需要将需要启动的程序路径添加至指定路径中就可以实现开机自启动功能。 Program.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/// &lt;summary&gt;/// 应用程序的主入口点。/// &lt;/summary&gt;[STAThread]static void Main(){ Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); string appGuid = ((GuidAttribute)Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(GuidAttribute), false).GetValue(0)).Value; using (Mutex mutex = new Mutex(false, \"Global\\\\\" + appGuid)) { if (!mutex.WaitOne(0, false)) { return; } //判断是否开启自启动 string strFilePath = Application.ExecutablePath; string strFileName = System.IO.Path.GetFileName(strFilePath); try { //自启动功能是否开启 var AutoRunFlag = ConfigurationManager.AppSettings[\"AutoRunFlag\"] == \"1\" ? true : false; //自启动是否已经存在 var flag = SystemHelper.IsAutoRun(strFilePath, strFileName); if (AutoRunFlag != flag) { #region 获取管理员权限，进行注册表写入操作 //当前用户是管理员的时候，直接启动应用程序并且写入注册表 //如果不是管理员，则使用启动对象启动程序，以确保使用管理员身份运行 //获得当前登录的Windows用户标示 WindowsIdentity identity = WindowsIdentity.GetCurrent(); WindowsPrincipal principal = new WindowsPrincipal(identity); //判断当前登录用户是否为管理员 if (principal.IsInRole(WindowsBuiltInRole.Administrator)) { try { //如果是管理员，注册自启动代码 SystemHelper.SetAutoRun(strFilePath, strFileName, AutoRunFlag); } catch(Exception ex) { MessageBox.Show( ex.Message, \"错误提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); } } else { //创建启动对象 System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo(); startInfo.UseShellExecute = true; startInfo.WorkingDirectory = Environment.CurrentDirectory; startInfo.FileName = Application.ExecutablePath; //设置启动动作,确保以管理员身份运行 startInfo.Verb = \"runas\"; try { System.Diagnostics.Process.Start(startInfo); } catch { return; } //退出 Application.Exit(); } #endregion } //启动程序 Application.Run(new Form1()); } catch(Exception ex) { MessageBox.Show(ex.Message, \"错误提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); //return; } } } SystemHelper.cs 参考自：C# winform程序实现开机自启动，并且识别是开机启动还是双击启动 SystemHelper.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public sealed class SystemHelper{ private SystemHelper() { } /// &lt;summary&gt; /// 设置程序开机启动 /// &lt;/summary&gt; /// &lt;param name=\"strAppPath\"&gt;应用程序exe所在文件夹&lt;/param&gt; /// &lt;param name=\"strAppName\"&gt;应用程序exe名称&lt;/param&gt; /// &lt;param name=\"bIsAutoRun\"&gt;自动运行状态&lt;/param&gt; public static void SetAutoRun(string strAppPath, string strAppName, bool bIsAutoRun) { try { if (string.IsNullOrWhiteSpace(strAppPath) || string.IsNullOrWhiteSpace(strAppName)) { throw new Exception(\"应用程序路径或名称为空！\"); } RegistryKey reg = Registry.LocalMachine; RegistryKey run = reg.CreateSubKey(@\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"); if (bIsAutoRun) { run.SetValue(strAppName, strAppPath); } else { if (null != run.GetValue(strAppName)) { run.DeleteValue(strAppName); } } run.Close(); reg.Close(); } catch (Exception ex) { throw new Exception(ex.Message, ex); } } /// &lt;summary&gt; /// 判断是否开机启动 /// &lt;/summary&gt; /// &lt;param name=\"strAppPath\"&gt;应用程序路径&lt;/param&gt; /// &lt;param name=\"strAppName\"&gt;应用程序名称&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsAutoRun(string strAppPath, string strAppName) { try { RegistryKey reg = Registry.LocalMachine; RegistryKey software = reg.OpenSubKey(@\"SOFTWARE\"); RegistryKey run = reg.OpenSubKey(@\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"); object key = run.GetValue(strAppName); software.Close(); run.Close(); if (null == key || !strAppPath.Equals(key.ToString())) { return false; } return true; } catch (Exception ex) { throw new Exception(ex.Message, ex); } }} 运行环境 Win10.NET Framework4.5VS2019 填坑 注册表地址 使用代码修改注册表的方式，如果需要查看注册信息，需要确认程序是32-bit还是64-bit。 32位，查看地址为 :HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVers ion\\Run 64位，查看地址为 :HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 操作系统 64位程序访问的注册表 32位程序访问的注册表 64位系统 HKEY_LOCAL_MACHINE\\SOFTWARE HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node 32位系统 - HKEY_LOCAL_MACHINE\\SOFTWARE 参考资料： .NET/C# 在 64 位进程中读取 32 位进程重定向后的注册表 关于WOW6432Node 以管理员权限打开程序：参考资料： Windows 下使用 runas 命令以指定的权限启动一个进程（非管理员、管理员） Windows 中的 UAC 用户账户控制 C#程序以管理员权限运行","link":"/2021/07/16/C-%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"},{"title":"C#代码确保应用程序只有一个实例","text":"使用互斥锁，实现只有一个程序 代码： code.cs12345678910string appGuid = ((GuidAttribute)Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(GuidAttribute), false).GetValue(0)).Value;using (Mutex mutex = new Mutex(false, \"Global\\\\\" + appGuid)){ if (!mutex.WaitOne(0, false)) { return; } //启动程序 Application.Run(new Form1()); } 运行环境 Win10.NET Framework 4.5VS2019 参考资料： What is a good pattern for using a Global Mutex in C#? The Misunderstood Mutex C# prevent multiple instance of console application running","link":"/2021/07/20/C-%E4%BB%A3%E7%A0%81%E7%A1%AE%E4%BF%9D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B/"},{"title":"服务器设置系统启动时程序自动运行（不需要登录）","text":"## 写在前面 本方法不适用于winform、WPF等UI程序。涉及到windows系统的用户会话管理的策略。Windows系统中存在一个特殊的 Session，其 Session ID 为 0。这通常称为 Session0。所有 Windows 服务都在 Session0 中运行，并且 Session0 是非交互式的。非交互式意味着无法启动 UI 应用程序； 1. 通过组策略设置脚本随服务器启动打开组策略编辑器 找到 计算机配置-&gt;Windows设置-&gt;脚本（启动/关机） 选中启动 将下列脚本添加进去，配置好启动程序路径的参数： start.bat1234567@echo offREM 声明采用UTF-8编码chcp 65001@REM pauseset input=%1%echo 自启动程序路径参数:%input%start %input% 2. 使用任务计划程序需要注意的时，在选择用户执行时，如果创建任务的用户为Administrator，需要注意执行时的用户账户，如果是需要在服务器启动时运行，就不应该为Administrator，而是应该为SYSTEM。 参考资料： Windows Server 2012的服务管理自动化 windows2008服务器设置系统启动时程序自动运行 碰见的问题： Windows Scheduled Task - Error 2147943711 for “on startup” task Task scheduler can’t show GUI of the application after login (Run whether user is logged on or not mode) - How bypass it with C# 界面显示问题： According to Microsoft (emphasis added): You can specify that a task should run even if the account under which the task is scheduled to run is not logged on when the task is triggered. To do this, select the radio button labeled Run whether user is logged on or not . If this radio button is selected, tasks will not run interactively. To make a task run interactively, select the Run only when user is logged on radio button. Essentially, if you select ‘Run whether user is logged on or not’, the process will not start a UI.","link":"/2021/07/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%97%B6%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%EF%BC%88%E4%B8%8D%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95%EF%BC%89/"},{"title":"Win10中文语言下添加美式键盘","text":"个人操作习惯使用Ctrl+Shift切换键盘布局，但是win10的更新会经常性导致输入法的问题出现。下面是一些平时收集到的方法。 ### 20H2版本 无法通过修改注册表实现添加美式键盘，目前使用Silence的工具箱博主开发的工具进行修改 日期 使用版本 链接 2021-7-20 V0.9.2.0 TSFTool V0.9.2.0 输入法设置工具 20H2以前的版本通过注册表可以正常添加美式键盘布局。 来源：https://www.itsk.com/thread-413229-1-1.html 2021-7-20.reg12345678910111213141516171819Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Keyboard Layout\\Preload]\"1\"=\"00000804\"[HKEY_CURRENT_USER\\Keyboard Layout\\Substitutes]\"00000804\"=\"00000409\"[HKEY_USERS\\.DEFAULT\\Keyboard Layout\\Preload]\"1\"=\"00000804\"[HKEY_USERS\\.DEFAULT\\Keyboard Layout\\Substitutes]\"00000804\"=\"00000409\"[HKEY_CURRENT_USER\\Control Panel\\International\\User Profile]\"InputMethodOverride\"=\"0804:00000409\"[HKEY_CURRENT_USER\\Control Panel\\International\\User Profile\\zh-Hans-CN]\"0804:00000409\"=dword:00000001","link":"/2021/07/20/Win1020H2%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%BE%8E%E5%BC%8F%E9%94%AE%E7%9B%98/"},{"title":"C#穿透session隔离———Windows服务启动UI交互程序","text":"写在前面一开始是因为服务器经常会出现断电、系统崩溃的情况，导致一些正常运行的winform程序在系统故障重启后，每次都需要手动登录触发事件让程序自启。然后想利用windows服务在开启时就会自启来实现开机启动Winform程序。但是因为从Vista 开始引入了 Session 0 隔离机制，导致windows服务无法直接进行界面交互操作。 注意：使用CreateProcessAsUser与界面交互需要Session Id &gt;0 ，用户会话的必须存在，如果存在服务器重启、注销后，重新开机导致系统只有Session 0存在，此时服务调用后的程序是不会显示界面的。所以到头来还是没能实现我的想法。。。淦 Session 0 隔离原理参考： 穿透Session 0 隔离（一）摘录用户界面特权隔离 在早期的Windows操作系统中，在同一用户下运行的所有进程有着相同的安全等级，拥有相同的权限。例如，一个进程可以自由地发送一个Windows消息到另外一个进程的窗口。从Windows Vista开始，当然也包括Windows 7、Windows 10，对于某些Windows消息，这一方式再也行不通了。进程(或者其他的对象)开始拥有一个新的属性——特权等级(Privilege Level)。一个特权等级较低的进程不再可以向一个特权等级较高的进程发送消息，虽然他们在相同的用户权限下运行。这就是所谓的用户界面特权隔离(User Interface Privilege Isolation ，UIPI)。 UIPI的引入，最大的目的是防止恶意代码发送消息给那些拥有较高权限的窗口以对其进行攻击，从而获取较高的权限等等，在计算机系统中，这却是一种维护系统安全的合适方式。 windows服务启动UI程序、对于简单的交互，服务可以通过WTSSendMessage 函数，在用户Session 上显示消息窗口。对于一些复杂的UI 交互，必须调用CreateProcessAsUser 或其他方法（WCF、.NET远程处理等）进行跨Session 通信，在桌面用户上创建一个应用程序界面。 解决思路是：window service创建一个和与当前登陆用户可以交互的进程，这个进程运行在admin权限下，能够调起应用程序的UI 具体的做法是：widow service复制winlogon.exe进程句柄，然后通过调用api函数CreateProcessAsUser（）以winlogon.exe权限创建新进程，新创建的进程有winlogon.exe的权限（winlogon.exe运行在system权限下），负责调用程序。 作者原文： First, we are going to create a Windows Service that runs under the System account. This service will be responsible for spawning an interactive process within the currently active User’s Session. This newly created process will display a UI and run with full admin rights. When the first User logs on to the computer, this service will be started and will be running in Session0; however the process that this service spawns will be running on the desktop of the currently logged on User. We will refer to this service as the LoaderService. Next, the winlogon.exe process is responsible for managing User login and logout procedures. We know that every User who logs on to the computer will have a unique Session ID and a corresponding winlogon.exe process associated with their Session. Now, we mentioned above, the LoaderService runs under the System account. We also confirmed that each winlogon.exe process on the computer runs under the System account. Because the System account is the owner of both the LoaderService and the winlogon.exe processes, our LoaderService can copy the access token (and Session ID) of the winlogon.exe process and then call the Win32 API function CreateProcessAsUser to launch a process into the currently active Session of the logged on User. Since the Session ID located within the access token of the copied winlogon.exe process is greater than 0, we can launch an interactive process using that token. 参考：交互式服务C#开发Windows服务详细流程C#穿透session隔离———Windows服务启动UI交互程序Subverting Vista UAC in Both 32 and 64 bit Architectures 问题windows服务启动winform程序不显示UI问题解决原因：xp系统的用户和window service运行在一个session下，在xp以后，windows系统改变了用户会话管理的策略，window service独立运行在session0下，依次给后续的登录用户分配sessionX(X =1,2,3…)，session0没有权限运行UI。所以在window xp以后的系统下，window service调用有UI的application时只能看到程序进程但不能运行程序的UI。 参考：C# windows服务启动winform程序不显示UI问题解决How can a Windows service execute a GUI application?穿透Session 0 隔离（二）","link":"/2021/07/21/C-%E7%A9%BF%E9%80%8Fsession%E9%9A%94%E7%A6%BB%E2%80%94%E2%80%94%E2%80%94Windows%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8UI%E4%BA%A4%E4%BA%92%E7%A8%8B%E5%BA%8F/"},{"title":"SQLite学习【一】","text":"SQLite学习.sql123456789101112131415161718192021222324252627282930313233343536373839404142434445--创建数据库(数据库名可以是任何名字，文件类型始终为sqlite类型)sqlite3 test.sqlitesqlite3 other.dbsqlite3 db.sqlite3--创建数据表 增删改查 SQLiteCREATE TABLE DEPARTMENT( ID INT PRIMARY KEY NOT NULL, DEPT CHAR(50) NOT NULL, EMP_ID INT NOT NULL);CREATE TABLE Test( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL);SELECT * FROM sqlite_master WHERE type = 'table';DROP TABLE DEPARTMENT;SELECT * FROM sqlite_master WHERE type = 'table';--增INSERT INTO `Test` (ID, NAME, AGE, ADDRESS, SALARY) VALUES (1,'测试人员',35,'东北那旮瘩',5000);INSERT INTO `Test` (ID, NAME, AGE, ADDRESS, SALARY)VALUES (2,'测试人员',35,'东北那旮瘩',10000);SELECT * from Test ;--删DELETE from `Test` where ID='1';SELECT * from Test ;--改update `Test` set Name ='测试人员2' where ID=2;SELECT * from `Test`;DROP TABLE Test;SELECT * FROM sqlite_master WHERE type = 'table';","link":"/2021/07/28/sqlite/"},{"title":"PDI【Kettle】（一）","text":"转换组件-脚本-JavaScript【Spoon】我们在使用JavaScript组件的时候,在左侧核心树对象栏中可以看到Kettle为我们提供了很多简洁强大的内置函数,帮助我们在写脚本的时候对数据、参数变量等能很轻松的做处理,体验编码的感觉.本篇将详细介绍JavaScript组件中的函数功能 脚本组件包含的函数主要包括六大类,分别是： 字符串类型的函数(String Functions) 浮点型的函数(Numeric Functions) 日期类型函数(Date Functions) 逻辑判断型函数(Logic Functions) 特殊的函数(Special Functions) 文件处理类函数(File Functions) 字符串类型函数(String Functions)顾名思义,字符串类型的函数肯定是针对字符串类型的参数、变量进行处理操作的函数 日期转字符串(date2str)日期转字符串函数date2str主要有4个方法,分别是： date2str(date):传入日期实例,转换成字符串类型 date2str(date,format):传入日期和格式化参数,进行格式化转换 date2str(date,format,iso):传入日期和参数格式化及ISO代码进行转换,(DE = German, EN = English, FR = France, …) date2str(date,format,iso,zone):传入时区进行格式化,例如北京时区(GMT+8) 日期格式化参数format参数类型供参考： 1234567yy / yyyy - 06 / 2006MM / MMM / MMMMM - 11 / Nov / Novemberd / dd - 1 / 01E / EEEE - Tue / Tuesdayhh / HH - 11 / 23m / mm - 5 / 05s / ss - 8 / 08 代码示例: 1234567var dValue = new Date();writeToLog(date2str(dValue,\"dd.MM.yyyy\"));writeToLog(date2str(dValue,\"dd.MM.yyyy HH:mm:ss\"));writeToLog(date2str(dValue,\"E.MMM.yyyy\",\"DE\"));writeToLog(date2str(dValue,\"dd.MM.yyyy HH:mm:ss\",\"EN\"));writeToLog(date2str(dValue,\"dd.MM.yyyy HH:mm:ss\",\"ZH\", \"GMT+8\"));writeToLog(date2str(dValue,\"yyyy-MM-dd HH:mm:ss\",\"ZH\", \"GMT+8\")); 以上代码在控制台将会输出如下： 1234562019/08/19 10:12:56 - JavaScript代码.0 - 19.08.20192019/08/19 10:12:56 - JavaScript代码.0 - 19.08.2019 10:12:562019/08/19 10:12:56 - JavaScript代码.0 - Mo.Aug.20192019/08/19 10:12:56 - JavaScript代码.0 - 19.08.2019 10:12:562019/08/19 10:12:56 - JavaScript代码.0 - 19.08.2019 10:12:562019/08/19 10:12:56 - JavaScript代码.0 - 2019-08-19 10:12:56 转义HTMLescapeHtml(html)代码如下： 123var html=\"&lt;h1&gt;我是H2标题&lt;/h2&gt;\";writeToLog(escapeHtml(html)) 最终输出 12019/08/19 10:16:13 - JavaScript代码.0 - &amp;lt;h1&amp;gt;&amp;#25105;&amp;#26159;H2&amp;#26631;&amp;#39064;&amp;lt;/h2&amp;gt; 转义SQL(escapeSQL(var))12var str1 = \"SELECT * FROM CUSTOMER WHERE NAME='\" + escapeSQL(\"McHale's Navy\") + \"'\"; writeToLog(str1) 该函数会把单引号转成双引号,输出结果如下： 12019/08/19 10:18:59 - JavaScript代码.0 - SELECT * FROM CUSTOMER WHERE NAME='McHale''s Navy' 构造定长字符串(fillString(char,length))代码示例如下： 12writeToLog(fillString(\"x\",10));writeToLog(fillString(\"A\",3)); 最终会输出10个X和3个A,输出结果如下： 122019/08/19 10:24:08 - JavaScript代码.0 - xxxxxxxxxx2019/08/19 10:24:08 - JavaScript代码.0 - AAA 需要注意的是第一个是一个char类型的单字符,不能是字符串 统计字符串出现频次(getOcuranceString(str,searchStr))第一个参数是要搜索的完整字符串,第二个参数是要搜索统计的字符串 代码示例： 1234var sef='2007-09-11';writeToLog(getOcuranceString(sef,'0'))writeToLog(getOcuranceString(sef,'00')) 我们分别统计字符串0和00最终出现的次数,此时,日志最终打印的次数是3和1： 122019/08/19 10:28:45 - JavaScript代码.0 - 32019/08/19 10:28:45 - JavaScript代码.0 - 1 获取字符串下标索引(indexOf)获取下标索引主要有2个重构函数,分别是： indexOf(string,subString):获取出现字符串的索引开始位置 indexOf(string,subString,fromIndex)；指定开始位置,获取字符串索引开始位置 代码示例： 123456var str1= \"Hello Pentaho!\";var str2= indexOf(str1, \"Pentaho\");var str3= indexOf(str1, \"o\", 7);writeToLog(\"Input : \" + str1);writeToLog(\"Index of 'Pentaho' : \" + str2);writeToLog(\"index of 'o', search from position 7 : \" + str3); 最终控制台输出： 1232019/08/19 10:34:16 - JavaScript代码.0 - Input : Hello Pentaho!2019/08/19 10:34:16 - JavaScript代码.0 - Index of 'Pentaho' : 62019/08/19 10:34:16 - JavaScript代码.0 - index of 'o', search from position 7 : 12 首字母大写(initCap)对指定字符串首字母大写处理,来看代码示例： 1234var str1 = \"my home\"; writeToLog(initCap(str1));writeToLog(initCap('test a aaa cw'));writeToLog(initCap('myhome')); 此时,最终控制台输出如下： 1232019/08/19 10:41:27 - JavaScript代码.0 - My Home2019/08/19 10:41:27 - JavaScript代码.0 - Test A Aaa Cw2019/08/19 10:41:27 - JavaScript代码.0 - Myhome 字符串转小写(lower)将传入字符串全部转小写 代码如下： 12345var str1= \"Hello World!\";var str2= lower(str1);writeToLog(\"Input:\" + str1);writeToLog(\"Converted to LowerCase:\" + str2);writeToLog(lower('DDDHelloSWxss')) 响应内容 1232019/08/19 10:43:09 - JavaScript代码.0 - Input:Hello World!2019/08/19 10:43:09 - JavaScript代码.0 - Converted to LowerCase:hello world!2019/08/19 10:43:09 - JavaScript代码.0 - dddhelloswxss 字符串填充左侧(lpad(string,char,length))用指定长度的给定字符将字符串填充到左侧 参数定义： 1：传入字符串 2：填充单字符 3：填充单字符长度 如果length长度超过给定字符串的长度,将对填充字符串做减法，例如： 12var str1= \"Hello World!\"; writeToLog(\"Lpad:\" + lpad(str1, \"x\",20)); 此时,最终输出结果为： 12019/08/19 10:46:38 - JavaScript代码.0 - Lpad:xxxxxxxxHello World! 最终的完成长度是20个字符长度,因此填充的单字符x并没有填充20次 如果length长度小于给定字符串的长度,则默认返回原字符串,不做填充,代码示例： 12var str1= \"Hello World!\"; writeToLog(\"Lpad:\" + lpad(str1, \"x\",5)); 此时最终的输出结果为： 12019/08/19 10:46:38 - JavaScript代码.0 - Lpad:Hello World! 去空字符(ltrim)从左侧开始去除空字符串 数字转字符串(num2str)给定数字,转换为字符串,主要有3个构造函数： num2str(num):转换num数字为字符串 num2str(num,format):格式化数字为指定字符串 num2str(num,format,iso):按照本地ISO编码进行格式化 代码示例如下： 123456var d1 = 123.40;var d2 = -123.40;writeToLog(num2str(d1));writeToLog(num2str(d1, \"0.00\"));writeToLog(num2str(d1, \"0.00\", \"EN\"));writeToLog(num2str(d2, \"0.00;(0.00)\", \"EN\")); 最终控制台输出： 12342019/08/19 11:00:17 - JavaScript代码.0 - 123.42019/08/19 11:00:17 - JavaScript代码.0 - 123.402019/08/19 11:00:17 - JavaScript代码.0 - 123.402019/08/19 11:00:17 - JavaScript代码.0 - (123.40) XML保护标签函数转换(protectXMLCDATA)传入给定字符串,添加标准保护,代码示例 12var str1 = \"my home\"; writeToLog(protectXMLCDATA(str1)); 此时,将会给变量str1加上保护标签 12019/08/19 11:02:09 - JavaScript代码.0 - &lt;![CDATA[my home]]&gt; 移除字符串中CRLF字符(removeCRLF(str))给定字符串中删除CR END LF的字符串 替换字符串(replace)替换字符串主要包括两个构造函数： replace(str,searchStr,replaceStr):从指定字符串中查询，然后替换 replace(str,firstSearch,firstReplace,secondSearch,SecondReplace...)：无限查询替换 代码示例如下： 12345var str1 = \"Hello World, this is a nice function\"; var str2 = replace(str1,\"World\", \"Folk\");writeToLog(str2);var str2 = replace(str1,\"World\", \"Folk\", \"nice\",\"beautifull\");writeToLog(str2); 最终输出: 122019/08/19 11:10:21 - JavaScript代码.0 - Hello Folk, this is a nice function2019/08/19 11:10:21 - JavaScript代码.0 - Hello Folk, this is a beautifull function 字符串右侧填充(rpad(string,char,length))使用方法同lpad,只是一个是左侧，一个是右侧 去除空字符(右侧)(rtrim)正则切分(str2RegExp)出入一个正则表达式,对string字符串进行Split操作.代码如下： 123456789101112var strToMatch = \"info@proconis.de\";var strReg = \"^(\\\\w+)@([a-zA-Z_]+?)\\\\.([a-zA-Z]{2,3})$\";var xArr = str2RegExp(strToMatch, strReg);if ( xArr != null ) { for(i=0;i&lt;xArr.length;i++) { writeToLog(xArr[i]); }}else { writeToLog(\"no match\");} 最终控制台输出： 1232019/08/19 13:21:19 - JavaScript代码.0 - info2019/08/19 13:21:19 - JavaScript代码.0 - proconis2019/08/19 13:21:19 - JavaScript代码.0 - de 字符串截取(substr)通过制定索引开始对字符串进行截取操作,主要有两个重构参数： substr(string,from):指定from索引开始截取字符串 substr(string,from,to):指定开始和截止索引进行截取 代码示例： 123456var str1= \"Hello Pentaho!\";var str2= substr(str1, 6);var str3= substr(str1, 6, 7);writeToLog(\"Input : \" + str1);writeToLog(\"From position 6: \" + str2);writeToLog(\"From position 6 for 7 long : \" + str3); 控制台输出如下： 1232019/08/19 13:31:20 - JavaScript代码.0 - Input : Hello Pentaho!2019/08/19 13:31:20 - JavaScript代码.0 - From position 6: Pentaho!2019/08/19 13:31:20 - JavaScript代码.0 - From position 6 for 7 long : Pentaho 去除左右空格(trim)不转义HTML(unEscapeHtml(html))针对以转义的HTML字符进行解密,代码如下： 1234567var w='&lt;h2&gt;我是H2标题&lt;/h2&gt;';var esW=escapeHtml(w);var unesw=unEscapeHtml(esW);writeToLog(esW);writeToLog(unesw); 最终控制台输出： 122019/08/19 13:38:16 - JavaScript代码.0 - &amp;lt;h2&amp;gt;&amp;#25105;&amp;#26159;H2&amp;#26631;&amp;#39064;&amp;lt;/h2&amp;gt;2019/08/19 13:38:16 - JavaScript代码.0 - &lt;h2&gt;我是H2标题&lt;/h2&gt; 解码转义XML(unEscapeXml )字符串转大写(upper)将传入字符串全部转大写.例如: 12var str=\"Hello World\";writeToLog(upper(str)); 浮点型的函数(Numeric Functions)计算绝对值(abs(num))计算一个数值的绝对值,代码示例： 1234var d1 = -1234.01;var d2 = 1234.01;writeToLog(abs(d1));writeToLog(abs(d2)); 最终控制台输出为： 122019/08/19 13:51:00 - JavaScript代码.0 - 1234.012019/08/19 13:51:00 - JavaScript代码.0 - 1234.01 最小双精度值(ceil(num))返回最小的双精度值。该值将被四舍五入。代码示例： 1234var d1 = -1234.01;var d2 = 1234.01;writeToLog(ceil(d1));writeToLog(ceil(d2)); 最终控制台输出： 122019/08/19 13:52:40 - JavaScript代码.0 - -12342019/08/19 13:52:40 - JavaScript代码.0 - 1235 最大数值(floor(num))返回最大数值,该值将被四舍五入,代码示例： 1234var d1 = -1234.01;var d2 = 1234.01;writeToLog(floor(d1));writeToLog(floor(d2)); 运行结果如下： 122019/08/19 13:55:13 - JavaScript代码.0 - -12352019/08/19 13:55:13 - JavaScript代码.0 - 1234 字符串转数值(str2num(var))字符串转数值主要包含两个构造函数,分别是 str2num(str):传入数值字符串,进行格式化转换 str2num(str,format):通过指定格式进行数值转换 代码示例如下： 1234var str1 = \"1.234,56\";var str2 = \"12\";writeToLog((str2num(str1,\"#,##0.00\")));writeToLog((str2num(str2))); 最终控制台输出： 122019/08/19 14:02:19 - JavaScript代码.0 - 1.2342019/08/19 14:02:19 - JavaScript代码.0 - 12 截取数值(trunc)1trunc(1234.9); // 返回 1234 日期类型函数(Date Functions)日期相加(dateAdd)针对日期变量进行相应的添加时间,添加频率包括年、月、日、时、分、秒 等等 函数定义:dateAdd(date,format,plusNum) date:日期对象 format:要加的类型 plusNum:加的数值 相加类型主要包括： y:年 m：月 d:日 w:周 wd:工作日 hh:小时 mi:分钟 ss:秒 代码示例如下： 1234567var d1 = new Date();var fmt='yyyy-MM-dd HH:mm:ss';writeToLog(\"当前时间:\"+date2str(d1,fmt));var py=dateAdd(d1,'y',1);var fy=date2str(py,fmt);writeToLog(\"加1年：\"+fy); 最终控制台输出： 122019/08/19 14:17:41 - JavaScript代码.0 - 当前时间:2019-08-19 14:17:412019/08/19 14:17:41 - JavaScript代码.0 - 加1年：2020-08-19 14:17:41 日期比较(dateDiff)两个日期相互比较 函数定义:dateDiff(startDate,endDate,type) startDate:开始日期 endDate:截止日期 type：返回相差数值类型 类型主要包括： y:年 m：月 d:日 w:周 wd:工作日 hh:小时 mi:分钟 ss:秒 获取指定日期数值(getDayNumber)根据类型获取指定日期的数值 函数定义：getDayNumber(date,type) date:当前日期实例 type:类别 类别主要分四类 y:获取当年的天数 m:获取当月的天数 w:获取本周的天数 wm:获取当月中本周的天数 代码示例： 12345var d1 = new Date();writeToLog(getDayNumber(d1, \"y\"));writeToLog(getDayNumber(d1, \"m\"));writeToLog(getDayNumber(d1, \"w\"));writeToLog(getDayNumber(d1, \"wm\")); getFiscalDate12345678910111213141516// Returns the fiscal Date from the date value,// based on a given offset.//// Usage:// getFiscalDate(var);// 1: Date - The Variable with the Date.// 2: String - The Date/Month which represents// the fiscal Start Offset. Format allways \"dd.MM.\".//// 2006-11-15//var d1 = new Date();var str1 = \"01.07.\";var str2 = \"10.12.\";Alert(getFiscalDate(d1, str1));Alert(getFiscalDate(d1, str2)); 获取下一个工作日日期(getNextWorkingDay)传入当前日期,获取该日期后面一个工作日日期 函数定义getNextWorkingDay(date) 代码示例如下： 12345678910var d1 = new Date();// 周1var d2=str2date('2019-08-19 16:36:00',fmt);//周 6var d3=str2date('2019-08-17 16:36:00',fmt);writeToLog(date2str(getNextWorkingDay(d1),fmt));writeToLog(date2str(getNextWorkingDay(d2),fmt));writeToLog(date2str(getNextWorkingDay(d3),fmt)); 我们这d2和d3变量中定义了不同的日期实例,分别是周1和周6,最终通过getNextWorkingDay能获取得到下一个工作日日期，控制台输出如下： 1232019/08/19 16:37:38 - JavaScript代码.0 - 2019-08-20 16:37:382019/08/19 16:37:38 - JavaScript代码.0 - 2019-08-20 16:36:002019/08/19 16:37:38 - JavaScript代码.0 - 2019-08-19 16:36:00 获取当前月份数值(month(date))获取当前日期的月份数值,需要注意的是,该值的月份是从0开始的,因此我们最终得到的结果应该+1才是我们的真实月份数值，代码示例： 12var d1 = new Date();//2019/08/19writeToLog(month(d1)); //最终输出为7 获取当前时间的季度值(quarter(date))根据指定日期获取当前季度数值 12var d1 = new Date();//2019/08/19writeToLog(quarter(d1));//最终输出为3(代表第三季度) 字符串转日期(str2date)字符串转日期和日期转字符串有点类似,只不过主体对换了一下,但是传入的格式参数都是一样的，主要有4个重载函数: str2date(str):默认转换 str2date(str,format):传入format格式化参数 str2date(str,format,iso):根据iso编码及格式化参数进行转换 str2date(str,format,iso,timezone):根据不同时区的iso编码进行格式化转换 代码示例如下： 12345writeToLog(str2date(\"01.12.2006\",\"dd.MM.yyyy\"));writeToLog(str2date(\"01.12.2006 23:23:01\",\"dd.MM.yyyy HH:mm:ss\"));writeToLog(str2date(\"Tue.May.2006\",\"E.MMM.yyyy\",\"EN\"));writeToLog(str2date(\"22.02.2008 23:23:01\",\"dd.MM.yyyy HH:mm:ss\",\"DE\"));writeToLog(str2date(\"22.02.2008 23:23:01\",\"dd.MM.yyyy HH:mm:ss\",\"DE\", \"EST\")); 截取日期(truncDate(date,type))指定截取不同的日期部分,函数定义truncDate(date,type) date:当前日期实例 type:截取类型 类型主要有6中,分别是整型，从0-5： 5：截取月份 4：截取天数 3:截取小时 2：截取分钟 1：截取秒 0:截取毫秒 代码示例 如下： 1234567var dateTime = new Date();var date0 = truncDate(dateTime, 0); // gives back today at yyyy/MM/dd HH:mm:ss.000var date1 = truncDate(dateTime, 1); // gives back today at yyyy/MM/dd HH:mm:00.000var date2 = truncDate(dateTime, 2); // gives back today at yyyy/MM/dd HH:00:00.000var date3 = truncDate(dateTime, 3); // gives back today at yyyy/MM/dd 00:00:00.000var date4 = truncDate(dateTime, 4); // gives back today at yyyy/MM/01 00:00:00.000var date5 = truncDate(dateTime, 5); // gives back today at yyyy/01/01 00:00:00.000 获取当年的周数(week)获取指定日期的周数,代码示例： 123var d1 = new Date(); //2019/08/19 writeToLog(week(d1));// 返回34 获取年份(year)获取传入日期的年份,代码示例： 123var d1 = new Date(); //2019/08/19 writeToLog(year(d1));// 返回2019 逻辑判断型函数(Logic Functions)isCodepage判断字符串的codepage项,代码示例： 123var xStr = \"RÃ©al\";writeToLog(isCodepage(xStr, \"UTF-8\"));// truewriteToLog(isCodepage(xStr, \"windows-1250\"));// true 是否日期(isDate(str))判断当前字符串是否日期 1234var d1 = \"Hello World\"; var d2 = new Date();writeToLog(isDate(d1));//falsewriteToLog(isDate(d2));//true 是否为空(isEmpty(str))判断字符串是否为空 12var d = \"Hello World\"; Alert(isEmpty(d));//false 判断字符串是否为邮箱标准格式(isMailValid(str))判断一个字符串是否是邮箱 判断是否是数值(isNum(str))判断一个字符串是否是数值 1234var str1 = \"Hello World\"; var str2 = 123456;Alert(isNum(str1));//falseAlert(isNum(str2));//true 是否正则匹配(isRegExp)判断给定的正则表达式是否匹配当前的字符串，主要有2个函数定义： isRegExp(str,reg):给定正则判断字符串是否匹配 isRegExp(str,reg1,reg2,reg3…)；可以递归判断正则匹配 最终返回的是匹配的次数数值,如果不匹配,返回-1 代码示例如下： 12345678910var email1 =\"info@proconis.de\";var email2= \"support@proconis.co.uk\";var email3= \"HelloWorld@x\";var reg1=\"^\\\\w+@[a-zA-Z_]+?\\\\.[a-zA-Z]{2,3}$\";var reg2=\"^[\\\\w-\\.]+@([\\\\w-]+\\\\.)+[\\\\w-]{2,4}$\";writeToLog(isRegExp(email1, reg1,reg2) + \" Matches\"); //1writeToLog(isRegExp(email2, reg1,reg2) + \" Matches\"); //2writeToLog(isRegExp(email3, reg1,reg2) + \" Matches\");// 1 是否工作日(isWorkingDay(date))判断某日期是否是工作日,代码示例： 1234var d1 = new Date();//周1var d2=str2date('2019-08-17','yyyy-MM-dd') //周六writeToLog(isWorkingDay(d1));//truewriteToLog(isWorkingDay(d2));//false 特殊的函数(Special Functions)弹框信息(Alert(msg))在屏幕前弹出一个信息框 加载JavaScript文件(LoadScriptFile)将一个javascript文件加载到实际的运行上下文中。应该从定义的StartScript调用此函数，否则，每次处理都会加载javascript文件行。 代码示例如下： 12var xPfad = \"F:/bak/Hello.js\";LoadScriptFile(xPfad); 此时,我们的外部JS文件仅仅是包含一句简单的输出，如下： 1writeToLog(\"Hello LoadScriptFile,outSide JS File \"); 最终运行时,控制台会打印出我们在外部JS中的输出行 从当前Tab栏加载JS并运行(LoadScriptFromTab)如果我们在当前的JavaScript组件中通过模块化的方式编写了很多脚本代码,我们可以通过LoadScriptFromTab函数进行相互调用,这对于开发抽象来说是很好的,代码示例如下： 12writeToLog(\"外部Tab加载JS-------------------------\")LoadScriptFromTab('Item_1'); 有效卡号判断(LuhnCheck)如果给定的是一个有效的卡号,则返回true 123456var str1 = \"4444333322221111\"; writeToLog(str1 + \": \" + LuhnCheck(str1)); //truevar str2 = \"4444333322221110\"; writeToLog(str2 + \": \" + LuhnCheck(str2));//false 向文件中追加数据(appendToFile)向指定文件中追加数据,如果文件不存在则创建文件 1234567var file = \"F:/bak/log.txt\";for(var i=0;i&lt;100;i++){ appendToFile(file,'TEST'+i+\"\\r\\n\");} 此时,该代码会向log.txt文件输出100条数据行 decode函数decode函数有点类似于IF-THEN-ELSE语句，即表示通过给定查询的字符串是否存在，如果存在，即替换,否则返回默认值 代码示例： 123456var str1 = \"Hallo\";writeToLog(decode(str1, \"Hallo\", \"Hello\"));writeToLog(decode(str1, \"1\", \"Mr\", \"2\", \"Mrs\", \"N/A\"));writeToLog(decode(str1, \"1\", \"Mr\", \"2\", \"Mrs\"));str1 = \"Mrs\";writeToLog(decode(str1, \"1\", \"Mr\", \"2\", \"Mrs\")); 控制台输出： 12342019/08/19 17:39:01 - JavaScript代码.0 - Hello2019/08/19 17:39:01 - JavaScript代码.0 - N/A2019/08/19 17:39:01 - JavaScript代码.0 - Hallo2019/08/19 17:39:01 - JavaScript代码.0 - Mrs 执行命令(execProcess)代码如下： 12var t=execProcess('ping www.baidu.com');writeToLog(t) 调用命令行,ping百度的网址，最终输出返回数据 执行SQL语句(fireToDB)通过获取数据库连接名称，传递SQL语句,以返回SQL查询的值,函数定义： fireToDB(connectionName,SQL)；第一个参数为数据库连接名称，我们在JNDI中定义的名称，第二个参数为SQL语句 123var strConn = \"MY Connection\";var strSQL = \"SELECT COUNT(*) FROM ...\";var xArr = fireToDB(strConn, strSQL); 仅仅获取数值(getDigitsOnly)在给定的字符串中仅仅筛选过滤得到数值，代码如下： 12var str1 = \"abc123cde\"; writeToLog(getDigitsOnly(str1));//返回123 获取Kettle环境变量的值(getEnvironmentVar)获取在Kettle中的环境变量的值 12writeToLog(getEnvironmentVar(\"user.dir\"));writeToLog(getEnvironmentVar(\"user.name\")); 获取当前进程的受影响行数(getProcessCount(type))根据类型获取当前进程的受影响行数，类型如下： u:更新行数 i:插入行数 w:写入行数 r:读取行数 o:输出行数 12writeToLog(getProcessCount(\"u\"));writeToLog(getProcessCount(\"r\")); 获取当前转换名称(getTransformationName)获取当前的转换名称 12var xTranName = getTransformationName();writeToLog(xTranName); 获取Kettle环境中的变量值(getVariable)从当前的Kettle环境中获取指定的变量值,目前函数有2个重载： getVariable(varName)；根据变量名称获取变量值 getVariable(varName,defaultValue):根据变量名获取值,如果不存在则使用默认值 12345678var strVarName=\"getVariableTest\";var strVarValue=\"123456\";Alert(getVariable(strVarName, \"\"));setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\"));strVarValue=\"654321\";setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\")); 控制台打印(println)123var str = \"Hello World!\";print(str); 移除数值(removeDigits)移除给定字符串中的数值，代码示例： 123var str1 = \"abc123cde\"; writeToLog(removeDigits(str1));//返回abccde 发送邮件设置环境变量(setEnvironmentVar)通过在Script脚本组件中调用函数重新设置Kettle的环境变量 12345678var strVarName=\"setEnvTest\";var strVarValue=\"123456\";Alert(getEnvironmentVar(strVarName));setEnvironmentVar(strVarName,strVarValue);Alert(getEnvironmentVar(strVarName));strVarValue=\"654321\";setEnvironmentVar(strVarName,strVarValue);Alert(getEnvironmentVar(strVarName)); 设置变量(setVariable)通过setVariable函数设置环境变量,该用途可以用于重新赋值Kettle环境中已经存在的变量值或者重新生成变量值 函数定义setVariable(key,value,level) key:变量名称 value:变量值 level:级别,主要包括s(system)、r(root)、p(parent)、g(grandparent)四种类别 代码示例如下： 12345678var strVarName=\"setEnvTest\";var strVarValue=\"123456\";Alert(getVariable(strVarName, \"\"));setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\"));strVarValue=\"654321\";setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\")); 写入日志(writeToLog)打印并写入日志信息,该函数可能是我们用到的最多的函数,可以帮助我们调试信息,主要有两个重载： writeToLog(msg):写入msg日志信息 writeToLog(level,msg)：根据level基本写入msg信息 关于日志的级别,这里主要是简写的方式,主要如下： d(Debug):调试模式 l(Detailed):详细 e(Error):错误 m(Minimal):最小日志 r(RowLevel):行级日志 12writeToLog(\"Hello World!\");writeToLog(\"r\", \"Hello World!\"); 文件处理类函数(File Functions)复制文件(copyFile)复制一个文件到目标目录,函数定义如下： copyFile(sourceFile,targetFile,overwrite) sourceFile:源文件 targetFile:目标文件 overWrite:是否覆盖,如果目标文件存在的话,布尔类型 12345var file1 = \"F:/bak/log.txt\";var targetFile=\"F:/bak/logTarget.txt\";copyFile(file1,targetFile,false) 创建文件夹(createFolder)创建一个文件夹,代码示例如下： 12var strFolder = \"F:/bak/createFolder\";createFolder(strFolder); 删除文件(deleteFile)删除一个文件(不能删除文件夹) 123var targetFile=\"F:/bak/logTarget.txt\"; deleteFile(targetFile); 判断文件是否存在(fileExists())判断文件是否存在 123var targetFile=\"F:/bak/logTarget.txt\"; fileExists(targetFile); 获取文件扩展名(getFileExtension)如果文件不存在,则返回null,代码示例 1234var file1 = \"F:/bak/log.txt\"; var ext=getFileExtension(file1);writeToLog(\"扩展名：\"+ext) 获取文件大小(getFileSize)获取文件大小,结果是一个long类型的长整型数值 1234var file1 = \"F:/bak/log.txt\"; var ext=getFileSize(file1);writeToLog(\"大小：\"+ext) 获取文件最后修改日期(getLastModifiedTime)获取文件最后修改日期,函数定义： getLastModifiedTime(filePath,format) filePath:文件路径 format：日期格式化 123var file1 = \"F:/bak/log.txt\"; var ext=getLastModifiedTime(file1,\"yyyy-MM-dd HH:mm:ss\"); 获取文件的父文件夹名称(getParentFoldername)获取文件的父文件夹名称 12var file1 = \"F:/bak/log.txt\";var parentFolder=getParentFoldername(file1); 获取文件简称(getShortName)获取文件简称 12345var file1 = \"F:/bak/log.txt\";var shortName=getShortFilename(file1);writeToLog(\"简单名称:\"+shortName)//返回log.txt 判断是否是一个文件(isFile)判断是否是一个文件 12var file1 = \"F:/bak/log.txt\";var flag=isFile(file1) //true 判断是否是一个文件夹(isFolder)判断是否是一个文件夹 12var file1 = \"F:/bak/log.txt\";var flag=isFolder(file1) //false 加载一个文件的内容(loadFileContent)从指定文件中加载内容,主要有两个重载函数： loadFileContent(filePath):默认加载文件 loadFileContent(filePath,encoding):指定编码加载文件内容 代码示例： 1234var file1 = \"F:/bak/log.txt\";var content=loadFileContent(file1);var c1=loadFileContent(file1,\"UTF-8\")writeToLog(content) 移动文件(moveFile)移动指定文件，函数定义moveFile(source,target,overWrite) source:源文件 target:目标文件 overWrite；是否覆盖,如果目标文件存在,布尔类型值 12345var file1 = \"F:/bak/log.txt\";var targetFile=\"F:/bak/logTarget.txt\";moveFile(file1,targetFile,false) 创建一个空文件(touch)创建一个空文件 12var strFile = \"F:/bak/log.txt\";touch(strFile); 总结以上就是Kettle 8.3版本中的内置函数方法,方法很多,写这篇博客也是很累,算是全部都学习了一遍,脑子里已经记忆了一遍,但是我们也不需要死记硬背,就和我们学些Linux命令一样,如果你知道man命令，对某个命令不是很了解的话直接通过man命令学习即可. Kettle也是如此,对于某个函数不是很了解的话,右键点击该函数,会出现sample字样菜单,点击该菜单即可弹出该函数的介绍和使用信息,里面包含了该函数的调用示例和函数详细介绍,也是很人性化的.","link":"/2021/07/29/Kettle/"},{"title":"kettle填坑","text":"写在前面为了将MSSqlserver数据传输至MySql数据库，一开始的选择有很多,类似DataX、ES，但是碍于运行环境是windows server 2012,且服务器环境不方便更改，查阅一番后，决定使用kettle进行数据的同步。 环境 系统：windows server 2012R2 64位 内存：8GB JDK：1.8 kettle配置统一参数一、kettle的常用配置文件说明： ${user.home} 表示WINDOWS的当前用户的文档文件夹，在C:\\Users文件夹下 ${user.home}/ .kettle /repositories.xml: 该文件保存了用户设置的所有资源库信息,包括资源库名称,资源库需要的数据库连接参数等。该文件中定义的资源库将显示在spoon启动后出现的选择资源库下拉列表中,注意该文件的编码是UTF-8，资源库的名称尽量使用英文。 ${user.home}/ kettle/kettle.properties: 该文件保存了转换或作业中需要的变量, spoon启动后会自动加载该文件里定义的变量。 ${user.home}/.kettle/shared.xml: 该文件里保存了共享对象,共享对象可以是Database connections, Steps,Slave servers ,Partition schemas ,Cluster schemas。对象共享实质上就是将对象序列化的过程, spoon启动时,会加载shared.xml文件中定义的所有对象。 lib\\kettle-engine.jar\\kettle-jobs.xml: 该文件中定义了Spoon启动时需要加载的作业项。 lib\\kettle-engine.jarkettle-partition-plugins.xml: 该文件中定义了Spoon启动时需要加载的分区插件。 lib\\kettle-engine.jar\\kettle- plugins.xml: 该文件中定义了Spoon启动时步骤和作业项插件的加载路径。 lib\\kettle-engine.jar\\kettle-steps.xml: 该文件中定义了Spoon启动时需要加载的转换步骤。 二、修改repositories.xml的位置 找到kettle所在文件夹下的Spoon.bat 文件,在里面查找出Kettle home所在的代码段,在 cd %KETTLE_DIR%代码上一行加上代码：set KETTLE_HOME=D:/AAA/BBB/CCC 如上，表示把文件重新等位到D:/AAA/BBB/CCC这个文件夹下。(注意:文件夹的斜杠和WINDOWS的目录斜杠是反的） 复制 ${user.home} 文件夹下的 .kettle 文件夹到D:/AAA/BBB/CCC目录下。 启动kettle程序。 参考： Kettle日常使用汇总整理 Kettle使用统一的数据库配置 kettle学习笔记10—配置文件的使用 Kettle环境配置-kettle.properties部份配置: kettle配置作业、转换参考：Kettle—使用手册 在配置完成后,执行作业的方式有两种： 使用spoon.bat打开UI程序进行执行 优点：作业执行很稳定，不会异常退出。 缺点：吃内存，配置不高的服务器可能压力大。懂不懂1GB起步。😓 使用Kitchen.bat脚本执行作业 优点：可以结合windows的任务执行计划程序进行定时启动作业，占用内存少，完成后自动退出。 缺点：一些耗时长的任务会有闪退的情况，或者数据量太大，执行时只取了一部分，会造成数据丢失。 配置重抽作业的逻辑初始化时在作业里设置开始时间、结束时间变量值，执行转换前判断变量值，未到时间点，执行转换。执行一次转换后，更新变量，循环判断，实现重抽的需求。作业流程配置: 转换流程配置： 更新时间变量JavaScript代码： updatetime.js12345678910111213141516171819202122232425262728293031//Script here//var st =getVariable(\"StTime\",'2021-01-01')//var end =getVariable(\"End\",'2021-7-27')//Alert(\"st:\"+st+\"end:\"+end)var stDate =StTime;// str2date(st,'yyyy-MM-dd')var endDate =End;// str2date(end,'yyyy-MM-dd')if(stDate==null|| endDate==null) { //Alert(\"error\") false;}else{var diff = dateDiff(stDate,endDate,'d')var flag = false;if(diff&gt;=1){ var nextDate =dateAdd(stDate,'d',1); //Alert(\"next:\"+nextDate) var strDate=date2str(stDate,'yyyy-MM-dd'); var strNextDate = date2str(nextDate,'yyyy-MM-dd'); //setVariable(\"StTime\",strNextDate,‘p’) //Alert(\"开始时间:\"+strDate+\"结束时间:\"+strNextDate) return true}else {return false}} 定时启动无界面kettle任务使用CMD脚本+windows任务计划程序实现定时启动作业执行。耗时在2小时以内的作业可以使用脚本方式，执行时间长的作业最好使用spoon窗口程序执行，不会存在执行一半退出的情况。bat文件保存要按ANSI编码进行保存 Task.bat1234567891011121314@REM @echo off@REM if \"%1\" == \"h\" goto begin@REM mshta vbscript:createobject(\"wscript.shell\").run(\"%~nx0 h\",0)(window.close)&amp;&amp;exit@REM :begin:: Kitchen.bat所在路径盘符?D::: Kitchen.bat所在目录? ? ?cd D:\\PDI\\data-integration\\:: 作业（job）文件路径和日志文件路径:: 执行kitchen执行job，并写入日志Kitchen.bat /file:F:\\pdi-ce-9.1.0.0-324\\WorkSpace\\测试.kjb /level:Base &gt;F:\\pdi-ce-9.1.0.0-324\\Log Kitchen.bat参数详细说明：https://help.hitachivantara.com/Documentation/Pentaho/9.1/Products/Use_Command_Line_Tools_to_Run_Transformations_and_Jobs 参考资料Kettle系列教程-第一章kettle-数据同步比较数据（删除更新）Kettle之定时运行Jobkettle教程—kettle作业调度，根据更新时间增量更新Kettle实现循环增量抽取数据Learn About the PDI Client (Spoon)-官方文档Use Command Line Tools to Run Transformations and Jobs","link":"/2021/08/03/kettle%E5%A1%AB%E5%9D%91/"},{"title":"docker初识","text":"Docker容器与镜像的关系类似于面向对象编程中的对象与类。 Docker 面向对象 容器 对象 镜像 类 安装参考：Ubuntu Docker 安装 docker命令列出docker的命令帮助，在docker xx 后面 加上 --help 可以查看具体的命令用法和参数注解 cmd-help.sh1docker --help 创建镜像列出所有镜像： 1docker images -a 获取一个新的ubuntu 13.10版本镜像 1docker pull ubuntu:13.10 查找centos镜像 1docker search centos 删除ubuntu镜像 1docker rmi ubuntu 创建镜像1、从已经创建的容器中更新镜像，并且提交这个镜像2、使用 Dockerfile 指令来创建一个新的镜像 创建容器","link":"/2021/08/13/docker%E5%88%9D%E8%AF%86/"},{"title":"Dockerfile笔记","text":"","link":"/2021/08/14/Dockerfile%E7%AC%94%E8%AE%B0/"},{"title":"yapi-docker部署","text":"填坑docker images生成部署时。发现docker-entrypoint.sh没有初始化数据库，只有运行代码，没有添加初始化命令： npm run install-server //安装程序，初始化数据库索引和管理员账号，管理员账号名可在 config.json 配置` 补救措施： 123456[root@VM-4-16-centos /]# docker exec -it 2e43588c8b1f bashroot@2e43588c8b1f:/# node api/vendors/server/install.js (node:65) DeprecationWarning: current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.log: mongodb load success...初始化管理员账号成功,账号名：\"xxxxx@gmail.com\"，密码：\"ymfe.org\"","link":"/2021/08/14/yapi-docker%E9%83%A8%E7%BD%B2/"},{"title":"MongoDb初识","text":"https://www.cnblogs.com/my-blogs-for-everone/articles/9749842.html MongoDb 命令查询所有数据库列表 1show dbs 如果想查看当前连接在哪个数据库下面，可以直接输入dbdb 切换到test数据库下面use test 想查看test下有哪些表或者叫collection，可以输入show collections 想知道mongodb支持哪些命令，可以直接输入helphelp 想知道当前数据库支持哪些方法db.help(); 想知道当前数据库下的表或者表collection支持哪些方法，可以使用以下命令db.user.help(); user为表名 根据条件查找数据通过条件查询： db.foo.find( { x : 77 } , { name : 1 , x : 1 } ) 超级用户相关： #增加或修改用户密码 db.addUser('admin','pwd') #查看用户列表 db.system.users.find() #用户认证 db.auth('admin','pwd') #删除用户 db.removeUser('mongodb') #查看所有用户 show users #查看所有数据库 show dbs #查看所有的collection show collections #查看各collection的状态 db.printCollectionStats() #查看主从复制状态 db.printReplicationInfo() #修复数据库 db.repairDatabase() #设置记录profiling，0=off 1=slow 2=all db.setProfilingLevel(1) #查看profiling show profile #拷贝数据库 db.copyDatabase('mail_addr','mail_addr_tmp') #删除collection db.mail_addr.drop() #删除当前的数据库 db.dropDatabase() 客户端连接 /usr/local/mongodb/bin/mongo user_addr -u user -p 'pwd' 增删改 #存储嵌套的对象 db.foo.save({'name':'ysz','address':{'city':'beijing','post':100096},'phone':[138,139]}) #存储数组对象 db.user_addr.save({'Uid':'yushunzhi@sohu.com','Al':['test-1@sohu.com','test-2@sohu.com']}) #根据query条件修改，如果不存在则插入，允许修改多条记录 db.foo.update({‘yy’:5},{‘$set’:{‘xx’:2}},upsert=true,multi=true) #删除yy=5的记录 db.foo.remove({'yy':5}) #删除所有的记录 db.foo.remove() 索引 增加索引：1(ascending),-1(descending) db.things.ensureIndex({firstname: 1, lastname: 1}, {unique: true}); #索引子对象 db.user_addr.ensureIndex({'Al.Em': 1}) #查看索引信息 db.deliver_status.getIndexes() db.deliver_status.getIndexKeys() #根据索引名删除索引 db.user_addr.dropIndex(‘Al.Em_1’) 查询 查找所有 db.foo.find() #查找一条记录 db.foo.findOne() #根据条件检索10条记录 db.foo.find({'msg':'Hello 1'}).limit(10) #sort排序 db.deliver_status.find({'From':'yushunzhi@sohu.com'}).sort({'Dt',-1}) db.deliver_status.find().sort({'Ct':-1}).limit(1) #count操作 db.user_addr.count() #distinct操作 db.foo.distinct(‘msg’)#&gt;操作 db.foo.find({“timestamp”: {“$gte” : 2}}) #子对象的查找 db.foo.find({‘address.city’:’beijing’}) 管理 查看collection数据的大小 db.deliver_status.dataSize() #查看colleciont状态 db.deliver_status.stats() #查询所有索引的大小 db.deliver_status.totalIndexSize()","link":"/2021/09/01/MongoDb%E5%88%9D%E8%AF%86/"},{"title":"Markdown语法速查表","text":"## 总览 此 Markdown 语法速查表提供了所有 Markdown 语法元素的快速参考。但是此速查表无法涵盖所有极限用法，因此，如果您需要某些语法元素的详细信息，请参阅我们的 basic syntax 和 extended syntax 手册。 基本语法这些是 John Gruber 的原始设计文档中列出的元素。所有 Markdown 应用程序都支持这些元素。 元素 Markdown 语法 Heading # H1## H2### H3 Bold **bold text** Italic *italicized text* Blockquote &gt; blockquote Ordered List 1. First item 2. Second item 3. Third item Unordered List - First item - Second item - Third item Code `code` Horizontal Rule --- Link [title](https://www.example.com) Image ![alt text](image.jpg) 扩展语法这些元素通过添加额外的功能扩展了基本语法。但是，并非所有 Markdown 应用程序都支持这些元素。 Element Markdown Syntax Table | Syntax | Description | | ----------- | ----------- | | Header | Title | | Paragraph | Text | Fenced Code Block ``` { &nbsp;&nbsp;\"firstName\": \"John\", &nbsp;&nbsp;\"lastName\": \"Smith\", &nbsp;&nbsp;\"age\": 25 } ``` Footnote Here's a sentence with a footnote. [^1] [^1]: This is the footnote. Heading ID ### My Great Heading {#custom-id} Definition List term : definition Strikethrough ~~The world is flat.~~ Task List - [x] Write the press release - [ ] Update the website - [ ] Contact the media 下载你可以下载此速查表的 Markdown 源码文件，并在你自己的 Markdown 程序中使用。","link":"/2021/10/21/Markdown%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%E8%A1%A8/"},{"title":"sql server 中的数组和列表（转载）","text":"转载自：Arrays and Lists in SQL Server-The Short Version 原文摘录Two Simple Multi-Statement FunctionsIf you search the web, there is no end of functions to split strings into table format. Here, I will present two simple functions that run on SQL 2008 or later, one for a list of integers and one for a list of strings. I should immediately warn you that these functions are not the most efficient and therefore not suitable if you have long lists with thousands of elements. But they are perfectly adequate if you are passing the contents of a multi-choice checkbox from a client where you would rarely have as many as 50 elements. I opted to share these functions because they are simple and you can easily adapt them if you want different behaviour with regards to the choices that I have made. In my long article, I describe methods that are faster, but they all require extra setup than just a function. Below is a function to split a delimited list of integers. The function accepts a parameter for the delimiter which can be up to 10 characters long. The function returns the list positions for the elements. An empty element is returned as NULL. If there is a non-numeric value in the list, there will be a conversion error. sql12345678910111213141516171819202122CREATE FUNCTION intlist_to_tbl (@list nvarchar(MAX), @delim nvarchar(10)) RETURNS @tbl TABLE (listpos int NOT NULL IDENTITY(1,1), n int NULL) ASBEGIN DECLARE @pos int = 1, @nextpos int = 1, @valuelen int, @delimlen int = datalength(@delim) / 2 WHILE @nextpos &gt; 0 BEGIN SELECT @nextpos = charindex(@delim COLLATE Czech_BIN2, @list, @pos) SELECT @valuelen = CASE WHEN @nextpos &gt; 0 THEN @nextpos ELSE len(@list) + 1 END - @pos INSERT @tbl (n) VALUES (convert(int, nullif(substring(@list, @pos, @valuelen), ''))) SELECT @pos = @nextpos + @delimlen END RETURNEND You are likely to be puzzled by the COLLATE clause. This is a small speed booster. By forcing a binary collation, we avoid that SQL Server employs the full Unicode rules when searching for the delimiter. This pays off when scanning long strings. Why Czech? The language does not matter here, so I just picked one with a short name. And why datalength divided by 2 and not len? datalength returns the length in bytes, whence the division. len does not count trailing spaces, so it does not work if the delimiter is a space. Here are two examples: sql12SELECT * FROM intlist_to_tbl('1,2,3, 677,7 , ,-1', ',')SELECT * FROM intlist_to_tbl('1&lt;-&gt;2&lt;-&gt;3&lt;-&gt; 677&lt;-&gt;7&lt;-&gt;&lt;-&gt;-1', '&lt;-&gt;') Since the values are the same in both lists, the output is the same: listpos n 1 1 2 2 3 3 4 677 5 7 6 NULL 7 -1 Here is an example of how you would use it in a simple query: sql123SELECT ...FROM tbl WHERE col IN (SELECT n FROM intlist_to_tbl('1,2,3,4', ',')) If you find that you are only using comma-separated lists, you may grow tired of having to specify the delimiter every time. To that end, this wrapper can be handy: sql1234CREATE FUNCTION intlisttotbl (@list nvarchar(MAX)) RETURNS TABLE ASRETURN ( SELECT listpos, n FROM intlist_to_tbl(@list, ',')) I leave it as an exercise to the reader to come up with a better name. Here is a function for a list of strings. It accepts an input parameter of the type nvarchar(MAX), but the return table has both a varchar and an nvarchar column. I will return to why in a second. Like intlist_to_tbl it returns the list position. It trims leading and trailing spaces. In difference to intlist_to_tbl, empty elements are returned as empty strings and not as NULL. sql12345678910111213141516171819202122232425CREATE FUNCTION strlist_to_tbl (@list nvarchar(MAX), @delim nvarchar(10)) RETURNS @tbl TABLE (listpos int NOT NULL IDENTITY(1,1), str varchar(4000) NOT NULL, nstr nvarchar(4000) NOT NULL) ASBEGIN DECLARE @pos int = 1, @nextpos int = 1, @valuelen int, @nstr nvarchar(4000), @delimlen int = datalength(@delim) / 2 WHILE @nextpos &gt; 0 BEGIN SELECT @nextpos = charindex(@delim COLLATE Czech_BIN2, @list, @pos) SELECT @valuelen = CASE WHEN @nextpos &gt; 0 THEN @nextpos ELSE len(@list) + 1 END - @pos SELECT @nstr = ltrim(rtrim(substring(@list, @pos, @valuelen))) INSERT @tbl (str, nstr) VALUES (@nstr, @nstr) SELECT @pos = @nextpos + @delimlen END RETURNEND Here are two examples: sql12SELECT * FROM strlist_to_tbl(N'Alpha (α) | Beta (β)|Gamma (γ)|Delta (δ)|', '|')SELECT * FROM strlist_to_tbl(N'a///b///c///v///x', '///') Here is the output: listpos | str | nstr|:–:|:–:|:–:|1 | Alpha (a)| Alpha (α)2 | Beta (ß) | Beta (β)3 | Gamma (?)| Gamma (γ)4 | Delta (d)| Delta (δ)5 | | | listpos | str | nstr|:–:|:–:|:–:|1 | a | a2 | b | b3 | c | c4 | v | v5 | x | x Note in the first result set that the Greek characters has been replaced by fallback characters in the str column. They are unchanged in the nstr column. (If you have a Greek or a UTF-8 collation, the two columns will be identical, though.) Here are two examples of using this function: sql1234567SELECT ...FROM tbl WHERE varcharcol IN (SELECT str FROM strlist_to_tbl('a,b,c', ','))SELECT ...FROM tbl WHERE nvarcharcol IN (SELECT nstr FROM strlist_to_tbl('a,b,c', ',')) These examples illustrate why there are two columns. If you are going to use the list against a varchar column, you need to use the str column. This is important because of the type-conversion rules in SQL Server. If you mistakenly compare varcharcol to nstr, varcharcol will be converted to nvarchar, and this can render any index on varcharcol ineligible for the query, leading to a performance disaster as the table must be scanned. And conversely, if you have an nvarchar column, you need to compare it to the nvarchar value, since else the result can be incorrect because of the character replacement with the conversion to varchar. I like to point out that these functions are by no means cast in stone, but see them as suggestions. Feel free to modify them according to your preferences and needs.","link":"/2021/10/21/sqlserver%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"},{"title":"判断文件类型【一】","text":"现有一文件，其扩展名未知或标记错误。假设它是一个正常的、非空的文件，且将扩展名更正后可以正常使用，那么，如何判断它是哪种类型的文件？在后缀未知，或者后缀被修改的文件，依然通过文件头来判断该文件究竟是什么文件类型。 C#实现参考： example.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class MimeType{ private static readonly byte[] BMP = { 66, 77 }; private static readonly byte[] DOC = { 208, 207, 17, 224, 161, 177, 26, 225 }; private static readonly byte[] EXE_DLL = { 77, 90 }; private static readonly byte[] GIF = { 71, 73, 70, 56 }; private static readonly byte[] ICO = { 0, 0, 1, 0 }; private static readonly byte[] JPG = { 255, 216, 255 }; private static readonly byte[] MP3 = { 255, 251, 48 }; private static readonly byte[] OGG = { 79, 103, 103, 83, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0 }; private static readonly byte[] PDF = { 37, 80, 68, 70, 45, 49, 46 }; private static readonly byte[] PNG = { 137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82 }; private static readonly byte[] RAR = { 82, 97, 114, 33, 26, 7, 0 }; private static readonly byte[] SWF = { 70, 87, 83 }; private static readonly byte[] TIFF = { 73, 73, 42, 0 }; private static readonly byte[] TORRENT = { 100, 56, 58, 97, 110, 110, 111, 117, 110, 99, 101 }; private static readonly byte[] TTF = { 0, 1, 0, 0, 0 }; private static readonly byte[] WAV_AVI = { 82, 73, 70, 70 }; private static readonly byte[] WMV_WMA = { 48, 38, 178, 117, 142, 102, 207, 17, 166, 217, 0, 170, 0, 98, 206, 108 }; private static readonly byte[] ZIP_DOCX = { 80, 75, 3, 4 }; public static string GetMimeType(byte[] file, string fileName) { string mime = \"application/octet-stream\"; //DEFAULT UNKNOWN MIME TYPE //Ensure that the filename isn't empty or null if (string.IsNullOrWhiteSpace(fileName)) { return mime; } //Get the file extension string extension = Path.GetExtension(fileName) == null ? string.Empty : Path.GetExtension(fileName).ToUpper(); //Get the MIME Type if (file.Take(2).SequenceEqual(BMP)) { mime = \"image/bmp\"; } else if (file.Take(8).SequenceEqual(DOC)) { mime = \"application/msword\"; } else if (file.Take(2).SequenceEqual(EXE_DLL)) { mime = \"application/x-msdownload\"; //both use same mime type } else if (file.Take(4).SequenceEqual(GIF)) { mime = \"image/gif\"; } else if (file.Take(4).SequenceEqual(ICO)) { mime = \"image/x-icon\"; } else if (file.Take(3).SequenceEqual(JPG)) { mime = \"image/jpeg\"; } else if (file.Take(3).SequenceEqual(MP3)) { mime = \"audio/mpeg\"; } else if (file.Take(14).SequenceEqual(OGG)) { if (extension == \".OGX\") { mime = \"application/ogg\"; } else if (extension == \".OGA\") { mime = \"audio/ogg\"; } else { mime = \"video/ogg\"; } } else if (file.Take(7).SequenceEqual(PDF)) { mime = \"application/pdf\"; } else if (file.Take(16).SequenceEqual(PNG)) { mime = \"image/png\"; } else if (file.Take(7).SequenceEqual(RAR)) { mime = \"application/x-rar-compressed\"; } else if (file.Take(3).SequenceEqual(SWF)) { mime = \"application/x-shockwave-flash\"; } else if (file.Take(4).SequenceEqual(TIFF)) { mime = \"image/tiff\"; } else if (file.Take(11).SequenceEqual(TORRENT)) { mime = \"application/x-bittorrent\"; } else if (file.Take(5).SequenceEqual(TTF)) { mime = \"application/x-font-ttf\"; } else if (file.Take(4).SequenceEqual(WAV_AVI)) { mime = extension == \".AVI\" ? \"video/x-msvideo\" : \"audio/x-wav\"; } else if (file.Take(16).SequenceEqual(WMV_WMA)) { mime = extension == \".WMA\" ? \"audio/x-ms-wma\" : \"video/x-ms-wmv\"; } else if (file.Take(4).SequenceEqual(ZIP_DOCX)) { mime = extension == \".DOCX\" ? \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" : \"application/x-zip-compressed\"; } return mime; }} 资料：Mime-Detective 文件签名表格：GCK’S FILE SIGNATURES TABLE 参考资料：Magic numberList of file signatures","link":"/2021/12/01/%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"【C#】SqlBulkCopy实现SQLSRVER批量插入","text":"参考： SqlBulkCopy 类http://raylei.cn/index.php/archives/74/https://www.cxybb.com/article/weixin_30333885/96361368 问题 来自数据源的 Decimal 类型的给定值不能转换为指定目标列的类型 datetime 实际情况可能很复杂，使用的是泛型进行实体类转DataTable,可能会出现各种类型错误提示。 自己使用的是调用Copy()方法。 demo: demo.cs1234567891011121314151617var TableStruct = dal.GetTableStruct();DataTable dataTable = TableStruct.Clone();foreach (var item in oD.ToList&lt;StdYpkcday&gt;()){ DataRow dataRow = dataTable.NewRow(); dataRow[\"id\"] = DBNull.Value;//自增主键。赋值DBNull.Value dataRow[\"code\"] = item.Hoscode; if (item.Gqsj == null ) { dataRow[\"time\"] = DBNull.Value; } else { dataRow[\"time\"] = item.Gqsj; } dataTable.Rows.Add(dataRow);} 参考：https://stackoverflow.com/questions/18140012/sqlbulkcopy-the-given-value-of-type-string-from-the-data-source-cannot-be-conv Demo删除并批量插入.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/// &lt;summary&gt;/// 删除并批量插入/// &lt;/summary&gt;/// &lt;param name=\"_Type\"&gt;&lt;/param&gt;/// &lt;param name=\"TableName\"&gt;批量插入数据的表名&lt;/param&gt;/// &lt;param name=\"Dt\"&gt;批量插入的数据&lt;/param&gt;/// &lt;param name=\"SqlDeleteText\"&gt;删除的sql语句&lt;/param&gt;public void DeleteAndBulkCopy(string Type,string TableName, DataTable Dt, string SqlDeleteText,bool isIncreaPK){ using (SqlConnection conn = new SqlConnection(DBUtility.DbCommon.GetConnectString(Type))) { conn.Open(); using (SqlTransaction transaction = conn.BeginTransaction()) { SqlCommand sqlcom = conn.CreateCommand(); sqlcom.Transaction = transaction; sqlcom.CommandText = SqlDeleteText; var BulkCopyOptions = SqlBulkCopyOptions.KeepIdentity; //自增主键，使用系统生成主键 if (isIncreaPK) { BulkCopyOptions = SqlBulkCopyOptions.Default; } using (SqlBulkCopy bulk = new SqlBulkCopy(conn, BulkCopyOptions, transaction)) { if (Dt.Rows.Count &gt; 0) { for (int i = 0; i &lt; Dt.Columns.Count; i++) { bulk.ColumnMappings.Add(Dt.Columns[i].ColumnName, Dt.Columns[i].ColumnName); } bulk.BatchSize = Dt.Rows.Count; bulk.DestinationTableName = TableName; } try { sqlcom.ExecuteNonQuery(); bulk.WriteToServer(Dt); transaction.Commit(); } catch (Exception ex) { transaction.Rollback(); } finally { bulk.Close(); conn.Close(); } } } }} 批量更新.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#region 批量更新/// &lt;summary&gt;/// 批量更新/// &lt;/summary&gt;/// &lt;param name=\"dataTable\"&gt;&lt;/param&gt;/// &lt;param name=\"crateTemplateSql\"&gt;/// eg:/// [xxx] varchar(255) NOT NULL,[xxx] varchar(10) NOT NULL/// &lt;/param&gt;/// &lt;param name=\"updateSql\"&gt;/// eg:/// UPDATE bulktest set bulktest.name=Temp.tempname /// FROM bulktest INNER JOIN #TmpTable Temp /// ON Temp.temprdn = bulktest.rdn ; /// DROP TABLE #TmpTable/// &lt;/param&gt;public void SqlBulkCopyUpdate(DataTable dataTable, string crateTemplateSql, string updateSql){ using (SqlConnection conn = new SqlConnection(DBUtility.DbCommon.GetConnectString(DBType))) { using (var command = new SqlCommand(\"\", conn)) { try { conn.Open(); //数据库并创建一个临时表来保存数据表的数据 command.CommandText = $\" CREATE TABLE #TmpTable ({crateTemplateSql})\"; command.ExecuteNonQuery(); //使用SqlBulkCopy 加载数据到临时表中 using (var bulkCopy = new SqlBulkCopy(conn)) { foreach (DataColumn dcPrepped in dataTable.Columns) { bulkCopy.ColumnMappings.Add(dcPrepped.ColumnName, dcPrepped.ColumnName); } bulkCopy.BulkCopyTimeout = 660; bulkCopy.DestinationTableName = \"#TmpTable\"; bulkCopy.WriteToServer(dataTable); bulkCopy.Close(); } // 执行Command命令 使用临时表的数据去更新目标表中的数据 然后删除临时表 command.CommandTimeout = 300; command.CommandText = updateSql; int rows = command.ExecuteNonQuery(); } catch(Exception ex) { throw ex; } finally { conn.Close(); } } }}#endregion","link":"/2021/12/11/SqlBulkCopy%E5%AE%9E%E7%8E%B0SQLSRVER%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/"},{"title":"redis初识","text":"Windows安装Redis下载地址：https://github.com/tporadowski/redis 部署为服务命令行进入安装目录/解压目录 安装服务: redis-server.exe –service-install redis.windows.conf –loglevel verbose 卸载服务：redis-server –service-uninstall 开启服务：redis-server –service-start 停止服务：redis-server –service-stop 重命名服务：redis-server –service-name name 以下将会安装并启动三个不同的Redis实例作服务： 1234567891011redis-server --service-install --service-name redisService1 --port 10001redis-server --service-start --service-name redisService1redis-server --service-install --service-name redisService2 --port 10002redis-server --service-start --service-name redisService2redis-server --service-install --service-name redisService3 --port 10003redis-server --service-start --service-name redisService3","link":"/2022/01/05/redis%E5%88%9D%E8%AF%86/"},{"title":"【Csharp】Thread匿名方法初识","text":"片段代码笔记 12345678910111213141516171819202122232425262728293031323334353637383940414243/// &lt;summary&gt;/// 停止创建运行新任务和新线程，等待所有任务和线程执行完成。/// &lt;/summary&gt;private void StopRuningTaskOrThreadAndExitOrRestart(bool restartFlag){ timer1.Enabled = false;//停止触发 if (switchstr == \"1\" &amp;&amp; threadswitchstr == \"1\") { Thread t = new Thread((flag) =&gt; { while (threadUseNum &gt; 0) { Thread.Sleep(5000); RefreshMsgBox(DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\") + $\"\\t=&gt;\\t等待子任务执行完成退出：子任务数量：{threadUseNum}\"); } if ((bool)flag) { Process.Start(Application.ExecutablePath); } Environment.Exit(0); }); t.IsBackground = true; t.Start(restartFlag); } else if (switchstr == \"1\") { Thread t = new Thread((flag) =&gt; { if (taskThread != null) { taskThread.Wait();//等待执行完成 } if ((bool)flag) { Process.Start(Application.ExecutablePath); } Environment.Exit(0); }); t.IsBackground = true; t.Start(restartFlag); }}","link":"/2022/01/06/%E3%80%90Csharp%E3%80%91Thread%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E5%88%9D%E8%AF%86/"},{"title":"VUE初识","text":"","link":"/2022/02/14/VUE%E5%88%9D%E8%AF%86/"},{"title":"你好，世界","text":"欢迎来到[Hexo](https://hexo.io/)! 这是你的第一篇文章。 查看[文档](https://hexo.io/docs/) 以获取更多信息。如果您在使用Hexo时遇到任何问题，可以在[故障排除](https://hexo.io/docs/troubleshooting.html)中找到答案, 者您可以在[GitHub](https://github.com/hexojs/hexo/issues)上询问我。 快速开始创建一个新帖子1$ hexo new \"My New Post\" 更多信息： 写作 运行服务器1$ hexo server 更多信息：服务器 生成静态文件1$ hexo generate 更多信息：生成 部署到远程站点1$ hexo deploy 更多信息：部署","link":"/2019/06/30/hello-world/"},{"title":"测试","text":"Welcome to my Blog ! this is a test article ,This blog is built using Hexo and the theme is Minos theme .","link":"/2019/03/19/%E6%B5%8B%E8%AF%95/"},{"title":"记录第一次搭建Blog","text":"花了两天把我想了两年的事情给解决了 ## 起因 &nbsp;&nbsp;&nbsp;&nbsp;早就在学校读书时就想搭建一个记录生活的Blog,迫于自己比较懒（ 其实是游戏太好玩😑）,一直没有动手。然后从今年一月份开始实习后，遭受了社会太多的毒打😶,经历的一些事情让我很想找个地方记录下来，加之最近工作闲下来的时候在学习怎么用Github,用GitHub Page搭建Blog无疑是个很好的机会。于是我搭建了这个blog——一个记录生活，偶尔记录技术🙃的博客。 经过 在百度后，照着网上的教程一步步照着做下来，博客花了不到两天就这么搭好了（内心OS:😕这么简单，我为啥拖了这么久）。在搭建过程中也有出现一些小问题，在开始的时候让我无语的是在_config.yml中，配置项的值都需要和字段空一格😑： 错误:theme:minos 正确：theme: minos 。最后Blog使用Hexo+Minos+GitHub Pages搭建完成。 搭建参照： 使用Hexo+Github一步步搭建属于自己的博客（基础）使用Hexo+Github一步步搭建属于自己的博客（进阶）Github Pages和Hexo简明教程用Hexo+Github+Coding搭建静态博客（一） 配置插件和样式参照： Hexo文档讲解（二）Hexo安装和配置API和一些小部件（四） 主题的配置参照： 配置Minos主题自定义（三） Markdown语法和Minos支持的语法参照： Minos Markdown在线编辑markdownMarkdown 语法手册 效果： Thoughts搭建一个可以记录自己生活的地方是我从16年就想做的事，但是一直到了19年才实现。(我是不是太拖了🙃)不过还好，我终于搭建起了这个Blog虽然是静态的。想起来自己最初想搭建Blog也只是想找个类似树洞一样的地方倾述。没想到现在实现了，却突然没有那么多话想写下来。心里有点失落，不过好在自己以后也有吐槽的地方了，很好😝","link":"/2019/03/20/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BABlog/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"},{"name":"emoji","slug":"emoji","link":"/tags/emoji/"},{"name":"live2d","slug":"live2d","link":"/tags/live2d/"},{"name":"记录","slug":"记录","link":"/tags/%E8%AE%B0%E5%BD%95/"},{"name":"软件版本号","slug":"软件版本号","link":"/tags/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7/"},{"name":"-ASP.Net MVC","slug":"ASP-Net-MVC","link":"/tags/ASP-Net-MVC/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Mail","slug":"Mail","link":"/tags/Mail/"},{"name":"发送邮件","slug":"发送邮件","link":"/tags/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"name":"ASP.NET","slug":"ASP-NET","link":"/tags/ASP-NET/"},{"name":"System.Net.Mail","slug":"System-Net-Mail","link":"/tags/System-Net-Mail/"},{"name":"邮件发送","slug":"邮件发送","link":"/tags/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"},{"name":"吐槽","slug":"吐槽","link":"/tags/%E5%90%90%E6%A7%BD/"},{"name":"感想","slug":"感想","link":"/tags/%E6%84%9F%E6%83%B3/"},{"name":"负能量","slug":"负能量","link":"/tags/%E8%B4%9F%E8%83%BD%E9%87%8F/"},{"name":"Technology","slug":"Technology","link":"/tags/Technology/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Oracle","slug":"Oracle","link":"/tags/Oracle/"},{"name":"教育","slug":"教育","link":"/tags/%E6%95%99%E8%82%B2/"},{"name":"成长","slug":"成长","link":"/tags/%E6%88%90%E9%95%BF/"},{"name":"命令行","slug":"命令行","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Gmail","slug":"Gmail","link":"/tags/Gmail/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"Postman","slug":"Postman","link":"/tags/Postman/"},{"name":"sqlserver","slug":"sqlserver","link":"/tags/sqlserver/"},{"name":"死锁","slug":"死锁","link":"/tags/%E6%AD%BB%E9%94%81/"},{"name":"树洞","slug":"树洞","link":"/tags/%E6%A0%91%E6%B4%9E/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"SQLlite","slug":"SQLlite","link":"/tags/SQLlite/"},{"name":"kettle","slug":"kettle","link":"/tags/kettle/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"速查表","slug":"速查表","link":"/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"},{"name":"ADO.NET","slug":"ADO-NET","link":"/tags/ADO-NET/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"搭建Blog","slug":"搭建Blog","link":"/tags/%E6%90%AD%E5%BB%BABlog/"}],"categories":[{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"转载","slug":"转载","link":"/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"other","slug":"other","link":"/categories/other/"},{"name":"LifeStyle","slug":"LifeStyle","link":"/categories/LifeStyle/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"VUE","slug":"VUE","link":"/categories/VUE/"},{"name":"lifeStyle","slug":"lifeStyle","link":"/categories/lifeStyle/"}]}