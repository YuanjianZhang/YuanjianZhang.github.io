{"posts":[{"title":"你好，世界","text":"欢迎来到Hexo! 这是你的第一篇文章。 查看文档 以获取更多信息。如果您在使用Hexo时遇到任何问题，可以在故障排除中找到答案, 者您可以在GitHub上询问我。 快速开始创建一个新帖子1$ hexo new \"My New Post\" 更多信息： 写作 运行服务器1$ hexo server 更多信息：服务器 生成静态文件1$ hexo generate 更多信息：生成 部署到远程站点1$ hexo deploy 更多信息：部署","link":"/2019/03/19/hello-world/"},{"title":"测试","text":"Welcome to my Blog ! this is a test article ,This blog is built using Hexo and the theme is Minos theme .","link":"/2019/03/19/%E6%B5%8B%E8%AF%95/"},{"title":"记录第一次搭建Blog","text":"花了两天把我想了两年的事情给解决了 前言 早就在学校读书时就想搭建一个记录生活的Blog,迫于自己比较懒（ 其实是游戏太好玩😑）,一直没有动手。然后从今年一月份开始实习后，遭受了社会太多的毒打😶,经历的一些事情让我很想找个地方记录下来，加之最近工作闲下来的时候在学习怎么用Github,用GitHub Page搭建Blog无疑是个很好的机会。于是我搭建了这个blog——一个记录生活，偶尔记录技术🙃的博客。 经过 在百度后，照着网上的教程一步步照着做下来，博客花了不到两天就这么搭好了（内心OS:😕这么简单，我为啥拖了这么久）。在搭建过程中也有出现一些小问题，在开始的时候让我无语的是在_config.yml中，配置项的值都需要和字段空一格😑： 错误:theme:minos 正确：theme: minos 。最后Blog使用Hexo+Minos+GitHub Pages搭建完成。 搭建参照： 使用Hexo+Github一步步搭建属于自己的博客（基础）使用Hexo+Github一步步搭建属于自己的博客（进阶）Github Pages和Hexo简明教程用Hexo+Github+Coding搭建静态博客（一） 配置插件和样式参照： Hexo文档讲解（二）Hexo安装和配置API和一些小部件（四） 主题的配置参照： 配置Minos主题自定义（三） Markdown语法和Minos支持的语法参照： Minos Markdown在线编辑markdownMarkdown 语法手册 效果： Thoughts搭建一个可以记录自己生活的地方是我从16年就想做的事，但是一直到了19年才实现。(我是不是太拖了🙃)不过还好，我终于搭建起了这个Blog虽然是静态的。想起来自己最初想搭建Blog也只是想找个类似树洞一样的地方倾述。没想到现在实现了，却突然没有那么多话想写下来。心里有点失落，不过好在自己以后也有吐槽的地方了，很好😝 参考 https://segmentfault.com/a/1190000009544924https://www.jianshu.com/p/b7886271e21ahttps://my.oschina.net/ryaneLee/blog/638440https://www.cnblogs.com/fengxiongZz/p/7707219.htmlhttps://www.jianshu.com/p/57e22584b277https://sm.ms/https://www.simon96.online/2018/10/12/hexo-tutorial/https://theme-next.iissnan.com/faqs.htmlhttps://segmentfault.com/a/1190000009544924#articleHeader23Hexo 更换电脑重新部署","link":"/2019/03/20/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BABlog/"},{"title":"在hexo上添加Live 2D看板娘","text":"博客美化—给Hexo博客添加萌萌的康娜（Kanna） 前言 在逛V站时，看到了一个帖子，然后就被她的看板娘吸引，但是想我也算是有Blog的人(虽然才刚建)，我是不是也可以弄一个呢，说干就干，立马开始捣鼓起来。 过程开始 因为看板娘在WordPress、Typecho、Typecho等用户群体大的博客上应用广泛，所以Live2d 看板娘在WordPress这些博客上能被更好的应用，在网上找的的教程大部分也是关于WordPress等的教程，所以我自己也是懵懵懂懂的去实现这个功能，这篇文章仅记录过程。 经过 在查看下列几篇文章后,开始动手搭建 在Hexo博客上添加可爱的Live 2D模型hexo 添加live2d看板动画 安装模块 hexo博客根目录选择cmd命令窗口或者git bash 输入以下代码，安装插件 1npm install --save hexo-helper-live2d 下载模型1npm install live2d-widget-model-shizuku 配置 打开个人Hexo博客文件根目录下的 _config.yml 文件，在最后添加一下代码 _config.yml12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true再打开cmd键入hexo g -d 就大功告成了😁🎉🎉🎉 DIY资料 资源模型插件:hexo-helper-live2d模型插件作者各种模型包展示hexo模型插件作者各种模型包合集Live2d模型资源：梦象-Live2D 模型资源收集站 适用于WordPress、Typecho、Typecho等强烈推荐：为你的博客博客/网页添加Live2d二次元老婆的插件/手动方法给博客添加能动的看板娘(Live2D)-关于模型的二三事网页添加 Live2D 看板娘","link":"/2019/03/25/%E5%9C%A8hexo%E4%B8%8A%E6%B7%BB%E5%8A%A0Live-2D/"},{"title":"在hexo文章里使用emoji🤔","text":"记录如何然hexo文章支持emojiHexo 默认的 markdown 渲染引擎不支持将 Github emoji 渲染到静态的 html 页面中，我们换一个支持 emoji 的引擎，再增加一个 emoji 插件即可.","link":"/2019/03/25/%E5%9C%A8hexo%E6%96%87%E7%AB%A0%E9%87%8C%E4%BD%BF%E7%94%A8emoji/"},{"title":"各种软件版本号的含义","text":"今天在逛spring的文档repo时， 常见软件版本编辑软件版本：包含两种不同含义（1）为满足不同用户的不同使用要求，如适用于不同运行环境或不同平台的系列产品。（2）软件产品投入使用以后，经过一段时间运行提出了变更的要求，需要做较大的修正或纠错，增强功能或提高性能。 Alpha版（内部测试版）：Alpha版本通常会送交到开发软件的组织或社群中的各个软件测试者，用作内部测试。在市场上，越来越多公司会邀请外部的客户或合作伙伴参与其软件的Alpha测试阶段。这令软件在此阶段有更大的可用性测试。在测试的第一个阶段中，开发者通常会进行白盒测试。其他测试会在稍后时间由其他测试团体以黑盒或灰盒技术进行，不过有时会同时进行。 Beta版（外部测试版）：软件开发公司为对外宣传，将非正式产品免费发送给具有典型性的用户，让用户测试该软件的不足之处及存在问题，以便在正式发行前进一步改进和完善 。一般可通过Internet免费下载，也可以向软件公司索取。Beta版本是第一个对外公开的软件版本，是由公众参与的测试阶段。一般来说，Beta包含所有功能，但可能有一些已知问题和较轻微的臭虫（Bug）。Beta版本的测试者通常是开发软件的组织的客户，他们会以免费或优惠价钱得到软件，但会成为组织的免费测试者。Beta版本主要测试产品的支援和市场反应（在邀请Beta用户时）等。 Demo版（演示版）：主要是演示正式软件的部分功能，用户可以从中得知软件的基本操作，为正式产品的发售扩大影响。如果是游戏的话，则只有一两个关卡可以玩。该版本也可以从Internet上免费下载。Enhanced版（增强版或加强版）：如果是一般软件，一般称作“增强版”，会加入一些实用的新功能。如果是游戏，一般称作“加强版”，会加入一些新的游戏场景和游戏情节等。这是正式发售的版本。 Free版（自由版）：这一般是个人或自由软件联盟组织的成员制作的软件，希望免费给大家使用，没有版权，一般也是通过Internet免费下载。Full Version版（完全版）：也就是正式版，是最终正式发售的版本。 Shareware版（共享版）：有些公司为了吸引客户，对于他们制作的某些软件，可以让用户通过Internet免费下载的方式获取。不过，此版本软件多会带有一些使用时间或次数的限制，但可以利用在线注册或电子注册成为正式版用户。 Release版（发行版）：稳定的发行版，可从Internet上免费下载。Release Candidate（简称RC）指可能成为最终产品的版本，如果没有再出现问题则可释出正式版本。在此阶段，产品包含所有功能亦不会出现严重问题。通常此阶段的产品是接近完整的。微软公司很多时会使用此名称。在1990年代，苹果电脑把在这阶段的产品称为“Golden Master”，而最后的Golden Master为正式版本。这阶段亦称Gamma（更后期的称为Delta，及其后的希腊字母）。 Upgrade版（升级版）：当你有某个软件以前的正式版本时，可以购买升级版，将你的软件升级为最新版。升级后的软件与正式版在功能上相同，但价格会低些，这主要是为了给原有的正版用户提供优惠。 Retail版 零售版，一般只针对个人的功能不是很全的版本，价格比较低，升级时间也有限制。Cardware版 属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。Plus版 属增强版，不过这种大部分是在程序界面及多媒体功能上增强。Preview版 预览版，软件作者为了满足那些对新版本很关注的人，发布的可以看到大部分功能的测试软件。Corporation &amp; Enterprise版 企业版，只针对企业发布的全功能版本，价格比较昂贵，服务非常齐全。Standard版 标准版，软件商推荐大家使用的版本，这种版本一般比较稳定，BUG少。Mini版 迷你版也叫精简版只有最基本的功能，为那些想节省硬盘空间或者不追求华丽的人准备的。Premium——超值版Professional——专业版Express——简易版（比如Outlook express 和outlook 相比，前者更精简；Sql Server Express版表示免费精简版）Deluxe——豪华版Regged——已注册版CN——简体中文版CHT——繁体中文版EN——英文版Multilanguage——多语言版Rip 是指从原版文件（一般是指光盘或光盘镜像文件）直接将有用的内容（核心内容）分离出来，剔除无用的文档，例如PDF说明文件啊，视频演示啊之类的东西，也可以算做是精简版吧…但主要内容功能是一点也不能缺少的！另：DVDrip是指将视频和音频直接从DVD光盘里以文件方式分离出来。trial 试用版（含有某些限制，如时间、功能，注册后也有可能变为正式版）RC 版 是 Release Candidate 的缩写，意思是发布倒计时，该版本已经完成全部功能并清除大部分的BUG。到了这个阶段只会除BUG，不会对软件做任何大的更改。RTM 版 这基本就是最终的版本，英文是 Release To Manufacture，意思是发布到生产商。版本号编辑V（Version）即版本，通常用数字表示版本号。（如：EVEREST Ultimate v4.20.1188 Beta） Build：用数字或日期标示版本号的一种方式。（如：VeryCD eMule v0.48a Build 071112）SP：Service Pack，升级包。（如：WindowsXP SP2/Vista SP1）授权和功能划分： Trial：试用版，通常都有时间限制，有些试用版软件还在功能上做了一定的限制。可注册或购买成为正式版Unregistered未注册版，通常没有时间限制，在功能上相对于正式版做了一定的限制。可注册或购买成为正式版。Demo：演示版，仅仅集成了正式版中的几个功能，不能升级成正式版。Lite：精简版。Full version：完整版，属于正式版。 语言划分编辑SC：Simplified Chinese简体中文版。CN：简体中文版GBK：简体中文汉字内码扩展规范版。TC：Traditional Chinese繁体中文版。CHT：繁体中文版BIG5：繁体中文大五码版。EN：英文版Multilanguage：多语言版UTF8： Unicode Transformation Format 8 bit，对现有的中文系统不是好的解决方案。 开发阶段划分编辑α（Alpha）版：内测版，内部交流或者专业测试人员测试用。Bug较多，普通用户最好不要安装。β（Beta）版：公测版，专业爱好者大规模测试用，存在一些缺陷，该版本也不适合一般用户安装。γ（Gamma）版：相当成熟的测试版，与即将发行的正式版相差无几。RC版：Release Candidate。RC版。是Release Candidate的缩写，意思是发布倒计时，候选版本，处于Gamma阶段，该版本已经完成全部功能并清除大部分的BUG。到了这个阶段只会除BUG，不会对软件做任何大的更改。从Alpha到Beta再到Gamma是改进的先后关系，但RC1、RC2往往是取舍关系。SR版：Service Release的缩写，修正版或更新版，修正了正式版推出后发现的Bug。Final版：正式版。 其他版本编辑Enhance：增强版或者加强版，属于正式版Free：自由版（免费版）Release：发行版Upgrade：升级版Retail：零售版Cardware：属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。/SPlus：属增强版，不过这种大部分是在程序界面及多媒体功能上增强。Preview：预览版Corporation&amp;Enterprise：企业版Standard：标准版Mini：迷你版也叫精简版只有最基本的功能Professional/pro：专业版Express：特别版Deluxe： 豪华版Regged：已注册版Rip： 是指从原版文件（一般是指光盘或光盘镜像文件）直接将有用的内容（核心内容）分离出来，剔除无用的文档，例如PDF说明文件啊，视频演示啊之类的东西，也可以算做是精简版吧…但主要内容功能是一点也不能缺少的！另：DVDrip是指将视频和音频直接从DVD光盘里以文件方式分离出来。RTM：这基本就是最终的版本，英文是Release To Manufactur，意思是发布到生产商。OEM：Original Equipment Manufacturer，是给电脑生产厂的版本，软件发行商于电脑生产厂家的定制版本。FPP：Full Packaged Product（FPP）/Retail，就是零售版（盒装软件），这种产品的光盘的卷标都带有“FPP”字样，比如英文WXP Pro的FPP版本的光盘卷标就是WXPFPP_EN，其中WX表示是Windows XP，P是Professional（H是Home），FPP表明是零售版本，EN是表明是英语。获得途径除了在商店购买之外，某些MSDN用户也可以得到。VOL：Volume Licensing for Organizations（VLO），团体批量许可证（大量采购授权合约），这是为团体购买而制定的一种优惠方式。这种产品的光盘的卷标都带有“VOL”字样，取“Volume”前3个字母，以表明是批量，比如英文WXP Pro的VOL版本的光盘卷标就是WXPVOL_EN，其中WX表示是Windows XP，P是Professional（VOL没有Home版本），VOL表明是团体批量许可证版本，EN是表明是英语。获得途径主要是集团购买，某些MSDN用户也可以得到。","link":"/2019/03/26/%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/"},{"title":"只是一个普通人","text":"","link":"/2019/04/08/%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E4%BA%BA/"},{"title":"ASP.Net MVC action 同时支持Get和Post","text":"项目中遇到一个action，有post和get请求，特此记录方法：在action 上加上 AcceptVerbs标签: 12[AcceptVerbs(HttpVerbs.Get | HttpVerbs.Post)]public ActionResult Index() 转自：https://blog.csdn.net/Helloantoherday/article/details/85007344","link":"/2019/04/10/ASP-Net-MVC-action-%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81Get%E5%92%8CPost/"},{"title":"C#邮件发送问题","text":"转自：C#邮件发送问题（一）C#邮件发送问题（二）","link":"/2019/04/10/CSharp%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98/"},{"title":"ASP.NET发送电子邮件【C#】","text":"本文转载自-https://www.cnblogs.com/Jeremy2001/p/6870175.html，侵删。 1.补充知识 （1）POP3和SMTP服务器是什么？ 简单点来说：POP3 用于接收电子邮件 ，SMTP 用于发送电子邮件。 （1）POP3具体指什么？ POP3(Post Office Protocol 3)即邮局协议的第3个版本，它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。它是因特网电子邮件的第一个离线协议标准，POP3协议允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上，同时根据客户端的操作删除或保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。POP3协议是TCP/IP协议族中的一员，,由RFC 1939 定义 （2）SMTP具体是指什么？ SMTP的全称是”Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。 2.System.Net.Mail 使用ASP.NET发送电子邮件，需要引用System.Net.Mail命名空间。System.Net.Mail 命名空间包含用于将电子邮件发送到简单邮件传输协议 (SMTP) 服务器进行传送的类。 （1）命名空间下有三个比较主要的类： MailMessage:提供属性和方法来创建一个邮件消息对象，即邮件内容。 Attachment:提供属性和方法来创建一个邮件附件对象，即邮件附件。 SmtpClient:将电子邮件传输到您指定用于邮件传送的 SMTP 主机。 （2）MailMessage类： From：发送邮件的地址To：接收邮件的地址Subject：邮件的标题Priority：邮件的优先级（分别为为High,Low,Normal）Attachments：电子邮件的数据的附件集合Bcc：密送地址Cc：抄送地址Body：邮件正文SubjectEncoding：电子邮件的主题内容使用的编码 IsBodyHtml：邮件正文是否为 Html 格式的值 详细参考：MailMessage （3）Attachment类： 详细参考：Attachment （4）SmtpClient类： DeliveryMethod：指定如何处理待发的电子邮件 Host：SMTP 事务的主机的名称或 IP 地址 Credentials：设置用于验证发件人身份的凭据 详细参考：SmtpClient 3.ASP.NET发送邮件两种方式 （1）通过邮件服务提供商的SMTP来发送邮件 首先需要注册对应服务提供商免费邮箱，因为你要使用邮件服务提供商的SMTP，他们需要对身份进行验证，这样可以避免产生大量的垃圾邮件。 有三个是重要的信息：SMTP服务器、用户名、密码。从网上收集了几个类，可以参考下。 123456789101112131415161718192021222324252627282930313233343536373839#region/// &lt;summary&gt;/// 发送邮件/// &lt;/summary&gt;/// &lt;param name=\"mailTo\"&gt;要发送的邮箱&lt;/param&gt;/// &lt;param name=\"mailSubject\"&gt;邮箱主题&lt;/param&gt;/// &lt;param name=\"mailContent\"&gt;邮箱内容&lt;/param&gt;/// &lt;returns&gt;返回发送邮箱的结果&lt;/returns&gt;public static bool SendEmail(string mailTo,string mailSubject,string mailContent){ // 设置发送方的邮件信息,例如使用网易的smtp string smtpServer = \"smtp.163.com\"; //SMTP服务器 string mailFrom = \"XXX@163.com\"; //登陆用户名 string userPassword = \"XXX\";//登陆密码 // 邮件服务设置 SmtpClient smtpClient=new SmtpClient(); smtpClient.DeliveryMethod = SmtpDeliveryMethod.Network;//指定电子邮件发送方式 smtpClient.Host = smtpServer; //指定SMTP服务器 smtpClient.Credentials = new System.Net.NetworkCredential(mailFrom, userPassword);//用户名和密码 // 发送邮件设置 MailMessage mailMessage = new MailMessage(mailFrom, mailTo); // 发送人和收件人 mailMessage.Subject = mailSubject;//主题 mailMessage.Body = mailContent;//内容 mailMessage.BodyEncoding = Encoding.UTF8;//正文编码 mailMessage.IsBodyHtml = true;//设置为HTML格式 mailMessage.Priority = MailPriority.Low;//优先级 try { smtpClient.Send(mailMessage); // 发送邮件 return true; } catch (SmtpException ex) { return false; }}2）利用本机的SMTP虚拟服务器的SMTP来发送邮件 需要进行SMTP配置，还是第一种简单实用。 4.参考资料：常用邮件服务器 gmail.com:POP3服务器地址:pop.gmail.comSMTP服务器地址:smtp.gmail.com qq.com: POP3服务器地址:pop.qq.comSMTP服务器地址:smtp.qq.com 163.com:POP3服务器地址:pop.163.comSMTP服务器地址:smtp.163.com sina.com: POP3服务器地址:pop3.sina.com.cnSMTP服务器地址:smtp.sina.com.cn yahoo.com:POP3服务器地址:pop.mail.yahoo.comSMTP服务器地址:smtp.mail.yahoo.com sohu.com:POP3服务器地址:pop3.sohu.comSMTP服务器地址:smtp.sohu.com china.com:POP3服务器地址:pop.china.comSMTP服务器地址:smtp.china.com 21cn.com:POP3服务器地址:pop.21cn.comSMTP服务器地址:smtp.21cn.com sina.com: 实例下载","link":"/2019/04/11/ASP.NET%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E3%80%90CSharp%E3%80%91/"},{"title":"突发奇想：对于人类进化的优胜劣汰","text":"最近实习越来越发现自己","link":"/2019/04/16/%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%EF%BC%9A%E5%AF%B9%E4%BA%8E%E4%BA%BA%E7%B1%BB%E8%BF%9B%E5%8C%96%E7%9A%84%E4%BC%98%E8%83%9C%E5%8A%A3%E6%B1%B0/"},{"title":"彻底清除Github上某个文件的历史（对于误传密码等隐私信息等情况）","text":"Removing sensitive data from a repository","link":"/2019/04/26/%E5%BD%BB%E5%BA%95%E6%B8%85%E9%99%A4Github%E4%B8%8A%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%88%E5%AF%B9%E4%BA%8E%E8%AF%AF%E4%BC%A0%E5%AF%86%E7%A0%81%E7%AD%89%E9%9A%90%E7%A7%81%E4%BF%A1%E6%81%AF%E7%AD%89%E6%83%85%E5%86%B5%EF%BC%89/"},{"title":"Asp.net MVC在Razor中输出Html的两种方式","text":"Razor中所有的Html都会自动编码，这样就不需要我们手动去编码了（安全），但在需要输出Html时就是已经转义过的Html文本了，如下所示： 1234@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\";}@thisTest; 这样在页面输出的文本就是：&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;而不是红色的字体了，要输出红色的字体，有下面常用的两种方式： 1、使用Razor中的Html.Raw（推荐使用这种方式）： 1234@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\";}@Html.Raw(thisTest); 2、使用MvcHtmlString类来实现： 12345@{ string thisTest = \"&lt;span style='color:red;'&gt;测试文字&lt;/span&gt;\"; var thisResult = new MvcHtmlString(thisTest);}@thisResult 或 @(new HtmlString(thisTest))","link":"/2019/05/07/Asp-net-MVC%E5%9C%A8Razor%E4%B8%AD%E8%BE%93%E5%87%BAHtml%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"jQuery的Ajax的dataType设置问题","text":"在Asp.Net MVC的前台页面使用Ajax获取数据，当Ajax方法中设置了dataType: \"json\"后，Ajax无法使用data.ret的方式处理数据。Controller.Json Method (Object)Json(Object) 方法返回的是继承自System.Object的类型值System.Web.Mvc.JsonResult在前台获取到的是object，而不是json字符串 http://www.cnblogs.com/zhangcybb/p/6604380.htmlhttps://docs.microsoft.com/en-us/previous-versions/aspnet/dd504936%28v%3dvs.100%29#see-alsohttps://docs.microsoft.com/en-us/previous-versions/aspnet/dd504936%28v%3dvs.100%29https://docs.microsoft.com/zh-cn/previous-versions/aspnet/dd470569%28v%3dvs.100%29https://www.cnblogs.com/fire-dragon/p/5889400.html","link":"/2019/05/09/jQuery%E7%9A%84Ajax%E7%9A%84dataType%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"},{"title":"SQL语句使用技巧","text":"记录一下自己在使用PL/SQL的编写SQL语句的注意点和技巧 记录工作中遇到的在统计一张数据表中一个数据类型为Char(2) 的字段的值为空的数量时，使用 `select count(1) from table1 where EHR_PAT_GEN = ''`，查询出的结果为0（数据库中数据已经确认有空的）。 然后将语句换成`select count(1) from table1 where EHR_PAT_GEN &lt;&gt; ''`执行后，结果仍然为0，然后查询数据表，发现不为空的的数据为数字时，使用`select count(1) from table1 where EHR_PAT_GEN &gt; 0`查出该字段不为空的数据量。然后百度到char类型是","link":"/2019/05/20/SQL%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"对当今教育的一些感想","text":"今天是2019年5月24日，工作了一段时间后，逐渐发现","link":"/2019/05/24/%E5%AF%B9%E5%BD%93%E4%BB%8A%E6%95%99%E8%82%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/"},{"title":"&#39;nginx缓存页面+cookie后-串会话问题&#39;","text":"https://blog.csdn.net/clevercode/article/details/75145258","link":"/2019/05/31/nginx%E7%BC%93%E5%AD%98%E9%A1%B5%E9%9D%A2-cookie%E5%90%8E-%E4%B8%B2%E4%BC%9A%E8%AF%9D%E9%97%AE%E9%A2%98/"},{"title":"终究还是毕业了","text":"","link":"/2019/06/05/%E7%BB%88%E7%A9%B6%E8%BF%98%E6%98%AF%E6%AF%95%E4%B8%9A%E4%BA%86/"},{"title":"hexo指令列表","text":"为了方便使用hexo，将一些hexo指令记录下来 hexo指令 hexo 提示 hexo 官方文档 Hexo起步安装（-g为全局安装） 1npm install hexo -g 升级（-g为全局升级） 1npm update hexo -g 初始化，生成文件夹为blog 1hexo init blog 安装依赖库 1npm install 简写hexo n \"我的博客\"== hexo new \"我的博客\" #新建文章hexo p== hexo publish #将草稿帖子从_drafts移动到_posts文件夹。hexo g== hexo generate#生成hexo s== hexo server #启动服务预览hexo d == hexo deploy#部署hexo s -g == hexo server --generate#生成静态页面并启动服务预览 生成静态网页后部署到GitHub上 两个命令的作用是相同的hexo g -d == hexo generate --deployhexo d -g == hexo deploy --generate 模板hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate --watch #监视文件变动 hexo提示在CMD中输入hexo help后，获得的命令行列表 1234567891011121314151617181920212223用法: hexo &lt;command&gt;Commands: clean 删除生成的文件和缓存。 config 获取或设置配置 deploy 部署你的网站。 可简写成 `hexo d` generate 生成静态文件。 可简写成 `hexo g` help 获取有关命令的帮助。 init 创建一个新的Hexo文件夹。 list 列出网站的信息 migrate 将您的站点从其他系统迁移到Hexo。 new 创建一个新帖子。 可简写成 `hexo n` publish 将草稿帖子从_drafts移动到_posts文件夹。 render 使用渲染器插件渲染文件。 server 启动服务器。 可简写成 `hexo s` version 显示版本信息。全局选项: --config 指定配置文件而不是使用_config.yml --cwd 指定CWD --debug 显示终端中的所有详细消息 --draft 显示草稿帖子 --safe 禁用所有插件和脚本 --silent 隐藏控制台上的输出 官方文档的一些指令init1hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new1hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1hexo new \"post title with whitespace\" generate1hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 该命令可以简写为 1hexo g publish1hexo publish [layout] &lt;filename&gt; 发表草稿。 server1hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 deploy1hexo deploy 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 该命令可以简写为： 1hexo d render1hexo render &lt;file1&gt; [file2] ... 渲染文件。 参数 描述 -o, --output 设置输出路径 migrate1hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1hexo list &lt;type&gt; 列出网站资料。 version1hexo version 显示 Hexo 版本。 选项安全模式1hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式1hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式1hexo --silent 隐藏终端信息。 自定义配置文件的路径1hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿1hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD1hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。","link":"/2019/06/12/hexo%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A8/"},{"title":"a标签的target的用法","text":"记录一下今天在学习项目时遇到的一个低级问题🙃 HTML&lt;a&gt;标签的target属性 参考地址：http://www.w3school.com.cn/tags/att_a_target.asp 定义和用法&lt;a&gt; 标签的 target 属性规定在何处打开链接文档。 如果在一个 &lt;a&gt; 标签内包含一个 target 属性，浏览器将会载入和显示用这个标签的 href 属性命名的、名称与这个目标吻合的框架或者窗口中的文档。如果这个指定名称或 id 的框架或者窗口不存在，浏览器将打开一个新的窗口，给这个窗口一个指定的标记，然后将新的文档载入那个窗口。从此以后，超链接文档就可以指向这个新的窗口。 打开新窗口 被指向的超链接使得创建高效的浏览工具变得很容易。例如，一个简单的内容文档的列表，可以将文档重定向到一个单独的窗口： 12&lt;a href=\"https://www.bing.com\" target=\"view_window\"&gt;打开一个新的窗口，显示必应的首页HTML文档&lt;/a&gt;&lt;a href=\"https://www.baidu.com\" target=\"view_window\"&gt;在已经打开的窗口上，将必应的文档取代。显示百度的首页HTML文档&lt;/a&gt; 打开一个新的窗口，指向必应的新窗口 在已经打开的窗口上，将必应的文档取代。显示百度的首页HTML文档 当用户第一次选择内容列表中的某个链接时，浏览器将打开一个新的窗口，将它标记为 “view_window”，然后在其中显示希望显示的文档内容。如果用户从这个内容列表中选择另一个链接，且这个 “view_window” 仍处于打开状态，浏览器就会再次将选定的文档载入那个窗口，取代刚才的那些文档。 在整个过程中，这个包含了内容列表的窗口是用户可以访问的。通过单击窗口中的一个连接，可使另一个窗口的内容发生变化。 在框架中打开窗口不用打开一个完整的浏览器窗口，使用 target 更通常的方法是在一个 &lt;frameset&gt; 显示中将超链接内容定向到一个或者多个框架中。可以将这个内容列表放入一个带有两个框架的文档的其中一个框架中，并用这个相邻的框架来显示选定的文档： 12&lt;frame name=\"view\" src=\"\"&gt;&lt;a href=\"https://bing.com\" target=\"view\"&gt;在右边窗口打开必应首页&lt;/a&gt; 在右边窗口打开必应首页在右边窗口打开一张图片 语法1&lt;a target=&quot;value&quot;&gt; 属性值 值 描述 _blank 在新窗口中打开被链接文档。 _self 默认。在相同的框架中打开被链接文档。 _parent 在父框架集中打开被链接文档。 _top 在整个窗口中打开被链接文档。 framename 在指定的框架中打开被链接文档。 特殊的目标有 4 个保留的目标名称用作特殊的文档重定向操作： _blank浏览器总在一个新打开、未命名的窗口中载入目标文档。 _self这个目标的值对所有没有指定目标的 &lt;a&gt; 标签是默认目标，它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的，除非和文档标题 &lt;base&gt; 标签中的 target 属性一起使用。 _parent这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。 _top这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。 提示：这些 target 的所有 4 个值都以下划线开始。任何其他用一个下划线作为开头的窗口或者目标都会被浏览器忽略，因此，不要将下划线作为文档中定义的任何框架 name 或 id 的第一个字符。","link":"/2019/06/24/a%E6%A0%87%E7%AD%BE%E7%9A%84target%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"在Gmail地址上填个加号","text":"本文转载自：在Gmail地址上填个加号 在Gmail地址上填个加号 我在使用Gmail邮箱时，还有一个很好的功能经常用到，那就是给电子邮件地址填上“+”。给别人发邮件的时候，在自己Gmail邮箱地址上添加一个“+”，这种方法可以自动过滤掉那些未必是垃圾邮件却由于来自不同的邮箱而难以过滤的电子邮件。 考虑一下网上购物时的情况。你买东西的每一个网站都想留下你的电子邮件地址，以便给你发送货款收据、送货通知之类信息。不过可以肯定，它们也会利用你提供的邮件地址向你发送打折票券、促销信息之类内容，甚至发送垃圾邮件。由于来自这些网站的邮件可能包含有关你购买产品的重要信息，因此把这些网站加入垃圾邮件的黑名单并不是一个好的解决办法。此外，这些邮件可能来自多个邮箱（当然都出自同一个网站），因而难以事先预知，也不容易设置过滤条件。另一方面，你又不愿意让电子商务网站发送的垃圾邮件充斥自己的邮箱。 在这种情况下，你可以有别的选择。你可以针对每一个购物公司创建一个电子邮箱。这个办法效率不高，容易造成混乱，而且也会占用别人想用的邮箱地址。其实你不必这么办，只要在Gmail邮箱地址后面填个加号就可以了。 操作要领如下：如果你的Gmail邮箱地址是yourname@gmail.com，提供给购物网站的邮箱就可以是yourname+shopping@gmail.com，无须开设新的电子邮箱。 接下来，你可以设置过滤条件，把所有发向yourname+shopping@gmail.com的邮件自动存档。通过这种操作，所有来自电子商务网站的邮件会自动从当前收件箱中转移出去，成为Gmail邮箱里的历史邮件。结果，那些邮件就不会分散你的注意力，也不会让你恼怒，因为眼不见心不烦。然而，当你搜索邮件或者查看收件箱的时候，这些邮件都还在。另一个办法是，你可以给所有发向yourname+shopping@gmail.com的邮件自动加上诸如“购物”之类的标签。然后可以根据需要，对与电子商务活动有关的邮件进行查看或归类。 所有这些办法的关键是什么呢？对于你想看或不想看的邮件，这是一种简单易行的自动化组织方式。“+”是一个自动过滤器，马上就能作用于所有的网上购物邮件，需要你做的不过是设置一下而已。","link":"/2019/06/25/%E5%9C%A8Gmail%E5%9C%B0%E5%9D%80%E4%B8%8A%E5%A1%AB%E4%B8%AA%E5%8A%A0%E5%8F%B7/"},{"title":"XML文档笔记（一）","text":"转载自： https://www.cnblogs.com/catgatp/p/6403382.html &lt;![CDATA[]]&gt;和转义字符被&lt;![CDATA[]]&gt;这个标记所包含的内容将表示为纯文本，比如&lt;![CDATA[&lt;]]&gt;表示文本内容“&lt;”。 此标记用于xml文档中，我们先来看看使用转义符的情况。我们知道，在xml中，”&lt;”、”&gt;”、”&amp;”等字符是不能直接存入的，否则xml语法检查时会报错，如果想在xml中使用这些符号，必须将其转义为实体，如”&lt;”、”&gt;”、”&amp;”，这样才能保存进xml文档。 在使用程序读取的时候，解析器会自动将这些实体转换回”&lt;”、”&gt;”、”&amp;”。举个例子： &lt;age&gt; age &lt; 30 &lt;/age&gt; 上面这种写法会报错，应该这样写： &lt;age&gt; age&amp;lt;30 &lt;/age&gt; 值得注意的是： (1)转义序列字符之间不能有空格； (2) 转义序列必须以”;”结束； (3) 单独出现的”&amp;”不会被认为是转义的开始； (4) 区分大小写。 在XML中，需要转义的字符有： (1)&amp; &amp;amp; (2)&lt; &amp;lt; (3)&gt; &amp;gt; (4)＂ &amp;quot; (5)＇ &amp;apos; 但是严格来说，在XML中只有”&lt;”和”&amp;”是非法的，其它三个都是可以合法存在的，但是，把它们都进行转义是一个好的习惯。 不管怎么样，转义前的字符也好，转义后的字符也好，都会被xml解析器解析，为了方便起见，使用&lt;![CDATA[]]&gt;来包含不被xml解析器解析的内容。但要注意的是： (1) 此部分不能再包含”]]&gt;”； (2) 不允许嵌套使用； (3)”]]&gt;”这部分不能包含空格或者换行。 最后，说说&lt;![CDATA[]]&gt;和xml转移字符的关系，它们两个看起来是不是感觉功能重复了？ 是的，它们的功能就是一样的，只是应用场景和需求有些不同： (1)&lt;![CDATA[]]&gt;不能适用所有情况，转义字符可以； (2) 对于短字符串&lt;![CDATA[]]&gt;写起来啰嗦，对于长字符串转义字符写起来可读性差； (3) &lt;![CDATA[]]&gt;表示xml解析器忽略解析，所以更快。","link":"/2019/07/02/XML%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"为什么一到毕业就要经历生离死别","text":"","link":"/2019/07/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%88%B0%E6%AF%95%E4%B8%9A%E5%B0%B1%E8%A6%81%E7%BB%8F%E5%8E%86%E7%94%9F%E7%A6%BB%E6%AD%BB%E5%88%AB/"},{"title":"使用Postman测试SOAP接口","text":"使用Postman发出SOAP请求我们知道它说的是Postman“REST”客户端，但这并不意味着我们不能将其用于发出SOAP请求。通过执行以下简单步骤，可以轻松地使用Postman发出任何HTTP SOAP请求： 链接地址Making SOAP requests using PostmanPostman makes SOAP requests too","link":"/2019/10/25/%E4%BD%BF%E7%94%A8Postman%E6%B5%8B%E8%AF%95SOAP%E6%8E%A5%E5%8F%A3/"},{"title":"sqlserver查询使用with(nolock)","text":"sqlserver中，一张表会因为频繁的进行select、delete、insert操作而导致死锁。 记录一次数据库死锁在自己负责的一个业务中，有一张表因为会进行频繁的select、delete、insert。导致报了死锁的错：检验结果存储失败：事务(进程 ID 56)与另一个进程被死锁在 锁 | 通信缓冲区 资源上，并且已被选作死锁牺牲品。请重新运行该事务。SQL:delete LIS_RESULT_CG where JYLSH=’************’ 参考文章 select死锁问题sqlserver查询使用with(nolock)详解WITH(NOLOCK)与WITH(READPAST)共享锁（S锁）和排它锁（X锁）SQL SERVER SELECT语句中加锁选项的详细说明","link":"/2019/11/18/sqlserver%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8with-nolock/"},{"title":"前台加密3DES-C#后台解密","text":"js的3des加解密和c#.net后台解密 Des-3DesDemo C# 3Des加密解密 前台使用cryptojs加密解密时，一定要注意。方法会自动处理key，以凑齐24位。（key不足24位自动以0(最小位数是0)补齐,如果多余24位,则截取前24位,后面多余则舍弃掉） 但C#生成是是允许使用16位字符和24位字符加密的。具体参考：3DES将16位秘钥升级为24位 按3DES规范要求，的确其秘钥应该是24位而不是16位的，但16位秘钥可以按 前8位+后8位+前8位 的规则来升级成24位的秘钥。所以C#的key实际上也是24位，它将16位的key转换成了24位。服了，真是个大坑","link":"/2019/12/05/%E5%89%8D%E5%8F%B0%E5%8A%A0%E5%AF%863DES-CSharp%E5%90%8E%E5%8F%B0%E8%A7%A3%E5%AF%86/"},{"title":"关于json.stringfy不兼容ie8操作","text":"IE低版本 JSON.parse 和stringify 的兼容 （IE8以下）解决IE8以下低版本实现JSON.parse()与JSON.stringify()的兼容关于 json.stringfy不兼容ie8操作","link":"/2019/12/10/%E5%85%B3%E4%BA%8Ejson-stringfy%E4%B8%8D%E5%85%BC%E5%AE%B9ie8%E6%93%8D%E4%BD%9C/"},{"title":"SQL语句中的N&#39;xxxx&#39;是什么意思","text":"SQL语句中的N’xxxx’是什么意思我们在一些sql存储过程,触发器等中经常会见到类似 N’xxxx’ 是什么意思? 例如: 1234if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[sp_getProByIdAndName]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)drop procedure [dbo].[sp_getProByIdAndName]REPLACE(@pstrin, N'''', N'''''') Answer: N’xxx’ 标识将单引号中的xxx强制转换为Unicode编码的字符,不用在中文情况下会出现乱码. 因为在英文中常用的是ASCII码(一个字符占一个字节),而我们用的中文一个汉字就要占两个字节所以要用N’xxx’强制转换为Unicode编码的字符,这样单引号中不管是英文字符还是汉字一个都占两个字节,统一起来,不会出现乱码! 转载： https://www.cnblogs.com/wanshutao/p/4128016.html","link":"/2020/06/01/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84N-xxxx-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"},{"title":"拖延症的改善(一)","text":"拖延症在意识到拖延症已经严重影响到了生活后，我开始尝试改善这个十几年的毛病。 养成一个小习惯改善拖延症，尝试过制定每天的行程，通过闹钟严格控制自己。刚开始的时候确实有成效，但都坚持不了几周，自己慢慢失去动力。这种方式的中，人是被动的。 健身 拖延一个很简单只需要花费几分钟的动作，在坚持一到两天就能看到效果，或者感受到效果。这会给与我一个很强大的正反馈。付出和收获反馈很及时，这会在一定程度上，促使我主动去做，以为在我潜意识里只要我今天做了这个动作，我明天身体的某块地方就会改变，并且能被我感受到，捕捉到这个变化，一个很健康的正反馈循环会是我转守为攻，自己会监督自己去每天做这个动作。它在很大程度上改善了我的拖延。 这样的习惯养成后，能改善我自身的思维和心态。它会促使我潜意识觉得，每天坚持做一些事情，是会有益与我的，自身能接受的付出和收获的间隔长度也会慢慢变长。 健身改善了我的生活。 [EOF]","link":"/2020/08/07/%E6%8B%96%E5%BB%B6%E7%97%87%E7%9A%84%E6%94%B9%E5%96%84-%E4%B8%80/"},{"title":"最近感受到的压力","text":"","link":"/2020/09/10/%E6%9C%80%E8%BF%91%E6%84%9F%E5%8F%97%E5%88%B0%E7%9A%84%E5%8E%8B%E5%8A%9B/"},{"title":"转载—数据库锁的概念","text":"锁的概述一. 为什么要引入锁多个用户同时对数据库的并发操作时会带来以下数据不一致的问题: 丢失更新A,B两个用户读同一数据并进行修改,其中一个用户的修改结果破坏了另一个修改的结果,比如订票系统 脏读A用户修改了数据,随后B用户又读出该数据,但A用户因为某些原因取消了对数据的修改,数据恢复原值,此时B得到的数据就与数据库内的数据产生了不一致 不可重复读A用户读取数据,随后B用户读出该数据并修改,此时A用户再读取数据时发现前后两次的值不一致 并发控制的主要方法是封锁,锁就是在一段时间内禁止用户做某些操作以避免产生数据不一致 二 锁的分类锁的类别有两种分法： 从数据库系统的角度来看：分为独占锁（即排它锁），共享锁和更新锁 MS-SQL Server 使用以下资源锁模式。 锁模式描述:共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。更新 (U) 用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。排它 (X) 用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。意向锁 用于建立锁的层次结构。意向锁的类型为：意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。架构锁 在执行依赖于表架构的操作时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)。大容量更新 (BU) 向表中大容量复制数据并指定了 TABLOCK 提示时使用。共享锁共享 (S) 锁允许并发事务读取 (SELECT) 一个资源。资源上存在共享 (S) 锁时，任何其它事务都不能修改数据。一旦已经读取数据，便立即释放资源上的共享 (S) 锁，除非将事务隔离级别设置为可重复读或更高级别，或者在事务生存周期内用锁定提示保留共享 (S) 锁。 更新锁更新 (U) 锁可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享 (S) 锁，然后修改行，此操作要求锁转换为排它 (X) 锁。如果两个事务获得了资源上的共享模式锁，然后试图同时更新数据，则一个事务尝试将锁转换为排它 (X) 锁。共享模式到排它锁的转换必须等待一段时间，因为一个事务的排它锁与其它事务的共享模式锁不兼容；发生锁等待。第二个事务试图获取排它 (X) 锁以进行更新。由于两个事务都要转换为排它 (X) 锁，并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。 若要避免这种潜在的死锁问题，请使用更新 (U) 锁。一次只有一个事务可以获得资源的更新 (U) 锁。如果事务修改资源，则更新 (U) 锁转换为排它 (X) 锁。否则，锁转换为共享锁。 排它锁排它 (X) 锁可以防止并发事务对资源进行访问。其它事务不能读取或修改排它 (X) 锁锁定的数据。 意向锁意向锁表示 SQL Server 需要在层次结构中的某些底层资源上获取共享 (S) 锁或排它 (X) 锁。例如，放置在表级的共享意向锁表示事务打算在表中的页或行上放置共享 (S) 锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它 (X) 锁。意向锁可以提高性能，因为 SQL Server 仅在表级检查意向锁来确定事务是否可以安全地获取该表上的锁。而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。 意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。 锁模式 描述意向共享 (IS) 通过在各资源上放置 S 锁，表明事务的意向是读取层次结构中的部分（而不是全部）底层资源。意向排它 (IX) 通过在各资源上放置 X 锁，表明事务的意向是修改层次结构中的部分（而不是全部）底层资源。IX 是 IS 的超集。与意向排它共享 (SIX) 通过在各资源上放置 IX 锁，表明事务的意向是读取层次结构中的全部底层资源并修改部分（而不是全部）底层资源。允许顶层资源上的并发 IS 锁。例如，表的 SIX 锁在表上放置一个 SIX 锁（允许并发 IS 锁），在当前所修改页上放置 IX 锁（在已修改行上放置 X 锁）。虽然每个资源在一段时间内只能有一个 SIX 锁，以防止其它事务对资源进行更新，但是其它事务可以通过获取表级的 IS 锁来读取层次结构中的底层资源。 独占锁：只允许进行锁定操作的程序使用，其他任何对他的操作均不会被接受。执行数据更新命令时，SQL Server会自动使用独占锁。当对象上有其他锁存在时，无法对其加独占锁。共享锁：共享锁锁定的资源可以被其他用户读取，但其他用户无法修改它，在执行Select时，SQL Server会对对象加共享锁。更新锁：当SQL Server准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到SQL Server确定要进行更新数据操作时，他会自动将更新锁换为独占锁，当对象上有其他锁存在时，无法对其加更新锁。 从程序员的角度看：分为乐观锁和悲观锁。乐观锁：完全依靠数据库来管理锁的工作。悲观锁：程序员自己管理数据或对象上的锁处理。 MS-SQLSERVER 使用锁在多个同时在数据库内执行修改的用户间实现悲观并发控制 三 锁的粒度锁粒度是被封锁目标的大小,封锁粒度小则并发性高,但开销大,封锁粒度大则并发性低但开销小 SQL Server支持的锁粒度可以分为为行、页、键、键范围、索引、表或数据库获取锁 资源 描述RID 行标识符。用于单独锁定表中的一行。键 索引中的行锁。用于保护可串行事务中的键范围。页 8 千字节 (KB) 的数据页或索引页。扩展盘区 相邻的八个数据页或索引页构成的一组。表 包括所有数据和索引在内的整个表。DB 数据库。 四 锁定时间的长短锁保持的时间长度为保护所请求级别上的资源所需的时间长度。 用于保护读取操作的共享锁的保持时间取决于事务隔离级别。采用 READ COMMITTED 的默认事务隔离级别时，只在读取页的期间内控制共享锁。在扫描中，直到在扫描内的下一页上获取锁时才释放锁。如果指定 HOLDLOCK 提示或者将事务隔离级别设置为 REPEATABLE READ 或 SERIALIZABLE，则直到事务结束才释放锁。 根据为游标设置的并发选项，游标可以获取共享模式的滚动锁以保护提取。当需要滚动锁时，直到下一次提取或关闭游标（以先发生者为准）时才释放滚动锁。但是，如果指定 HOLDLOCK，则直到事务结束才释放滚动锁。 用于保护更新的排它锁将直到事务结束才释放。如果一个连接试图获取一个锁，而该锁与另一个连接所控制的锁冲突，则试图获取锁的连接将一直阻塞到： 将冲突锁释放而且连接获取了所请求的锁。 连接的超时间隔已到期。默认情况下没有超时间隔，但是一些应用程序设置超时间隔以防止无限期等待 五 SQL Server 中锁的自定义1 处理死锁和设置死锁优先级 死锁就是多个用户申请不同封锁,由于申请者均拥有一部分封锁权而又等待其他用户拥有的部分封锁而引起的无休止的等待 可以使用SET DEADLOCK_PRIORITY控制在发生死锁情况时会话的反应方式。如果两个进程都锁定数据，并且直到其它进程释放自己的锁时，每个进程才能释放自己的锁，即发生死锁情况。 2 处理超时和设置锁超时持续时间。 @@LOCK_TIMEOUT 返回当前会话的当前锁超时设置，单位为毫秒 SET LOCK_TIMEOUT 设置允许应用程序设置语句等待阻塞资源的最长时间。当语句等待的时间大于 LOCK_TIMEOUT 设置时，系统将自动取消阻塞的语句，并给应用程序返回”已超过了锁请求超时时段”的 1222 号错误信息 示例下例将锁超时期限设置为 1,800 毫秒。SET LOCK_TIMEOUT 1800 设置事务隔离级别。 4 ) 对 SELECT、INSERT、UPDATE 和 DELETE 语句使用表级锁定提示。 配置索引的锁定粒度可以使用 sp_indexoption 系统存储过程来设置用于索引的锁定粒度 六 查看锁的信息1 执行 EXEC SP_LOCK 报告有关锁的信息2 查询分析器中按Ctrl+2可以看到锁的信息 七 使用注意事项如何避免死锁1 使用事务时，尽量缩短事务的逻辑处理过程，及早提交或回滚事务；2 设置死锁超时参数为合理范围，如：3分钟-10分种；超过时间，自动放弃本次操作，避免进程悬挂；3 优化程序，检查并避免死锁现象出现；4 .对所有的脚本和SP都要仔细测试，在正是版本之前。5 所有的SP都要有错误处理（通过@error）6 一般不要修改SQL SERVER事务的默认级别。不推荐强行加锁 解决问题 如何对行 表 数据库加锁 八 几个有关锁的问题1 如何锁一个表的某一行 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED SELECT * FROM table ROWLOCK WHERE id = 1 2 锁定数据库的一个表 SELECT * FROM table WITH (HOLDLOCK) 加锁语句：sybase:update 表 set col1=col1 where 1=0 ;MSSQL:select col1 from 表 (tablockx) where 1=0 ;oracle:LOCK TABLE 表 IN EXCLUSIVE MODE ；加锁后其它人不可操作，直到加锁用户解锁，用commit或rollback解锁 几个例子帮助大家加深印象设table1(A,B,C)A B Ca1 b1 c1a2 b2 c2a3 b3 c3 1）排它锁新建两个连接在第一个连接中执行以下语句begin tranupdate table1set A=’aa’where B=’b2’waitfor delay ‘00:00:30’ –等待30秒commit tran在第二个连接中执行以下语句 1234begin tran select * from table1 where B='b2' commit tran 若同时执行上述两个语句，则select查询必须等待update执行完毕才能执行即要等待30秒 2）共享锁在第一个连接中执行以下语句 12345begin tran select * from table1 holdlock -holdlock人为加锁 where B='b2' waitfor delay '00:00:30' --等待30秒 commit tran 在第二个连接中执行以下语句 1234567begin tran select A,C from table1 where B='b2' update table1 set A='aa' where B='b2' commit tran 若同时执行上述两个语句，则第二个连接中的select查询可以执行而update必须等待第一个事务释放共享锁转为排它锁后才能执行 即要等待30秒 3）死锁 1234增设table2(D,E) D E d1 e1 d2 e2 在第一个连接中执行以下语句 123456789begin tran update table1 set A='aa' where B='b2' waitfor delay '00:00:30' update table2 set D='d5' where E='e1' commit tran 在第二个连接中执行以下语句 123456789begin tran update table2 set D='d5' where E='e1' waitfor delay '00:00:10' update table1 set A='aa' where B='b2' commit tran 同时执行，系统会检测出死锁，并中止进程 补充一点:Sql Server2000支持的表级锁定提示 HOLDLOCK 持有共享锁，直到整个事务完成，应该在被锁对象不需要时立即释放，等于SERIALIZABLE事务隔离级别 NOLOCK 语句执行时不发出共享锁，允许脏读 ，等于 READ UNCOMMITTED事务隔离级别 PAGLOCK 在使用一个表锁的地方用多个页锁 READPAST 让sql server跳过任何锁定行，执行事务，适用于READ UNCOMMITTED事务隔离级别只跳过RID锁，不跳过页，区域和表锁 ROWLOCK 强制使用行锁 TABLOCKX 强制使用独占表级锁，这个锁在事务期间阻止任何其他事务使用这个表 UPLOCK 强制在读表时使用更新而不用共享锁 应用程序锁:应用程序锁就是客户端代码生成的锁，而不是sql server本身生成的锁 处理应用程序锁的两个过程 sp_getapplock 锁定应用程序资源 sp_releaseapplock 为应用程序资源解锁 注意: 锁定数据库的一个表的区别 123SELECT * FROM table WITH (HOLDLOCK) 其他事务可以读取表，但不能更新删除 SELECT * FROM table WITH (TABLOCKX) 其他事务不能读取表,更新和删除","link":"/2020/11/27/%E8%BD%AC%E8%BD%BD%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5/"},{"title":"CMD start command","text":"by SRINI Start command可用于在另一个命令窗口中运行command/batch（批处理文件）或从命令行启动应用程序。您可以在下面找到该命令的语法和一些示例。 启动另一个命令窗口： 1start cmd 该命令将打开一个新的命令提示符窗口。 在单独的窗口中运行命令 1Start command 该命令将打开一个新的命令窗口，并运行指定的命令。如果命令是GUI应用程序，则将在没有任何新命令窗口的情况下启动该应用程序。 例子：启动新的命令窗口并运行dir命令： 1Start dir 在另一个窗口中运行命令，并在命令执行后终止： 1234567start cmd /c command````例如，要在另一个命令窗口中运行批处理文件并在批处理文件执行完成后关闭该窗口，命令将为：``` CMDStart cmd /c C:\\mybatchfile.bat 在同一窗口中运行命令： 1Start /b command 像在Linux中使用”&amp;”一样，在后台运行命令： 在Windows中，我们可以使用start命令执行类似的操作。但是在这里它不是在后台运行的。一个新的命令窗口将执行指定的命令，而当前窗口将返回以提示执行下一个命令。 123Start command(or)Start batchfile.bat 启动GUI应用程序： 1Start application 例如，要启动Chrome，我们可以使用以下命令: 1Start Chrome 在当前目录中打开Windows资源管理器：: 1start .","link":"/2021/05/07/CMD-Start-Command/"},{"title":"2020人口普查随笔","text":"男女比例的不平衡，以及人口出生率的降低，感觉一定程度上可以使用进化论的来解释。从古至今，人类都存在淘汰，野人时期，身体素质不够高，打不到足够的猎物就是饿死，到了封建时期，第一看投胎，第二就看自己够不够努力（只看生存能力,坑蒙拐骗也算本领）。而到了现在也是如此，第一看投胎，第二看自身。自古如此，人类的基因也在随着时间的变化而被筛选，更能适应社会的，能够获取到异性的注意力的人，他们的基因将会更好的流传下去，而一些从经济、思想、为人上无法获取到异性的青睐时，他们的基因从某种意义上来讲，也算是被自然所淘汰。 没钱的人只能单身","link":"/2021/05/11/2020%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5%E9%9A%8F%E7%AC%94/"},{"title":"一句话","text":"自己下定决心到达成某个目标时，不要和别人说，等自己完成后再说","link":"/2021/05/17/%E4%B8%80%E5%8F%A5%E8%AF%9D/"},{"title":"C#设置程序开机自启动[需登录]","text":"写在前面本来是想在服务器上实现服务器崩溃或者更新后，可以自动启动winform程序，但是以下方法还是需要有用户登录进去。 方法一：将软件的快捷方式创建到计算机的自动启动目录下（不需要管理员权限） 进入目录：C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 将应用程序快捷方式剪切(或者复制)并粘贴到目录中 应用程序快捷方式加入到了启动项，下次重启电脑之后这个应用程序就会自动开机运行了 如果需要针对个人账户进行配置：Win+R输入命令shell:startup ,会直接弹出启动项对应的目录，然后像前面方法一样把应用程序快捷方式复制到启动目录 方法二：修改计算机注册表的方式（需要管理员权限）开始Windows自启动原理在Windows操作系统下，主要有2个文件夹和8个注册表键项控制程序的自启动，通过修改“Run”键值实现自启动程序是比较常见的方法。具体的位置是：HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Run 参考资料： Windows程序自启动原理 代码在知道注册表中自启动位置所在后，只需要将需要启动的程序路径添加至指定路径中就可以实现开机自启动功能。 Program.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/// &lt;summary&gt;/// 应用程序的主入口点。/// &lt;/summary&gt;[STAThread]static void Main(){ Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); string appGuid = ((GuidAttribute)Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(GuidAttribute), false).GetValue(0)).Value; using (Mutex mutex = new Mutex(false, \"Global\\\\\" + appGuid)) { if (!mutex.WaitOne(0, false)) { return; } //判断是否开启自启动 string strFilePath = Application.ExecutablePath; string strFileName = System.IO.Path.GetFileName(strFilePath); try { //自启动功能是否开启 var AutoRunFlag = ConfigurationManager.AppSettings[\"AutoRunFlag\"] == \"1\" ? true : false; //自启动是否已经存在 var flag = SystemHelper.IsAutoRun(strFilePath, strFileName); if (AutoRunFlag != flag) { #region 获取管理员权限，进行注册表写入操作 //当前用户是管理员的时候，直接启动应用程序并且写入注册表 //如果不是管理员，则使用启动对象启动程序，以确保使用管理员身份运行 //获得当前登录的Windows用户标示 WindowsIdentity identity = WindowsIdentity.GetCurrent(); WindowsPrincipal principal = new WindowsPrincipal(identity); //判断当前登录用户是否为管理员 if (principal.IsInRole(WindowsBuiltInRole.Administrator)) { try { //如果是管理员，注册自启动代码 SystemHelper.SetAutoRun(strFilePath, strFileName, AutoRunFlag); } catch(Exception ex) { MessageBox.Show( ex.Message, \"错误提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); } } else { //创建启动对象 System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo(); startInfo.UseShellExecute = true; startInfo.WorkingDirectory = Environment.CurrentDirectory; startInfo.FileName = Application.ExecutablePath; //设置启动动作,确保以管理员身份运行 startInfo.Verb = \"runas\"; try { System.Diagnostics.Process.Start(startInfo); } catch { return; } //退出 Application.Exit(); } #endregion } //启动程序 Application.Run(new Form1()); } catch(Exception ex) { MessageBox.Show(ex.Message, \"错误提示\", MessageBoxButtons.OK, MessageBoxIcon.Error); //return; } } } SystemHelper.cs 参考自：C# winform程序实现开机自启动，并且识别是开机启动还是双击启动 SystemHelper.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public sealed class SystemHelper{ private SystemHelper() { } /// &lt;summary&gt; /// 设置程序开机启动 /// &lt;/summary&gt; /// &lt;param name=\"strAppPath\"&gt;应用程序exe所在文件夹&lt;/param&gt; /// &lt;param name=\"strAppName\"&gt;应用程序exe名称&lt;/param&gt; /// &lt;param name=\"bIsAutoRun\"&gt;自动运行状态&lt;/param&gt; public static void SetAutoRun(string strAppPath, string strAppName, bool bIsAutoRun) { try { if (string.IsNullOrWhiteSpace(strAppPath) || string.IsNullOrWhiteSpace(strAppName)) { throw new Exception(\"应用程序路径或名称为空！\"); } RegistryKey reg = Registry.LocalMachine; RegistryKey run = reg.CreateSubKey(@\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"); if (bIsAutoRun) { run.SetValue(strAppName, strAppPath); } else { if (null != run.GetValue(strAppName)) { run.DeleteValue(strAppName); } } run.Close(); reg.Close(); } catch (Exception ex) { throw new Exception(ex.Message, ex); } } /// &lt;summary&gt; /// 判断是否开机启动 /// &lt;/summary&gt; /// &lt;param name=\"strAppPath\"&gt;应用程序路径&lt;/param&gt; /// &lt;param name=\"strAppName\"&gt;应用程序名称&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsAutoRun(string strAppPath, string strAppName) { try { RegistryKey reg = Registry.LocalMachine; RegistryKey software = reg.OpenSubKey(@\"SOFTWARE\"); RegistryKey run = reg.OpenSubKey(@\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"); object key = run.GetValue(strAppName); software.Close(); run.Close(); if (null == key || !strAppPath.Equals(key.ToString())) { return false; } return true; } catch (Exception ex) { throw new Exception(ex.Message, ex); } }} 运行环境 Win10.NET Framework4.5VS2019 填坑 注册表地址 使用代码修改注册表的方式，如果需要查看注册信息，需要确认程序是32-bit还是64-bit。 32位，查看地址为 :HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVers ion\\Run 64位，查看地址为 :HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 操作系统 64位程序访问的注册表 32位程序访问的注册表 64位系统 HKEY_LOCAL_MACHINE\\SOFTWARE HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node 32位系统 - HKEY_LOCAL_MACHINE\\SOFTWARE 参考资料： .NET/C# 在 64 位进程中读取 32 位进程重定向后的注册表 关于WOW6432Node 以管理员权限打开程序：参考资料： Windows 下使用 runas 命令以指定的权限启动一个进程（非管理员、管理员） Windows 中的 UAC 用户账户控制 C#程序以管理员权限运行","link":"/2021/07/16/CSharp%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"},{"title":"C#代码确保应用程序只有一个实例","text":"使用互斥锁，实现只有一个程序 代码： code.cs12345678910string appGuid = ((GuidAttribute)Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(GuidAttribute), false).GetValue(0)).Value;using (Mutex mutex = new Mutex(false, \"Global\\\\\" + appGuid)){ if (!mutex.WaitOne(0, false)) { return; } //启动程序 Application.Run(new Form1()); } 运行环境 Win10.NET Framework 4.5VS2019 参考资料： What is a good pattern for using a Global Mutex in C#? The Misunderstood Mutex C# prevent multiple instance of console application running","link":"/2021/07/20/CSharp%E4%BB%A3%E7%A0%81%E7%A1%AE%E4%BF%9D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B/"},{"title":"Win10中文语言下添加美式键盘","text":"个人操作习惯使用Ctrl+Shift切换键盘布局，但是win10的更新会经常性导致输入法的问题出现。下面是一些平时收集到的方法。 20H2版本无法通过修改注册表实现添加美式键盘，目前使用Silence的工具箱博主开发的工具进行修改 日期 使用版本 链接 2021-7-20 V0.9.2.0 TSFTool V0.9.2.0 输入法设置工具 20H2以前的版本通过注册表可以正常添加美式键盘布局。 来源：https://www.itsk.com/thread-413229-1-1.html 2021-7-20.reg12345678910111213141516171819Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Keyboard Layout\\Preload]\"1\"=\"00000804\"[HKEY_CURRENT_USER\\Keyboard Layout\\Substitutes]\"00000804\"=\"00000409\"[HKEY_USERS\\.DEFAULT\\Keyboard Layout\\Preload]\"1\"=\"00000804\"[HKEY_USERS\\.DEFAULT\\Keyboard Layout\\Substitutes]\"00000804\"=\"00000409\"[HKEY_CURRENT_USER\\Control Panel\\International\\User Profile]\"InputMethodOverride\"=\"0804:00000409\"[HKEY_CURRENT_USER\\Control Panel\\International\\User Profile\\zh-Hans-CN]\"0804:00000409\"=dword:00000001","link":"/2021/07/20/Win1020H2%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%BE%8E%E5%BC%8F%E9%94%AE%E7%9B%98/"},{"title":"服务器设置系统启动时程序自动运行（不需要登录）","text":"写在前面本方法不适用于winform、WPF等UI程序。涉及到windows系统的用户会话管理的策略。Windows系统中存在一个特殊的 Session，其 Session ID 为 0。这通常称为 Session0。所有 Windows 服务都在 Session0 中运行，并且 Session0 是非交互式的。非交互式意味着无法启动 UI 应用程序； 1. 通过组策略设置脚本随服务器启动打开组策略编辑器 找到 计算机配置-&gt;Windows设置-&gt;脚本（启动/关机） 选中启动 将下列脚本添加进去，配置好启动程序路径的参数： start.bat1234567@echo offREM 声明采用UTF-8编码chcp 65001@REM pauseset input=%1%echo 自启动程序路径参数:%input%start %input% 2. 使用任务计划程序需要注意的时，在选择用户执行时，如果创建任务的用户为Administrator，需要注意执行时的用户账户，如果是需要在服务器启动时运行，就不应该为Administrator，而是应该为SYSTEM。 参考资料： Windows Server 2012的服务管理自动化 windows2008服务器设置系统启动时程序自动运行 碰见的问题： Windows Scheduled Task - Error 2147943711 for “on startup” task Task scheduler can’t show GUI of the application after login (Run whether user is logged on or not mode) - How bypass it with C# 界面显示问题： According to Microsoft (emphasis added): You can specify that a task should run even if the account under which the task is scheduled to run is not logged on when the task is triggered. To do this, select the radio button labeled Run whether user is logged on or not . If this radio button is selected, tasks will not run interactively. To make a task run interactively, select the Run only when user is logged on radio button. Essentially, if you select ‘Run whether user is logged on or not’, the process will not start a UI.","link":"/2021/07/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%97%B6%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%EF%BC%88%E4%B8%8D%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95%EF%BC%89/"},{"title":"C#穿透session隔离———Windows服务启动UI交互程序","text":"写在前面一开始是因为服务器经常会出现断电、系统崩溃的情况，导致一些正常运行的winform程序在系统故障重启后，每次都需要手动登录触发事件让程序自启。然后想利用windows服务在开启时就会自启来实现开机启动Winform程序。但是因为从Vista 开始引入了 Session 0 隔离机制，导致windows服务无法直接进行界面交互操作。 注意：使用CreateProcessAsUser与界面交互需要Session Id &gt;0 ，用户会话的必须存在，如果存在服务器重启、注销后，重新开机导致系统只有Session 0存在，此时服务调用后的程序是不会显示界面的。所以到头来还是没能实现我的想法。。。淦 Session 0 隔离原理参考： 穿透Session 0 隔离（一）摘录用户界面特权隔离 在早期的Windows操作系统中，在同一用户下运行的所有进程有着相同的安全等级，拥有相同的权限。例如，一个进程可以自由地发送一个Windows消息到另外一个进程的窗口。从Windows Vista开始，当然也包括Windows 7、Windows 10，对于某些Windows消息，这一方式再也行不通了。进程(或者其他的对象)开始拥有一个新的属性——特权等级(Privilege Level)。一个特权等级较低的进程不再可以向一个特权等级较高的进程发送消息，虽然他们在相同的用户权限下运行。这就是所谓的用户界面特权隔离(User Interface Privilege Isolation ，UIPI)。 UIPI的引入，最大的目的是防止恶意代码发送消息给那些拥有较高权限的窗口以对其进行攻击，从而获取较高的权限等等，在计算机系统中，这却是一种维护系统安全的合适方式。 windows服务启动UI程序、对于简单的交互，服务可以通过WTSSendMessage 函数，在用户Session 上显示消息窗口。对于一些复杂的UI 交互，必须调用CreateProcessAsUser 或其他方法（WCF、.NET远程处理等）进行跨Session 通信，在桌面用户上创建一个应用程序界面。 解决思路是：window service创建一个和与当前登陆用户可以交互的进程，这个进程运行在admin权限下，能够调起应用程序的UI 具体的做法是：widow service复制winlogon.exe进程句柄，然后通过调用api函数CreateProcessAsUser（）以winlogon.exe权限创建新进程，新创建的进程有winlogon.exe的权限（winlogon.exe运行在system权限下），负责调用程序。 作者原文： First, we are going to create a Windows Service that runs under the System account. This service will be responsible for spawning an interactive process within the currently active User’s Session. This newly created process will display a UI and run with full admin rights. When the first User logs on to the computer, this service will be started and will be running in Session0; however the process that this service spawns will be running on the desktop of the currently logged on User. We will refer to this service as the LoaderService. Next, the winlogon.exe process is responsible for managing User login and logout procedures. We know that every User who logs on to the computer will have a unique Session ID and a corresponding winlogon.exe process associated with their Session. Now, we mentioned above, the LoaderService runs under the System account. We also confirmed that each winlogon.exe process on the computer runs under the System account. Because the System account is the owner of both the LoaderService and the winlogon.exe processes, our LoaderService can copy the access token (and Session ID) of the winlogon.exe process and then call the Win32 API function CreateProcessAsUser to launch a process into the currently active Session of the logged on User. Since the Session ID located within the access token of the copied winlogon.exe process is greater than 0, we can launch an interactive process using that token. 参考：交互式服务C#开发Windows服务详细流程C#穿透session隔离———Windows服务启动UI交互程序Subverting Vista UAC in Both 32 and 64 bit Architectures 问题windows服务启动winform程序不显示UI问题解决原因：xp系统的用户和window service运行在一个session下，在xp以后，windows系统改变了用户会话管理的策略，window service独立运行在session0下，依次给后续的登录用户分配sessionX(X =1,2,3…)，session0没有权限运行UI。所以在window xp以后的系统下，window service调用有UI的application时只能看到程序进程但不能运行程序的UI。 参考：C# windows服务启动winform程序不显示UI问题解决How can a Windows service execute a GUI application?穿透Session 0 隔离（二）","link":"/2021/07/21/CSharp%E7%A9%BF%E9%80%8Fsession%E9%9A%94%E7%A6%BB%E2%80%94%E2%80%94%E2%80%94Windows%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8UI%E4%BA%A4%E4%BA%92%E7%A8%8B%E5%BA%8F/"},{"title":"SQLite学习【一】","text":"SQLite学习.sql123456789101112131415161718192021222324252627282930313233343536373839404142434445--创建数据库(数据库名可以是任何名字，文件类型始终为sqlite类型)sqlite3 test.sqlitesqlite3 other.dbsqlite3 db.sqlite3--创建数据表 增删改查 SQLiteCREATE TABLE DEPARTMENT( ID INT PRIMARY KEY NOT NULL, DEPT CHAR(50) NOT NULL, EMP_ID INT NOT NULL);CREATE TABLE Test( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL);SELECT * FROM sqlite_master WHERE type = 'table';DROP TABLE DEPARTMENT;SELECT * FROM sqlite_master WHERE type = 'table';--增INSERT INTO `Test` (ID, NAME, AGE, ADDRESS, SALARY) VALUES (1,'测试人员',35,'东北那旮瘩',5000);INSERT INTO `Test` (ID, NAME, AGE, ADDRESS, SALARY)VALUES (2,'测试人员',35,'东北那旮瘩',10000);SELECT * from Test ;--删DELETE from `Test` where ID='1';SELECT * from Test ;--改update `Test` set Name ='测试人员2' where ID=2;SELECT * from `Test`;DROP TABLE Test;SELECT * FROM sqlite_master WHERE type = 'table';","link":"/2021/07/28/sqlite/"},{"title":"PDI【Kettle】（一）","text":"Kettle中JavaScript内置函数说明转换组件-脚本-JavaScript【Spoon】我们在使用JavaScript组件的时候,在左侧核心树对象栏中可以看到Kettle为我们提供了很多简洁强大的内置函数,帮助我们在写脚本的时候对数据、参数变量等能很轻松的做处理,体验编码的感觉.本篇将详细介绍JavaScript组件中的函数功能 脚本组件包含的函数主要包括六大类,分别是： 字符串类型的函数(String Functions) 浮点型的函数(Numeric Functions) 日期类型函数(Date Functions) 逻辑判断型函数(Logic Functions) 特殊的函数(Special Functions) 文件处理类函数(File Functions) 字符串类型函数(String Functions)顾名思义,字符串类型的函数肯定是针对字符串类型的参数、变量进行处理操作的函数 日期转字符串(date2str)日期转字符串函数date2str主要有4个方法,分别是： date2str(date):传入日期实例,转换成字符串类型 date2str(date,format):传入日期和格式化参数,进行格式化转换 date2str(date,format,iso):传入日期和参数格式化及ISO代码进行转换,(DE = German, EN = English, FR = France, …) date2str(date,format,iso,zone):传入时区进行格式化,例如北京时区(GMT+8) 日期格式化参数format参数类型供参考： 1234567yy / yyyy - 06 / 2006MM / MMM / MMMMM - 11 / Nov / Novemberd / dd - 1 / 01E / EEEE - Tue / Tuesdayhh / HH - 11 / 23m / mm - 5 / 05s / ss - 8 / 08 代码示例: 1234567var dValue = new Date();writeToLog(date2str(dValue,\"dd.MM.yyyy\"));writeToLog(date2str(dValue,\"dd.MM.yyyy HH:mm:ss\"));writeToLog(date2str(dValue,\"E.MMM.yyyy\",\"DE\"));writeToLog(date2str(dValue,\"dd.MM.yyyy HH:mm:ss\",\"EN\"));writeToLog(date2str(dValue,\"dd.MM.yyyy HH:mm:ss\",\"ZH\", \"GMT+8\"));writeToLog(date2str(dValue,\"yyyy-MM-dd HH:mm:ss\",\"ZH\", \"GMT+8\")); 以上代码在控制台将会输出如下： 1234562019/08/19 10:12:56 - JavaScript代码.0 - 19.08.20192019/08/19 10:12:56 - JavaScript代码.0 - 19.08.2019 10:12:562019/08/19 10:12:56 - JavaScript代码.0 - Mo.Aug.20192019/08/19 10:12:56 - JavaScript代码.0 - 19.08.2019 10:12:562019/08/19 10:12:56 - JavaScript代码.0 - 19.08.2019 10:12:562019/08/19 10:12:56 - JavaScript代码.0 - 2019-08-19 10:12:56 转义HTMLescapeHtml(html)代码如下： 123var html=\"&lt;h1&gt;我是H2标题&lt;/h2&gt;\";writeToLog(escapeHtml(html)) 最终输出 12019/08/19 10:16:13 - JavaScript代码.0 - &amp;lt;h1&amp;gt;&amp;#25105;&amp;#26159;H2&amp;#26631;&amp;#39064;&amp;lt;/h2&amp;gt; 转义SQL(escapeSQL(var))12var str1 = \"SELECT * FROM CUSTOMER WHERE NAME='\" + escapeSQL(\"McHale's Navy\") + \"'\"; writeToLog(str1) 该函数会把单引号转成双引号,输出结果如下： 12019/08/19 10:18:59 - JavaScript代码.0 - SELECT * FROM CUSTOMER WHERE NAME='McHale''s Navy' 构造定长字符串(fillString(char,length))代码示例如下： 12writeToLog(fillString(\"x\",10));writeToLog(fillString(\"A\",3)); 最终会输出10个X和3个A,输出结果如下： 122019/08/19 10:24:08 - JavaScript代码.0 - xxxxxxxxxx2019/08/19 10:24:08 - JavaScript代码.0 - AAA 需要注意的是第一个是一个char类型的单字符,不能是字符串 统计字符串出现频次(getOcuranceString(str,searchStr))第一个参数是要搜索的完整字符串,第二个参数是要搜索统计的字符串 代码示例： 1234var sef='2007-09-11';writeToLog(getOcuranceString(sef,'0'))writeToLog(getOcuranceString(sef,'00')) 我们分别统计字符串0和00最终出现的次数,此时,日志最终打印的次数是3和1： 122019/08/19 10:28:45 - JavaScript代码.0 - 32019/08/19 10:28:45 - JavaScript代码.0 - 1 获取字符串下标索引(indexOf)获取下标索引主要有2个重构函数,分别是： indexOf(string,subString):获取出现字符串的索引开始位置 indexOf(string,subString,fromIndex)；指定开始位置,获取字符串索引开始位置 代码示例： 123456var str1= \"Hello Pentaho!\";var str2= indexOf(str1, \"Pentaho\");var str3= indexOf(str1, \"o\", 7);writeToLog(\"Input : \" + str1);writeToLog(\"Index of 'Pentaho' : \" + str2);writeToLog(\"index of 'o', search from position 7 : \" + str3); 最终控制台输出： 1232019/08/19 10:34:16 - JavaScript代码.0 - Input : Hello Pentaho!2019/08/19 10:34:16 - JavaScript代码.0 - Index of 'Pentaho' : 62019/08/19 10:34:16 - JavaScript代码.0 - index of 'o', search from position 7 : 12 首字母大写(initCap)对指定字符串首字母大写处理,来看代码示例： 1234var str1 = \"my home\"; writeToLog(initCap(str1));writeToLog(initCap('test a aaa cw'));writeToLog(initCap('myhome')); 此时,最终控制台输出如下： 1232019/08/19 10:41:27 - JavaScript代码.0 - My Home2019/08/19 10:41:27 - JavaScript代码.0 - Test A Aaa Cw2019/08/19 10:41:27 - JavaScript代码.0 - Myhome 字符串转小写(lower)将传入字符串全部转小写 代码如下： 12345var str1= \"Hello World!\";var str2= lower(str1);writeToLog(\"Input:\" + str1);writeToLog(\"Converted to LowerCase:\" + str2);writeToLog(lower('DDDHelloSWxss')) 响应内容 1232019/08/19 10:43:09 - JavaScript代码.0 - Input:Hello World!2019/08/19 10:43:09 - JavaScript代码.0 - Converted to LowerCase:hello world!2019/08/19 10:43:09 - JavaScript代码.0 - dddhelloswxss 字符串填充左侧(lpad(string,char,length))用指定长度的给定字符将字符串填充到左侧 参数定义： 1：传入字符串 2：填充单字符 3：填充单字符长度 如果length长度超过给定字符串的长度,将对填充字符串做减法，例如： 12var str1= \"Hello World!\"; writeToLog(\"Lpad:\" + lpad(str1, \"x\",20)); 此时,最终输出结果为： 12019/08/19 10:46:38 - JavaScript代码.0 - Lpad:xxxxxxxxHello World! 最终的完成长度是20个字符长度,因此填充的单字符x并没有填充20次 如果length长度小于给定字符串的长度,则默认返回原字符串,不做填充,代码示例： 12var str1= \"Hello World!\"; writeToLog(\"Lpad:\" + lpad(str1, \"x\",5)); 此时最终的输出结果为： 12019/08/19 10:46:38 - JavaScript代码.0 - Lpad:Hello World! 去空字符(ltrim)从左侧开始去除空字符串 数字转字符串(num2str)给定数字,转换为字符串,主要有3个构造函数： num2str(num):转换num数字为字符串 num2str(num,format):格式化数字为指定字符串 num2str(num,format,iso):按照本地ISO编码进行格式化 代码示例如下： 123456var d1 = 123.40;var d2 = -123.40;writeToLog(num2str(d1));writeToLog(num2str(d1, \"0.00\"));writeToLog(num2str(d1, \"0.00\", \"EN\"));writeToLog(num2str(d2, \"0.00;(0.00)\", \"EN\")); 最终控制台输出： 12342019/08/19 11:00:17 - JavaScript代码.0 - 123.42019/08/19 11:00:17 - JavaScript代码.0 - 123.402019/08/19 11:00:17 - JavaScript代码.0 - 123.402019/08/19 11:00:17 - JavaScript代码.0 - (123.40) XML保护标签函数转换(protectXMLCDATA)传入给定字符串,添加标准保护,代码示例 12var str1 = \"my home\"; writeToLog(protectXMLCDATA(str1)); 此时,将会给变量str1加上保护标签 12019/08/19 11:02:09 - JavaScript代码.0 - &lt;![CDATA[my home]]&gt; 移除字符串中CRLF字符(removeCRLF(str))给定字符串中删除CR END LF的字符串 替换字符串(replace)替换字符串主要包括两个构造函数： replace(str,searchStr,replaceStr):从指定字符串中查询，然后替换 replace(str,firstSearch,firstReplace,secondSearch,SecondReplace...)：无限查询替换 代码示例如下： 12345var str1 = \"Hello World, this is a nice function\"; var str2 = replace(str1,\"World\", \"Folk\");writeToLog(str2);var str2 = replace(str1,\"World\", \"Folk\", \"nice\",\"beautifull\");writeToLog(str2); 最终输出: 122019/08/19 11:10:21 - JavaScript代码.0 - Hello Folk, this is a nice function2019/08/19 11:10:21 - JavaScript代码.0 - Hello Folk, this is a beautifull function 字符串右侧填充(rpad(string,char,length))使用方法同lpad,只是一个是左侧，一个是右侧 去除空字符(右侧)(rtrim)正则切分(str2RegExp)出入一个正则表达式,对string字符串进行Split操作.代码如下： 123456789101112var strToMatch = \"info@proconis.de\";var strReg = \"^(\\\\w+)@([a-zA-Z_]+?)\\\\.([a-zA-Z]{2,3})$\";var xArr = str2RegExp(strToMatch, strReg);if ( xArr != null ) { for(i=0;i&lt;xArr.length;i++) { writeToLog(xArr[i]); }}else { writeToLog(\"no match\");} 最终控制台输出： 1232019/08/19 13:21:19 - JavaScript代码.0 - info2019/08/19 13:21:19 - JavaScript代码.0 - proconis2019/08/19 13:21:19 - JavaScript代码.0 - de 字符串截取(substr)通过制定索引开始对字符串进行截取操作,主要有两个重构参数： substr(string,from):指定from索引开始截取字符串 substr(string,from,to):指定开始和截止索引进行截取 代码示例： 123456var str1= \"Hello Pentaho!\";var str2= substr(str1, 6);var str3= substr(str1, 6, 7);writeToLog(\"Input : \" + str1);writeToLog(\"From position 6: \" + str2);writeToLog(\"From position 6 for 7 long : \" + str3); 控制台输出如下： 1232019/08/19 13:31:20 - JavaScript代码.0 - Input : Hello Pentaho!2019/08/19 13:31:20 - JavaScript代码.0 - From position 6: Pentaho!2019/08/19 13:31:20 - JavaScript代码.0 - From position 6 for 7 long : Pentaho 去除左右空格(trim)不转义HTML(unEscapeHtml(html))针对以转义的HTML字符进行解密,代码如下： 1234567var w='&lt;h2&gt;我是H2标题&lt;/h2&gt;';var esW=escapeHtml(w);var unesw=unEscapeHtml(esW);writeToLog(esW);writeToLog(unesw); 最终控制台输出： 122019/08/19 13:38:16 - JavaScript代码.0 - &amp;lt;h2&amp;gt;&amp;#25105;&amp;#26159;H2&amp;#26631;&amp;#39064;&amp;lt;/h2&amp;gt;2019/08/19 13:38:16 - JavaScript代码.0 - &lt;h2&gt;我是H2标题&lt;/h2&gt; 解码转义XML(unEscapeXml )字符串转大写(upper)将传入字符串全部转大写.例如: 12var str=\"Hello World\";writeToLog(upper(str)); 浮点型的函数(Numeric Functions)计算绝对值(abs(num))计算一个数值的绝对值,代码示例： 1234var d1 = -1234.01;var d2 = 1234.01;writeToLog(abs(d1));writeToLog(abs(d2)); 最终控制台输出为： 122019/08/19 13:51:00 - JavaScript代码.0 - 1234.012019/08/19 13:51:00 - JavaScript代码.0 - 1234.01 最小双精度值(ceil(num))返回最小的双精度值。该值将被四舍五入。代码示例： 1234var d1 = -1234.01;var d2 = 1234.01;writeToLog(ceil(d1));writeToLog(ceil(d2)); 最终控制台输出： 122019/08/19 13:52:40 - JavaScript代码.0 - -12342019/08/19 13:52:40 - JavaScript代码.0 - 1235 最大数值(floor(num))返回最大数值,该值将被四舍五入,代码示例： 1234var d1 = -1234.01;var d2 = 1234.01;writeToLog(floor(d1));writeToLog(floor(d2)); 运行结果如下： 122019/08/19 13:55:13 - JavaScript代码.0 - -12352019/08/19 13:55:13 - JavaScript代码.0 - 1234 字符串转数值(str2num(var))字符串转数值主要包含两个构造函数,分别是 str2num(str):传入数值字符串,进行格式化转换 str2num(str,format):通过指定格式进行数值转换 代码示例如下： 1234var str1 = \"1.234,56\";var str2 = \"12\";writeToLog((str2num(str1,\"#,##0.00\")));writeToLog((str2num(str2))); 最终控制台输出： 122019/08/19 14:02:19 - JavaScript代码.0 - 1.2342019/08/19 14:02:19 - JavaScript代码.0 - 12 截取数值(trunc)1trunc(1234.9); // 返回 1234 日期类型函数(Date Functions)日期相加(dateAdd)针对日期变量进行相应的添加时间,添加频率包括年、月、日、时、分、秒 等等 函数定义:dateAdd(date,format,plusNum) date:日期对象 format:要加的类型 plusNum:加的数值 相加类型主要包括： y:年 m：月 d:日 w:周 wd:工作日 hh:小时 mi:分钟 ss:秒 代码示例如下： 1234567var d1 = new Date();var fmt='yyyy-MM-dd HH:mm:ss';writeToLog(\"当前时间:\"+date2str(d1,fmt));var py=dateAdd(d1,'y',1);var fy=date2str(py,fmt);writeToLog(\"加1年：\"+fy); 最终控制台输出： 122019/08/19 14:17:41 - JavaScript代码.0 - 当前时间:2019-08-19 14:17:412019/08/19 14:17:41 - JavaScript代码.0 - 加1年：2020-08-19 14:17:41 日期比较(dateDiff)两个日期相互比较 函数定义:dateDiff(startDate,endDate,type) startDate:开始日期 endDate:截止日期 type：返回相差数值类型 类型主要包括： y:年 m：月 d:日 w:周 wd:工作日 hh:小时 mi:分钟 ss:秒 获取指定日期数值(getDayNumber)根据类型获取指定日期的数值 函数定义：getDayNumber(date,type) date:当前日期实例 type:类别 类别主要分四类 y:获取当年的天数 m:获取当月的天数 w:获取本周的天数 wm:获取当月中本周的天数 代码示例： 12345var d1 = new Date();writeToLog(getDayNumber(d1, \"y\"));writeToLog(getDayNumber(d1, \"m\"));writeToLog(getDayNumber(d1, \"w\"));writeToLog(getDayNumber(d1, \"wm\")); getFiscalDate12345678910111213141516// Returns the fiscal Date from the date value,// based on a given offset.//// Usage:// getFiscalDate(var);// 1: Date - The Variable with the Date.// 2: String - The Date/Month which represents// the fiscal Start Offset. Format allways \"dd.MM.\".//// 2006-11-15//var d1 = new Date();var str1 = \"01.07.\";var str2 = \"10.12.\";Alert(getFiscalDate(d1, str1));Alert(getFiscalDate(d1, str2)); 获取下一个工作日日期(getNextWorkingDay)传入当前日期,获取该日期后面一个工作日日期 函数定义getNextWorkingDay(date) 代码示例如下： 12345678910var d1 = new Date();// 周1var d2=str2date('2019-08-19 16:36:00',fmt);//周 6var d3=str2date('2019-08-17 16:36:00',fmt);writeToLog(date2str(getNextWorkingDay(d1),fmt));writeToLog(date2str(getNextWorkingDay(d2),fmt));writeToLog(date2str(getNextWorkingDay(d3),fmt)); 我们这d2和d3变量中定义了不同的日期实例,分别是周1和周6,最终通过getNextWorkingDay能获取得到下一个工作日日期，控制台输出如下： 1232019/08/19 16:37:38 - JavaScript代码.0 - 2019-08-20 16:37:382019/08/19 16:37:38 - JavaScript代码.0 - 2019-08-20 16:36:002019/08/19 16:37:38 - JavaScript代码.0 - 2019-08-19 16:36:00 获取当前月份数值(month(date))获取当前日期的月份数值,需要注意的是,该值的月份是从0开始的,因此我们最终得到的结果应该+1才是我们的真实月份数值，代码示例： 12var d1 = new Date();//2019/08/19writeToLog(month(d1)); //最终输出为7 获取当前时间的季度值(quarter(date))根据指定日期获取当前季度数值 12var d1 = new Date();//2019/08/19writeToLog(quarter(d1));//最终输出为3(代表第三季度) 字符串转日期(str2date)字符串转日期和日期转字符串有点类似,只不过主体对换了一下,但是传入的格式参数都是一样的，主要有4个重载函数: str2date(str):默认转换 str2date(str,format):传入format格式化参数 str2date(str,format,iso):根据iso编码及格式化参数进行转换 str2date(str,format,iso,timezone):根据不同时区的iso编码进行格式化转换 代码示例如下： 12345writeToLog(str2date(\"01.12.2006\",\"dd.MM.yyyy\"));writeToLog(str2date(\"01.12.2006 23:23:01\",\"dd.MM.yyyy HH:mm:ss\"));writeToLog(str2date(\"Tue.May.2006\",\"E.MMM.yyyy\",\"EN\"));writeToLog(str2date(\"22.02.2008 23:23:01\",\"dd.MM.yyyy HH:mm:ss\",\"DE\"));writeToLog(str2date(\"22.02.2008 23:23:01\",\"dd.MM.yyyy HH:mm:ss\",\"DE\", \"EST\")); 截取日期(truncDate(date,type))指定截取不同的日期部分,函数定义truncDate(date,type) date:当前日期实例 type:截取类型 类型主要有6中,分别是整型，从0-5： 5：截取月份 4：截取天数 3:截取小时 2：截取分钟 1：截取秒 0:截取毫秒 代码示例 如下： 1234567var dateTime = new Date();var date0 = truncDate(dateTime, 0); // gives back today at yyyy/MM/dd HH:mm:ss.000var date1 = truncDate(dateTime, 1); // gives back today at yyyy/MM/dd HH:mm:00.000var date2 = truncDate(dateTime, 2); // gives back today at yyyy/MM/dd HH:00:00.000var date3 = truncDate(dateTime, 3); // gives back today at yyyy/MM/dd 00:00:00.000var date4 = truncDate(dateTime, 4); // gives back today at yyyy/MM/01 00:00:00.000var date5 = truncDate(dateTime, 5); // gives back today at yyyy/01/01 00:00:00.000 获取当年的周数(week)获取指定日期的周数,代码示例： 123var d1 = new Date(); //2019/08/19 writeToLog(week(d1));// 返回34 获取年份(year)获取传入日期的年份,代码示例： 123var d1 = new Date(); //2019/08/19 writeToLog(year(d1));// 返回2019 逻辑判断型函数(Logic Functions)isCodepage判断字符串的codepage项,代码示例： 123var xStr = \"RÃ©al\";writeToLog(isCodepage(xStr, \"UTF-8\"));// truewriteToLog(isCodepage(xStr, \"windows-1250\"));// true 是否日期(isDate(str))判断当前字符串是否日期 1234var d1 = \"Hello World\"; var d2 = new Date();writeToLog(isDate(d1));//falsewriteToLog(isDate(d2));//true 是否为空(isEmpty(str))判断字符串是否为空 12var d = \"Hello World\"; Alert(isEmpty(d));//false 判断字符串是否为邮箱标准格式(isMailValid(str))判断一个字符串是否是邮箱 判断是否是数值(isNum(str))判断一个字符串是否是数值 1234var str1 = \"Hello World\"; var str2 = 123456;Alert(isNum(str1));//falseAlert(isNum(str2));//true 是否正则匹配(isRegExp)判断给定的正则表达式是否匹配当前的字符串，主要有2个函数定义： isRegExp(str,reg):给定正则判断字符串是否匹配 isRegExp(str,reg1,reg2,reg3…)；可以递归判断正则匹配 最终返回的是匹配的次数数值,如果不匹配,返回-1 代码示例如下： 12345678910var email1 =\"info@proconis.de\";var email2= \"support@proconis.co.uk\";var email3= \"HelloWorld@x\";var reg1=\"^\\\\w+@[a-zA-Z_]+?\\\\.[a-zA-Z]{2,3}$\";var reg2=\"^[\\\\w-\\.]+@([\\\\w-]+\\\\.)+[\\\\w-]{2,4}$\";writeToLog(isRegExp(email1, reg1,reg2) + \" Matches\"); //1writeToLog(isRegExp(email2, reg1,reg2) + \" Matches\"); //2writeToLog(isRegExp(email3, reg1,reg2) + \" Matches\");// 1 是否工作日(isWorkingDay(date))判断某日期是否是工作日,代码示例： 1234var d1 = new Date();//周1var d2=str2date('2019-08-17','yyyy-MM-dd') //周六writeToLog(isWorkingDay(d1));//truewriteToLog(isWorkingDay(d2));//false 特殊的函数(Special Functions)弹框信息(Alert(msg))在屏幕前弹出一个信息框 加载JavaScript文件(LoadScriptFile)将一个javascript文件加载到实际的运行上下文中。应该从定义的StartScript调用此函数，否则，每次处理都会加载javascript文件行。 代码示例如下： 12var xPfad = \"F:/bak/Hello.js\";LoadScriptFile(xPfad); 此时,我们的外部JS文件仅仅是包含一句简单的输出，如下： 1writeToLog(\"Hello LoadScriptFile,outSide JS File \"); 最终运行时,控制台会打印出我们在外部JS中的输出行 从当前Tab栏加载JS并运行(LoadScriptFromTab)如果我们在当前的JavaScript组件中通过模块化的方式编写了很多脚本代码,我们可以通过LoadScriptFromTab函数进行相互调用,这对于开发抽象来说是很好的,代码示例如下： 12writeToLog(\"外部Tab加载JS-------------------------\")LoadScriptFromTab('Item_1'); 有效卡号判断(LuhnCheck)如果给定的是一个有效的卡号,则返回true 123456var str1 = \"4444333322221111\"; writeToLog(str1 + \": \" + LuhnCheck(str1)); //truevar str2 = \"4444333322221110\"; writeToLog(str2 + \": \" + LuhnCheck(str2));//false 向文件中追加数据(appendToFile)向指定文件中追加数据,如果文件不存在则创建文件 1234567var file = \"F:/bak/log.txt\";for(var i=0;i&lt;100;i++){ appendToFile(file,'TEST'+i+\"\\r\\n\");} 此时,该代码会向log.txt文件输出100条数据行 decode函数decode函数有点类似于IF-THEN-ELSE语句，即表示通过给定查询的字符串是否存在，如果存在，即替换,否则返回默认值 代码示例： 123456var str1 = \"Hallo\";writeToLog(decode(str1, \"Hallo\", \"Hello\"));writeToLog(decode(str1, \"1\", \"Mr\", \"2\", \"Mrs\", \"N/A\"));writeToLog(decode(str1, \"1\", \"Mr\", \"2\", \"Mrs\"));str1 = \"Mrs\";writeToLog(decode(str1, \"1\", \"Mr\", \"2\", \"Mrs\")); 控制台输出： 12342019/08/19 17:39:01 - JavaScript代码.0 - Hello2019/08/19 17:39:01 - JavaScript代码.0 - N/A2019/08/19 17:39:01 - JavaScript代码.0 - Hallo2019/08/19 17:39:01 - JavaScript代码.0 - Mrs 执行命令(execProcess)代码如下： 12var t=execProcess('ping www.baidu.com');writeToLog(t) 调用命令行,ping百度的网址，最终输出返回数据 执行SQL语句(fireToDB)通过获取数据库连接名称，传递SQL语句,以返回SQL查询的值,函数定义： fireToDB(connectionName,SQL)；第一个参数为数据库连接名称，我们在JNDI中定义的名称，第二个参数为SQL语句 123var strConn = \"MY Connection\";var strSQL = \"SELECT COUNT(*) FROM ...\";var xArr = fireToDB(strConn, strSQL); 仅仅获取数值(getDigitsOnly)在给定的字符串中仅仅筛选过滤得到数值，代码如下： 12var str1 = \"abc123cde\"; writeToLog(getDigitsOnly(str1));//返回123 获取Kettle环境变量的值(getEnvironmentVar)获取在Kettle中的环境变量的值 12writeToLog(getEnvironmentVar(\"user.dir\"));writeToLog(getEnvironmentVar(\"user.name\")); 获取当前进程的受影响行数(getProcessCount(type))根据类型获取当前进程的受影响行数，类型如下： u:更新行数 i:插入行数 w:写入行数 r:读取行数 o:输出行数 12writeToLog(getProcessCount(\"u\"));writeToLog(getProcessCount(\"r\")); 获取当前转换名称(getTransformationName)获取当前的转换名称 12var xTranName = getTransformationName();writeToLog(xTranName); 获取Kettle环境中的变量值(getVariable)从当前的Kettle环境中获取指定的变量值,目前函数有2个重载： getVariable(varName)；根据变量名称获取变量值 getVariable(varName,defaultValue):根据变量名获取值,如果不存在则使用默认值 12345678var strVarName=\"getVariableTest\";var strVarValue=\"123456\";Alert(getVariable(strVarName, \"\"));setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\"));strVarValue=\"654321\";setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\")); 控制台打印(println)123var str = \"Hello World!\";print(str); 移除数值(removeDigits)移除给定字符串中的数值，代码示例： 123var str1 = \"abc123cde\"; writeToLog(removeDigits(str1));//返回abccde 发送邮件设置环境变量(setEnvironmentVar)通过在Script脚本组件中调用函数重新设置Kettle的环境变量 12345678var strVarName=\"setEnvTest\";var strVarValue=\"123456\";Alert(getEnvironmentVar(strVarName));setEnvironmentVar(strVarName,strVarValue);Alert(getEnvironmentVar(strVarName));strVarValue=\"654321\";setEnvironmentVar(strVarName,strVarValue);Alert(getEnvironmentVar(strVarName)); 设置变量(setVariable)通过setVariable函数设置环境变量,该用途可以用于重新赋值Kettle环境中已经存在的变量值或者重新生成变量值 函数定义setVariable(key,value,level) key:变量名称 value:变量值 level:级别,主要包括s(system)、r(root)、p(parent)、g(grandparent)四种类别 代码示例如下： 12345678var strVarName=\"setEnvTest\";var strVarValue=\"123456\";Alert(getVariable(strVarName, \"\"));setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\"));strVarValue=\"654321\";setVariable(strVarName,strVarValue, \"r\");Alert(getVariable(strVarName, \"\")); 写入日志(writeToLog)打印并写入日志信息,该函数可能是我们用到的最多的函数,可以帮助我们调试信息,主要有两个重载： writeToLog(msg):写入msg日志信息 writeToLog(level,msg)：根据level基本写入msg信息 关于日志的级别,这里主要是简写的方式,主要如下： d(Debug):调试模式 l(Detailed):详细 e(Error):错误 m(Minimal):最小日志 r(RowLevel):行级日志 12writeToLog(\"Hello World!\");writeToLog(\"r\", \"Hello World!\"); 文件处理类函数(File Functions)复制文件(copyFile)复制一个文件到目标目录,函数定义如下： copyFile(sourceFile,targetFile,overwrite) sourceFile:源文件 targetFile:目标文件 overWrite:是否覆盖,如果目标文件存在的话,布尔类型 12345var file1 = \"F:/bak/log.txt\";var targetFile=\"F:/bak/logTarget.txt\";copyFile(file1,targetFile,false) 创建文件夹(createFolder)创建一个文件夹,代码示例如下： 12var strFolder = \"F:/bak/createFolder\";createFolder(strFolder); 删除文件(deleteFile)删除一个文件(不能删除文件夹) 123var targetFile=\"F:/bak/logTarget.txt\"; deleteFile(targetFile); 判断文件是否存在(fileExists())判断文件是否存在 123var targetFile=\"F:/bak/logTarget.txt\"; fileExists(targetFile); 获取文件扩展名(getFileExtension)如果文件不存在,则返回null,代码示例 1234var file1 = \"F:/bak/log.txt\"; var ext=getFileExtension(file1);writeToLog(\"扩展名：\"+ext) 获取文件大小(getFileSize)获取文件大小,结果是一个long类型的长整型数值 1234var file1 = \"F:/bak/log.txt\"; var ext=getFileSize(file1);writeToLog(\"大小：\"+ext) 获取文件最后修改日期(getLastModifiedTime)获取文件最后修改日期,函数定义： getLastModifiedTime(filePath,format) filePath:文件路径 format：日期格式化 123var file1 = \"F:/bak/log.txt\"; var ext=getLastModifiedTime(file1,\"yyyy-MM-dd HH:mm:ss\"); 获取文件的父文件夹名称(getParentFoldername)获取文件的父文件夹名称 12var file1 = \"F:/bak/log.txt\";var parentFolder=getParentFoldername(file1); 获取文件简称(getShortName)获取文件简称 12345var file1 = \"F:/bak/log.txt\";var shortName=getShortFilename(file1);writeToLog(\"简单名称:\"+shortName)//返回log.txt 判断是否是一个文件(isFile)判断是否是一个文件 12var file1 = \"F:/bak/log.txt\";var flag=isFile(file1) //true 判断是否是一个文件夹(isFolder)判断是否是一个文件夹 12var file1 = \"F:/bak/log.txt\";var flag=isFolder(file1) //false 加载一个文件的内容(loadFileContent)从指定文件中加载内容,主要有两个重载函数： loadFileContent(filePath):默认加载文件 loadFileContent(filePath,encoding):指定编码加载文件内容 代码示例： 1234var file1 = \"F:/bak/log.txt\";var content=loadFileContent(file1);var c1=loadFileContent(file1,\"UTF-8\")writeToLog(content) 移动文件(moveFile)移动指定文件，函数定义moveFile(source,target,overWrite) source:源文件 target:目标文件 overWrite；是否覆盖,如果目标文件存在,布尔类型值 12345var file1 = \"F:/bak/log.txt\";var targetFile=\"F:/bak/logTarget.txt\";moveFile(file1,targetFile,false) 创建一个空文件(touch)创建一个空文件 12var strFile = \"F:/bak/log.txt\";touch(strFile); 总结以上就是Kettle 8.3版本中的内置函数方法,方法很多,写这篇博客也是很累,算是全部都学习了一遍,脑子里已经记忆了一遍,但是我们也不需要死记硬背,就和我们学些Linux命令一样,如果你知道man命令，对某个命令不是很了解的话直接通过man命令学习即可. Kettle也是如此,对于某个函数不是很了解的话,右键点击该函数,会出现sample字样菜单,点击该菜单即可弹出该函数的介绍和使用信息,里面包含了该函数的调用示例和函数详细介绍,也是很人性化的.","link":"/2021/07/29/Kettle/"},{"title":"kettle填坑","text":"写在前面为了将MSSqlserver数据传输至MySql数据库，一开始的选择有很多,类似DataX、ES，但是碍于运行环境是windows server 2012,且服务器环境不方便更改，查阅一番后，决定使用kettle进行数据的同步。 环境 系统：windows server 2012R2 64位 内存：8GB JDK：1.8 kettle配置统一参数一、kettle的常用配置文件说明： ${user.home} 表示WINDOWS的当前用户的文档文件夹，在C:\\Users文件夹下 ${user.home}/ .kettle /repositories.xml: 该文件保存了用户设置的所有资源库信息,包括资源库名称,资源库需要的数据库连接参数等。该文件中定义的资源库将显示在spoon启动后出现的选择资源库下拉列表中,注意该文件的编码是UTF-8，资源库的名称尽量使用英文。 ${user.home}/ kettle/kettle.properties: 该文件保存了转换或作业中需要的变量, spoon启动后会自动加载该文件里定义的变量。 ${user.home}/.kettle/shared.xml: 该文件里保存了共享对象,共享对象可以是Database connections, Steps,Slave servers ,Partition schemas ,Cluster schemas。对象共享实质上就是将对象序列化的过程, spoon启动时,会加载shared.xml文件中定义的所有对象。 lib\\kettle-engine.jar\\kettle-jobs.xml: 该文件中定义了Spoon启动时需要加载的作业项。 lib\\kettle-engine.jarkettle-partition-plugins.xml: 该文件中定义了Spoon启动时需要加载的分区插件。 lib\\kettle-engine.jar\\kettle- plugins.xml: 该文件中定义了Spoon启动时步骤和作业项插件的加载路径。 lib\\kettle-engine.jar\\kettle-steps.xml: 该文件中定义了Spoon启动时需要加载的转换步骤。 二、修改repositories.xml的位置 找到kettle所在文件夹下的Spoon.bat 文件,在里面查找出Kettle home所在的代码段,在 cd %KETTLE_DIR%代码上一行加上代码：set KETTLE_HOME=D:/AAA/BBB/CCC 如上，表示把文件重新等位到D:/AAA/BBB/CCC这个文件夹下。(注意:文件夹的斜杠和WINDOWS的目录斜杠是反的） 复制 ${user.home} 文件夹下的 .kettle 文件夹到D:/AAA/BBB/CCC目录下。 启动kettle程序。 参考： Kettle日常使用汇总整理 Kettle使用统一的数据库配置 kettle学习笔记10—配置文件的使用 Kettle环境配置-kettle.properties部份配置: kettle配置作业、转换参考：Kettle—使用手册 在配置完成后,执行作业的方式有两种： 使用spoon.bat打开UI程序进行执行 优点：作业执行很稳定，不会异常退出。 缺点：吃内存，配置不高的服务器可能压力大。懂不懂1GB起步。😓 使用Kitchen.bat脚本执行作业 优点：可以结合windows的任务执行计划程序进行定时启动作业，占用内存少，完成后自动退出。 缺点：一些耗时长的任务会有闪退的情况，或者数据量太大，执行时只取了一部分，会造成数据丢失。 配置重抽作业的逻辑初始化时在作业里设置开始时间、结束时间变量值，执行转换前判断变量值，未到时间点，执行转换。执行一次转换后，更新变量，循环判断，实现重抽的需求。作业流程配置: 转换流程配置： 更新时间变量JavaScript代码： updatetime.js12345678910111213141516171819202122232425262728293031//Script here//var st =getVariable(\"StTime\",'2021-01-01')//var end =getVariable(\"End\",'2021-7-27')//Alert(\"st:\"+st+\"end:\"+end)var stDate =StTime;// str2date(st,'yyyy-MM-dd')var endDate =End;// str2date(end,'yyyy-MM-dd')if(stDate==null|| endDate==null) { //Alert(\"error\") false;}else{var diff = dateDiff(stDate,endDate,'d')var flag = false;if(diff&gt;=1){ var nextDate =dateAdd(stDate,'d',1); //Alert(\"next:\"+nextDate) var strDate=date2str(stDate,'yyyy-MM-dd'); var strNextDate = date2str(nextDate,'yyyy-MM-dd'); //setVariable(\"StTime\",strNextDate,‘p’) //Alert(\"开始时间:\"+strDate+\"结束时间:\"+strNextDate) return true}else {return false}} 定时启动无界面kettle任务使用CMD脚本+windows任务计划程序实现定时启动作业执行。耗时在2小时以内的作业可以使用脚本方式，执行时间长的作业最好使用spoon窗口程序执行，不会存在执行一半退出的情况。bat文件保存要按ANSI编码进行保存 Task.bat1234567891011121314@REM @echo off@REM if \"%1\" == \"h\" goto begin@REM mshta vbscript:createobject(\"wscript.shell\").run(\"%~nx0 h\",0)(window.close)&amp;&amp;exit@REM :begin:: Kitchen.bat所在路径盘符?D::: Kitchen.bat所在目录? ? ?cd D:\\PDI\\data-integration\\:: 作业（job）文件路径和日志文件路径:: 执行kitchen执行job，并写入日志Kitchen.bat /file:F:\\pdi-ce-9.1.0.0-324\\WorkSpace\\测试.kjb /level:Base &gt;F:\\pdi-ce-9.1.0.0-324\\Log Kitchen.bat参数详细说明：Use Command Line Tools to Run Transformations and Jobs 参考资料Kettle系列教程-第一章kettle-数据同步比较数据（删除更新）Kettle之定时运行Jobkettle教程—kettle作业调度，根据更新时间增量更新Kettle实现循环增量抽取数据Learn About the PDI Client (Spoon)-官方文档Use Command Line Tools to Run Transformations and Jobs","link":"/2021/08/03/kettle%E5%A1%AB%E5%9D%91/"},{"title":"docker初识","text":"Docker容器与镜像的关系类似于面向对象编程中的对象与类。 Docker 面向对象 容器 对象 镜像 类 安装参考：Ubuntu Docker 安装 docker命令列出docker的命令帮助，在docker xx 后面 加上 --help 可以查看具体的命令用法和参数注解 cmd-help.sh1docker --help 创建镜像列出所有镜像： 1docker images -a 获取一个新的ubuntu 13.10版本镜像 1docker pull ubuntu:13.10 查找centos镜像 1docker search centos 删除ubuntu镜像 1docker rmi ubuntu 创建镜像1、从已经创建的容器中更新镜像，并且提交这个镜像2、使用 Dockerfile 指令来创建一个新的镜像 创建容器容器管理命令 code 操作 备注 docker ps 查看正在运行的容器 docker ps -s -a 查看当前所有容器 docker stop 容器名称 停止容器 docker restart 容器名称 重启容器 docker kill 容器名称 杀死容器 docker rm -f 镜像ID或者镜像名 删除已经停止的容器 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 运行容器 docker run --name mynginx -d nginx:latest 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。 OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 example运行一个新容器，映射至5600端口，挂载目录 1docker run -dit -v $PWD/ql/config:/ql/config -v $PWD/ql/log:/ql/log -v $PWD/ql/db:/ql/db -v $PWD/ql/repo:/ql/repo -v $PWD/ql/raw:/ql/raw -v $PWD/ql/scripts:/ql/scripts -v $PWD/ql/jbot:/ql/jbot -p 5600:5600 --name qinglong --hostname qinglong --restart always whyour/qinglong:latest 摘录docker镜像管理命令查看本地镜像 docker images #查看当前机器的所有镜像 docker images –q # 查看所用镜像的id docker search 镜像名称 #搜索镜像，网络中查找需要的镜像 docker pull 镜像名称 #从Docker仓库拉取镜像，名称:版本号 docker push 镜像名称 #推送镜像 docker rmi 镜像名称/镜像id #删除本地机器的镜像 docker rmi docker images -q # 删除所有本地镜像 docker tag 镜像名称:tag 镜像名称:tag #为一个镜像打tag docker save {image_name} &gt; {new_image_name}.tar #镜像打包成一个tar包 docker load &lt; {image_name}.tar #解压一个镜像tar包 docker查看日志信息docker logs -f 容器名称 #查看容器日志 docker info #查看docker服务的信息 docker inspect 容器名称 # 获取镜像的元信息，详细信息 与容器交互的命令进入正在运行的容器docker exec -it 容器ID或者容器名 /bin/bash exec的意思是在容器中运行⼀个命令。 /bin/bash是固有写法，作用是因为docker后台必须运行一个进程，否则容器就会退出，在这里表示启动容器后启动 bash。 退出容器exit #退出也关闭容器; Ctrl+P+Q #退出不关闭容器 创建启动容器时，使用–v参数设置数据卷docker run … –v 宿主机目录/文件:容器内目录/文件 数据卷宿主机的一个目录或文件 目录必须是绝对路径 如果目录不存在，会自动创建 可以挂载多个数据卷 拷贝文件docker cp 主机文件路径 容器ID或容器名:容器路径 #宿主机文件拷贝到容器中 docker cp 容器ID或容器名:容器路径 主机文件路径 #容器文件拷贝到宿主机中","link":"/2021/08/13/docker%E5%88%9D%E8%AF%86/"},{"title":"Dockerfile笔记","text":"","link":"/2021/08/14/Dockerfile%E7%AC%94%E8%AE%B0/"},{"title":"yapi-docker部署","text":"部署步骤使用DockerCompose构建部署Yapi.md 填坑docker images生成部署时。发现docker-entrypoint.sh没有初始化数据库，只有运行代码，没有添加初始化命令： npm run install-server //安装程序，初始化数据库索引和管理员账号，管理员账号名可在 config.json 配置` 补救措施： 123456[root@VM-4-16-centos /]# docker exec -it 2e43588c8b1f bashroot@2e43588c8b1f:/# node api/vendors/server/install.js (node:65) DeprecationWarning: current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.log: mongodb load success...初始化管理员账号成功,账号名：\"xxxxx@gmail.com\"，密码：\"ymfe.org\" config.json内容如下： 12345678910111213{\"port\": \"3000\", \"adminAccount\": \"admin@admin.com\",//yapi管理员账号 \"timeout\":120000, \"db\": { \"servername\": \"192.168.0.1\", \"DATABASE\": \"yapi\", \"port\": 27017, \"user\": \"yapi\", \"pass\": \"123456\", \"authSource\": \"\" }} 参考 Docker部署YApi和使用问题顶尖 API 文档管理工具 (YAPI)","link":"/2021/08/14/yapi-docker%E9%83%A8%E7%BD%B2/"},{"title":"MongoDb初识","text":"https://www.cnblogs.com/my-blogs-for-everone/articles/9749842.html MongoDb 命令查询所有数据库列表 1show dbs 如果想查看当前连接在哪个数据库下面，可以直接输入dbdb 切换到test数据库下面use test 想查看test下有哪些表或者叫collection，可以输入show collections 想知道mongodb支持哪些命令，可以直接输入helphelp 想知道当前数据库支持哪些方法db.help(); 想知道当前数据库下的表或者表collection支持哪些方法，可以使用以下命令db.user.help(); user为表名 根据条件查找数据通过条件查询： db.foo.find( { x : 77 } , { name : 1 , x : 1 } ) 超级用户相关： #增加或修改用户密码 db.addUser('admin','pwd') #查看用户列表 db.system.users.find() #用户认证 db.auth('admin','pwd') #删除用户 db.removeUser('mongodb') #查看所有用户 show users #查看所有数据库 show dbs #查看所有的collection show collections #查看各collection的状态 db.printCollectionStats() #查看主从复制状态 db.printReplicationInfo() #修复数据库 db.repairDatabase() #设置记录profiling，0=off 1=slow 2=all db.setProfilingLevel(1) #查看profiling show profile #拷贝数据库 db.copyDatabase('mail_addr','mail_addr_tmp') #删除collection db.mail_addr.drop() #删除当前的数据库 db.dropDatabase() 客户端连接 /usr/local/mongodb/bin/mongo user_addr -u user -p 'pwd' 增删改 #存储嵌套的对象 db.foo.save({'name':'ysz','address':{'city':'beijing','post':100096},'phone':[138,139]}) #存储数组对象 db.user_addr.save({'Uid':'yushunzhi@sohu.com','Al':['test-1@sohu.com','test-2@sohu.com']}) #根据query条件修改，如果不存在则插入，允许修改多条记录 db.foo.update({‘yy’:5},{‘$set’:{‘xx’:2}},upsert=true,multi=true) #删除yy=5的记录 db.foo.remove({'yy':5}) #删除所有的记录 db.foo.remove() 索引 增加索引：1(ascending),-1(descending) db.things.ensureIndex({firstname: 1, lastname: 1}, {unique: true}); #索引子对象 db.user_addr.ensureIndex({'Al.Em': 1}) #查看索引信息 db.deliver_status.getIndexes() db.deliver_status.getIndexKeys() #根据索引名删除索引 db.user_addr.dropIndex(‘Al.Em_1’) 查询 查找所有 db.foo.find() #查找一条记录 db.foo.findOne() #根据条件检索10条记录 db.foo.find({'msg':'Hello 1'}).limit(10) #sort排序 db.deliver_status.find({'From':'yushunzhi@sohu.com'}).sort({'Dt',-1}) db.deliver_status.find().sort({'Ct':-1}).limit(1) #count操作 db.user_addr.count() #distinct操作 db.foo.distinct(‘msg’)#&gt;操作 db.foo.find({“timestamp”: {“$gte” : 2}}) #子对象的查找 db.foo.find({‘address.city’:’beijing’}) 管理 查看collection数据的大小 db.deliver_status.dataSize() #查看colleciont状态 db.deliver_status.stats() #查询所有索引的大小 db.deliver_status.totalIndexSize()","link":"/2021/09/01/MongoDb%E5%88%9D%E8%AF%86/"},{"title":"Markdown语法速查表","text":"总览此 Markdown 语法速查表提供了所有 Markdown 语法元素的快速参考。但是此速查表无法涵盖所有极限用法，因此，如果您需要某些语法元素的详细信息，请参阅我们的 basic syntax 和 extended syntax 手册。 基本语法这些是 John Gruber 的原始设计文档中列出的元素。所有 Markdown 应用程序都支持这些元素。 元素 Markdown 语法 Heading # H1## H2### H3 Bold **bold text** Italic *italicized text* Blockquote &gt; blockquote Ordered List 1. First item 2. Second item 3. Third item Unordered List - First item - Second item - Third item Code `code` Horizontal Rule --- Link [title](https://www.example.com) Image ![alt text](image.jpg) 扩展语法这些元素通过添加额外的功能扩展了基本语法。但是，并非所有 Markdown 应用程序都支持这些元素。 Element Markdown Syntax Table | Syntax | Description | | ----------- | ----------- | | Header | Title | | Paragraph | Text | Fenced Code Block ``` { &nbsp;&nbsp;\"firstName\": \"John\", &nbsp;&nbsp;\"lastName\": \"Smith\", &nbsp;&nbsp;\"age\": 25 } ``` Footnote Here's a sentence with a footnote. [^1] [^1]: This is the footnote. Heading ID ### My Great Heading","link":"/2021/10/21/Markdown%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%E8%A1%A8/"},{"title":"sql server 中的数组和列表（转载）","text":"转载自：Arrays and Lists in SQL Server-The Short Version 原文摘录Two Simple Multi-Statement FunctionsIf you search the web, there is no end of functions to split strings into table format. Here, I will present two simple functions that run on SQL 2008 or later, one for a list of integers and one for a list of strings. I should immediately warn you that these functions are not the most efficient and therefore not suitable if you have long lists with thousands of elements. But they are perfectly adequate if you are passing the contents of a multi-choice checkbox from a client where you would rarely have as many as 50 elements. I opted to share these functions because they are simple and you can easily adapt them if you want different behaviour with regards to the choices that I have made. In my long article, I describe methods that are faster, but they all require extra setup than just a function. Below is a function to split a delimited list of integers. The function accepts a parameter for the delimiter which can be up to 10 characters long. The function returns the list positions for the elements. An empty element is returned as NULL. If there is a non-numeric value in the list, there will be a conversion error. sql12345678910111213141516171819202122CREATE FUNCTION intlist_to_tbl (@list nvarchar(MAX), @delim nvarchar(10)) RETURNS @tbl TABLE (listpos int NOT NULL IDENTITY(1,1), n int NULL) ASBEGIN DECLARE @pos int = 1, @nextpos int = 1, @valuelen int, @delimlen int = datalength(@delim) / 2 WHILE @nextpos &gt; 0 BEGIN SELECT @nextpos = charindex(@delim COLLATE Czech_BIN2, @list, @pos) SELECT @valuelen = CASE WHEN @nextpos &gt; 0 THEN @nextpos ELSE len(@list) + 1 END - @pos INSERT @tbl (n) VALUES (convert(int, nullif(substring(@list, @pos, @valuelen), ''))) SELECT @pos = @nextpos + @delimlen END RETURNEND You are likely to be puzzled by the COLLATE clause. This is a small speed booster. By forcing a binary collation, we avoid that SQL Server employs the full Unicode rules when searching for the delimiter. This pays off when scanning long strings. Why Czech? The language does not matter here, so I just picked one with a short name. And why datalength divided by 2 and not len? datalength returns the length in bytes, whence the division. len does not count trailing spaces, so it does not work if the delimiter is a space. Here are two examples: sql12SELECT * FROM intlist_to_tbl('1,2,3, 677,7 , ,-1', ',')SELECT * FROM intlist_to_tbl('1&lt;-&gt;2&lt;-&gt;3&lt;-&gt; 677&lt;-&gt;7&lt;-&gt;&lt;-&gt;-1', '&lt;-&gt;') Since the values are the same in both lists, the output is the same: listpos n 1 1 2 2 3 3 4 677 5 7 6 NULL 7 -1 Here is an example of how you would use it in a simple query: sql123SELECT ...FROM tbl WHERE col IN (SELECT n FROM intlist_to_tbl('1,2,3,4', ',')) If you find that you are only using comma-separated lists, you may grow tired of having to specify the delimiter every time. To that end, this wrapper can be handy: sql1234CREATE FUNCTION intlisttotbl (@list nvarchar(MAX)) RETURNS TABLE ASRETURN ( SELECT listpos, n FROM intlist_to_tbl(@list, ',')) I leave it as an exercise to the reader to come up with a better name. Here is a function for a list of strings. It accepts an input parameter of the type nvarchar(MAX), but the return table has both a varchar and an nvarchar column. I will return to why in a second. Like intlist_to_tbl it returns the list position. It trims leading and trailing spaces. In difference to intlist_to_tbl, empty elements are returned as empty strings and not as NULL. sql12345678910111213141516171819202122232425CREATE FUNCTION strlist_to_tbl (@list nvarchar(MAX), @delim nvarchar(10)) RETURNS @tbl TABLE (listpos int NOT NULL IDENTITY(1,1), str varchar(4000) NOT NULL, nstr nvarchar(4000) NOT NULL) ASBEGIN DECLARE @pos int = 1, @nextpos int = 1, @valuelen int, @nstr nvarchar(4000), @delimlen int = datalength(@delim) / 2 WHILE @nextpos &gt; 0 BEGIN SELECT @nextpos = charindex(@delim COLLATE Czech_BIN2, @list, @pos) SELECT @valuelen = CASE WHEN @nextpos &gt; 0 THEN @nextpos ELSE len(@list) + 1 END - @pos SELECT @nstr = ltrim(rtrim(substring(@list, @pos, @valuelen))) INSERT @tbl (str, nstr) VALUES (@nstr, @nstr) SELECT @pos = @nextpos + @delimlen END RETURNEND Here are two examples: sql12SELECT * FROM strlist_to_tbl(N'Alpha (α) | Beta (β)|Gamma (γ)|Delta (δ)|', '|')SELECT * FROM strlist_to_tbl(N'a///b///c///v///x', '///') Here is the output: listpos | str | nstr|:–:|:–:|:–:|1 | Alpha (a)| Alpha (α)2 | Beta (ß) | Beta (β)3 | Gamma (?)| Gamma (γ)4 | Delta (d)| Delta (δ)5 | | | listpos | str | nstr|:–:|:–:|:–:|1 | a | a2 | b | b3 | c | c4 | v | v5 | x | x Note in the first result set that the Greek characters has been replaced by fallback characters in the str column. They are unchanged in the nstr column. (If you have a Greek or a UTF-8 collation, the two columns will be identical, though.) Here are two examples of using this function: sql1234567SELECT ...FROM tbl WHERE varcharcol IN (SELECT str FROM strlist_to_tbl('a,b,c', ','))SELECT ...FROM tbl WHERE nvarcharcol IN (SELECT nstr FROM strlist_to_tbl('a,b,c', ',')) These examples illustrate why there are two columns. If you are going to use the list against a varchar column, you need to use the str column. This is important because of the type-conversion rules in SQL Server. If you mistakenly compare varcharcol to nstr, varcharcol will be converted to nvarchar, and this can render any index on varcharcol ineligible for the query, leading to a performance disaster as the table must be scanned. And conversely, if you have an nvarchar column, you need to compare it to the nvarchar value, since else the result can be incorrect because of the character replacement with the conversion to varchar. I like to point out that these functions are by no means cast in stone, but see them as suggestions. Feel free to modify them according to your preferences and needs.","link":"/2021/10/21/sqlserver%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"},{"title":"判断文件类型【一】","text":"引言现有一文件，其扩展名未知或标记错误。假设它是一个正常的、非空的文件，且将扩展名更正后可以正常使用，那么，如何判断它是哪种类型的文件？ 思路使用文件签名来判断实际文件类型，又称magic numbers 或 Magic Bytes。关于文件签名介绍，参考List of file signatures Magic Number: magic number是嵌入在文件开头或附近的数字，指示其文件格式（即文件的类型）。 我们看不到这个数字。 每个文件都有一个数字，代表文件类型的名称，它是十六进制格式。 C#实现参考： C#实现example.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class MimeType{ private static readonly byte[] BMP = { 66, 77 }; private static readonly byte[] DOC = { 208, 207, 17, 224, 161, 177, 26, 225 }; private static readonly byte[] EXE_DLL = { 77, 90 }; private static readonly byte[] GIF = { 71, 73, 70, 56 }; private static readonly byte[] ICO = { 0, 0, 1, 0 }; private static readonly byte[] JPG = { 255, 216, 255 }; private static readonly byte[] MP3 = { 255, 251, 48 }; private static readonly byte[] OGG = { 79, 103, 103, 83, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0 }; private static readonly byte[] PDF = { 37, 80, 68, 70, 45, 49, 46 }; private static readonly byte[] PNG = { 137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82 }; private static readonly byte[] RAR = { 82, 97, 114, 33, 26, 7, 0 }; private static readonly byte[] SWF = { 70, 87, 83 }; private static readonly byte[] TIFF = { 73, 73, 42, 0 }; private static readonly byte[] TORRENT = { 100, 56, 58, 97, 110, 110, 111, 117, 110, 99, 101 }; private static readonly byte[] TTF = { 0, 1, 0, 0, 0 }; private static readonly byte[] WAV_AVI = { 82, 73, 70, 70 }; private static readonly byte[] WMV_WMA = { 48, 38, 178, 117, 142, 102, 207, 17, 166, 217, 0, 170, 0, 98, 206, 108 }; private static readonly byte[] ZIP_DOCX = { 80, 75, 3, 4 }; public static string GetMimeType(byte[] file, string fileName) { string mime = \"application/octet-stream\"; //DEFAULT UNKNOWN MIME TYPE //Ensure that the filename isn't empty or null if (string.IsNullOrWhiteSpace(fileName)) { return mime; } //Get the file extension string extension = Path.GetExtension(fileName) == null ? string.Empty : Path.GetExtension(fileName).ToUpper(); //Get the MIME Type if (file.Take(2).SequenceEqual(BMP)) { mime = \"image/bmp\"; } else if (file.Take(8).SequenceEqual(DOC)) { mime = \"application/msword\"; } else if (file.Take(2).SequenceEqual(EXE_DLL)) { mime = \"application/x-msdownload\"; //both use same mime type } else if (file.Take(4).SequenceEqual(GIF)) { mime = \"image/gif\"; } else if (file.Take(4).SequenceEqual(ICO)) { mime = \"image/x-icon\"; } else if (file.Take(3).SequenceEqual(JPG)) { mime = \"image/jpeg\"; } else if (file.Take(3).SequenceEqual(MP3)) { mime = \"audio/mpeg\"; } else if (file.Take(14).SequenceEqual(OGG)) { if (extension == \".OGX\") { mime = \"application/ogg\"; } else if (extension == \".OGA\") { mime = \"audio/ogg\"; } else { mime = \"video/ogg\"; } } else if (file.Take(7).SequenceEqual(PDF)) { mime = \"application/pdf\"; } else if (file.Take(16).SequenceEqual(PNG)) { mime = \"image/png\"; } else if (file.Take(7).SequenceEqual(RAR)) { mime = \"application/x-rar-compressed\"; } else if (file.Take(3).SequenceEqual(SWF)) { mime = \"application/x-shockwave-flash\"; } else if (file.Take(4).SequenceEqual(TIFF)) { mime = \"image/tiff\"; } else if (file.Take(11).SequenceEqual(TORRENT)) { mime = \"application/x-bittorrent\"; } else if (file.Take(5).SequenceEqual(TTF)) { mime = \"application/x-font-ttf\"; } else if (file.Take(4).SequenceEqual(WAV_AVI)) { mime = extension == \".AVI\" ? \"video/x-msvideo\" : \"audio/x-wav\"; } else if (file.Take(16).SequenceEqual(WMV_WMA)) { mime = extension == \".WMA\" ? \"audio/x-ms-wma\" : \"video/x-ms-wmv\"; } else if (file.Take(4).SequenceEqual(ZIP_DOCX)) { mime = extension == \".DOCX\" ? \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" : \"application/x-zip-compressed\"; } return mime; }} 进制转换摘录部份常用文件HEX签名,来源GCK’S FILE SIGNATURES TABLE 十六进制签名 ASCII 签名 文件扩展名 文件描述 50 4B 03 04 PK.. ZIP PKZIP archive file (Ref. 1 Ref. 2) Trailer: filename 50 4B 17 characters 00 00 00 Trailer: (filename PK 17 characters …) Note: PK are the initals of Phil Katz, co-creator of the ZIP file format and author of PKZIP. ZIP Apple Mac OS X Dashboard Widget, Aston Shell theme, Oolite eXpansion Pack, Opera Widget, Pivot Style Template, Rockbox Theme package, Simple Machines Forums theme, SubEthaEdit Mode, Trillian zipped skin, Virtual Skipper skin APK Android package JAR Java archive; compressed file package for classes and data KMZ Google Earth saved working session file KWD KWord document ODT, ODP, OTT OpenDocument text document, presentation, and text document template, respectively. OXPS Microsoft Open XML paper specification file SXC, SXD, SXI, SXW OpenOffice spreadsheet (Calc), drawing (Draw), presentation (Impress),and word processing (Writer) files, respectively. SXC StarOffice spreadsheet WMZ Windows Media compressed skin file XPI Mozilla Browser Archive XPS XML paper specification file XPT eXact Packager Models HEX（十六进制）转换byte数组javascript在线计算： See the Pen HEX Convert Code Part by soyobean (@soyobean) on CodePen. 资料：Mime-Detective 文件签名表格：GCK’S FILE SIGNATURES TABLE 参考资料：Magic numberList of file signatures 拓展阅读：byte为什么要与上0xff？","link":"/2021/12/01/%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"【C#】SqlBulkCopy实现SQLSRVER批量插入","text":"参考： SqlBulkCopy 类http://raylei.cn/index.php/archives/74/https://www.cxybb.com/article/weixin_30333885/96361368 问题 来自数据源的 Decimal 类型的给定值不能转换为指定目标列的类型 datetime 实际情况可能很复杂，使用的是泛型进行实体类转DataTable,可能会出现各种类型错误提示。 自己使用的是调用Copy()方法。 demo: demo.cs1234567891011121314151617var TableStruct = dal.GetTableStruct();DataTable dataTable = TableStruct.Clone();foreach (var item in oD.ToList&lt;StdYpkcday&gt;()){ DataRow dataRow = dataTable.NewRow(); dataRow[\"id\"] = DBNull.Value;//自增主键。赋值DBNull.Value dataRow[\"code\"] = item.Hoscode; if (item.Gqsj == null ) { dataRow[\"time\"] = DBNull.Value; } else { dataRow[\"time\"] = item.Gqsj; } dataTable.Rows.Add(dataRow);} 参考：https://stackoverflow.com/questions/18140012/sqlbulkcopy-the-given-value-of-type-string-from-the-data-source-cannot-be-conv Demo删除并批量插入.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/// &lt;summary&gt;/// 删除并批量插入/// &lt;/summary&gt;/// &lt;param name=\"_Type\"&gt;&lt;/param&gt;/// &lt;param name=\"TableName\"&gt;批量插入数据的表名&lt;/param&gt;/// &lt;param name=\"Dt\"&gt;批量插入的数据&lt;/param&gt;/// &lt;param name=\"SqlDeleteText\"&gt;删除的sql语句&lt;/param&gt;public void DeleteAndBulkCopy(string Type,string TableName, DataTable Dt, string SqlDeleteText,bool isIncreaPK){ using (SqlConnection conn = new SqlConnection(DBUtility.DbCommon.GetConnectString(Type))) { conn.Open(); using (SqlTransaction transaction = conn.BeginTransaction()) { SqlCommand sqlcom = conn.CreateCommand(); sqlcom.Transaction = transaction; sqlcom.CommandText = SqlDeleteText; var BulkCopyOptions = SqlBulkCopyOptions.KeepIdentity; //自增主键，使用系统生成主键 if (isIncreaPK) { BulkCopyOptions = SqlBulkCopyOptions.Default; } using (SqlBulkCopy bulk = new SqlBulkCopy(conn, BulkCopyOptions, transaction)) { if (Dt.Rows.Count &gt; 0) { for (int i = 0; i &lt; Dt.Columns.Count; i++) { bulk.ColumnMappings.Add(Dt.Columns[i].ColumnName, Dt.Columns[i].ColumnName); } bulk.BatchSize = Dt.Rows.Count; bulk.DestinationTableName = TableName; } try { sqlcom.ExecuteNonQuery(); bulk.WriteToServer(Dt); transaction.Commit(); } catch (Exception ex) { transaction.Rollback(); } finally { bulk.Close(); conn.Close(); } } } }} 批量更新.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#region 批量更新/// &lt;summary&gt;/// 批量更新/// &lt;/summary&gt;/// &lt;param name=\"dataTable\"&gt;&lt;/param&gt;/// &lt;param name=\"crateTemplateSql\"&gt;/// eg:/// [xxx] varchar(255) NOT NULL,[xxx] varchar(10) NOT NULL/// &lt;/param&gt;/// &lt;param name=\"updateSql\"&gt;/// eg:/// UPDATE bulktest set bulktest.name=Temp.tempname /// FROM bulktest INNER JOIN #TmpTable Temp /// ON Temp.temprdn = bulktest.rdn ; /// DROP TABLE #TmpTable/// &lt;/param&gt;public void SqlBulkCopyUpdate(DataTable dataTable, string crateTemplateSql, string updateSql){ using (SqlConnection conn = new SqlConnection(DBUtility.DbCommon.GetConnectString(DBType))) { using (var command = new SqlCommand(\"\", conn)) { try { conn.Open(); //数据库并创建一个临时表来保存数据表的数据 command.CommandText = $\" CREATE TABLE #TmpTable ({crateTemplateSql})\"; command.ExecuteNonQuery(); //使用SqlBulkCopy 加载数据到临时表中 using (var bulkCopy = new SqlBulkCopy(conn)) { foreach (DataColumn dcPrepped in dataTable.Columns) { bulkCopy.ColumnMappings.Add(dcPrepped.ColumnName, dcPrepped.ColumnName); } bulkCopy.BulkCopyTimeout = 660; bulkCopy.DestinationTableName = \"#TmpTable\"; bulkCopy.WriteToServer(dataTable); bulkCopy.Close(); } // 执行Command命令 使用临时表的数据去更新目标表中的数据 然后删除临时表 command.CommandTimeout = 300; command.CommandText = updateSql; int rows = command.ExecuteNonQuery(); } catch(Exception ex) { throw ex; } finally { conn.Close(); } } }}#endregion","link":"/2021/12/11/SqlBulkCopy%E5%AE%9E%E7%8E%B0SQLSRVER%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/"},{"title":"redis初识","text":"Windows安装Redis下载地址：https://github.com/tporadowski/redis 部署为服务命令行进入安装目录/解压目录 安装服务: redis-server.exe –service-install redis.windows.conf –loglevel verbose 卸载服务：redis-server –service-uninstall 开启服务：redis-server –service-start 停止服务：redis-server –service-stop 重命名服务：redis-server –service-name name 以下将会安装并启动三个不同的Redis实例作服务： 1234567891011redis-server --service-install --service-name redisService1 --port 10001redis-server --service-start --service-name redisService1redis-server --service-install --service-name redisService2 --port 10002redis-server --service-start --service-name redisService2redis-server --service-install --service-name redisService3 --port 10003redis-server --service-start --service-name redisService3","link":"/2022/01/05/redis%E5%88%9D%E8%AF%86/"},{"title":"【Csharp】Thread匿名方法初识","text":"片段代码笔记 12345678910111213141516171819202122232425262728293031323334353637383940414243/// &lt;summary&gt;/// 停止创建运行新任务和新线程，等待所有任务和线程执行完成。/// &lt;/summary&gt;private void StopRuningTaskOrThreadAndExitOrRestart(bool restartFlag){ timer1.Enabled = false;//停止触发 if (switchstr == \"1\" &amp;&amp; threadswitchstr == \"1\") { Thread t = new Thread((flag) =&gt; { while (threadUseNum &gt; 0) { Thread.Sleep(5000); RefreshMsgBox(DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\") + $\"\\t=&gt;\\t等待子任务执行完成退出：子任务数量：{threadUseNum}\"); } if ((bool)flag) { Process.Start(Application.ExecutablePath); } Environment.Exit(0); }); t.IsBackground = true; t.Start(restartFlag); } else if (switchstr == \"1\") { Thread t = new Thread((flag) =&gt; { if (taskThread != null) { taskThread.Wait();//等待执行完成 } if ((bool)flag) { Process.Start(Application.ExecutablePath); } Environment.Exit(0); }); t.IsBackground = true; t.Start(restartFlag); }}","link":"/2022/01/06/%E3%80%90Csharp%E3%80%91Thread%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E5%88%9D%E8%AF%86/"},{"title":"VUE初识","text":"安装安装方式： CDN NPM VUE-CLI CDN1234&lt;!-- V2.x --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- V3.x最新版本 --&gt;&lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt; NPM1234# V2.x最新稳定版npm install vue# V3.x最新稳定版$ npm install vue@next VUE-CLI123npm install -g @vue/cli# 升级npm update -g @vue/cli 创建项目VUE-CLIVUE Create12# 创建一个新项目,跳过 git 初始化vue create hello-world -n 123456789101112131415161718192021vue create --help用法：create [options] &lt;app-name&gt;创建一个由 `vue-cli-service` 提供支持的新项目选项： -p, --preset &lt;presetName&gt; 忽略提示符并使用已保存的或远程的预设选项 -d, --default 忽略提示符并使用默认预设选项 -i, --inlinePreset &lt;json&gt; 忽略提示符并使用内联的 JSON 字符串预设选项 -m, --packageManager &lt;command&gt; 在安装依赖时使用指定的 npm 客户端 -r, --registry &lt;url&gt; 在安装依赖时使用指定的 npm registry -g, --git [message] 强制 / 跳过 git 初始化，并可选的指定初始化提交信息 -n, --no-git 跳过 git 初始化 -f, --force 覆写目标目录可能存在的配置 -c, --clone 使用 git clone 获取远程预设选项 -x, --proxy 使用指定的代理创建项目 -b, --bare 创建项目时省略默认组件中的新手指导信息 -h, --help 输出使用帮助信息 VUE UI1vue ui 拉取 2.x 模板 (旧版本)Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具： 123npm install -g @vue/cli-init# `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同vue init webpack my-project 运行VUE-CLI在一个 Vue CLI 项目中，@vue/cli-service 安装了一个名为 vue-cli-service 的命令。你可以在 npm scripts 中以 vue-cli-service、或者从终端中以 ./node_modules/.bin/vue-cli-service 访问这个命令。 这是你使用默认 preset 的项目的 package.json： package.json123456{ \"scripts\": { \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\" }} 123npm run serve# ORnpx vue-cli-service serve 123456789101112vue-cli-service serve用法：vue-cli-service serve [options] [entry]选项： --open 在服务器启动时打开浏览器 --copy 在服务器启动时将 URL 复制到剪切版 --mode 指定环境模式 (默认值：development) --host 指定 host (默认值：0.0.0.0) --port 指定 port (默认值：8080) --https 使用 https (默认值：false) 123456789101112131415vue-cli-service build用法：vue-cli-service build [options] [entry|pattern]选项： --mode 指定环境模式 (默认值：production) --dest 指定输出目录 (默认值：dist) --modern 面向现代浏览器带自动回退地构建应用 --target app | lib | wc | wc-async (默认值：app) --name 库或 Web Components 模式下的名字 (默认值：package.json 中的 \"name\" 字段或入口文件名) --no-clean 在构建项目之前不清除目标目录 --report 生成 report.html 以帮助分析包内容 --report-json 生成 report.json 以帮助分析包内容 --watch 监听文件变化 构建部署","link":"/2022/02/14/VUE%E5%88%9D%E8%AF%86/"},{"title":"nodejs单线程？非阻塞I&#x2F;O？异步？","text":"像java、python这个可以具有多线程的语言。多线程同步模式是这样的，将cpu分成几个线程，每个线程同步运行。 而node.js采用单线程异步非阻塞模式，也就是说每一个计算独占cpu，遇到I/O请求不阻塞后面的计算，当I/O完成后，以事件的方式通知，继续执行计算2。 JavaScript是单线程执行【CPU单核】，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。 JavaScript 的确是单线程的异步是浏览器的 JavaScript 引擎做的工作 问题二：nodejs既然是单线程，如何实现异步、非阻塞I/O？顺便回答标题nodejs真的是单线程吗？其实只有javascript执行是单线程，I/O显然是其它线程。 js执行线程是单线程，把需要做的I/O交给libuv，自己马上返回做别的事情，然后libuv在指定的时刻回调就行了。其实简化的流程就是这样子的！ 细化一点，nodejs会先从js代码通过node-bindings调用到C/C++代码，然后通过C/C++代码封装一个叫 “请求对象” 的东西交给libuv，这个请求对象里面无非就是需要执行的功能+回调之类的东西，给libuv执行以及执行完实现回调。 总结来说，一个异步 I/O 的大致流程如下： 发起 I/O 调用用户通过 Javascript 代码调用 Node 核心模块，将参数和回调函数传入到核心模块；Node 核心模块会将传入的参数和回调函数封装成一个请求对象；将这个请求对象推入到 I/O 线程池等待执行；Javascript 发起的异步调用结束，Javascript 线程继续执行后续操作。执行回调I/O 操作完成后，会取出之前封装在请求对象中的回调函数，执行这个回调函数，以完成 Javascript 回调的目的。（这里回调的细节下面讲解） 从这里，我们可以看到，我们其实对 Node.js 的单线程一直有个误会。 事实上，它的单线程指的是自身 Javascript 运行环境的单线程，Node.js 并没有给 Javascript 执行时创建新线程的能力，最终的实际操作，还是通过 Libuv 以及它的事件循环来执行的。 这也就是为什么 Javascript 一个单线程的语言，能在 Node.js 里面实现异步操作的原因，两者并不冲突。 问题五、nodejs擅长什么？不擅长什么？Node.js 通过 libuv 来处理与操作系统的交互，并且因此具备了异步、非阻塞、事件驱动的能力。因此，NodeJS能响应大量的并发请求。所以，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。 上面提到，如果是 I/O 任务，Node.js 就把任务交给线程池来异步处理，高效简单，因此 Node.js 适合处理I/O密集型任务。但不是所有的任务都是 I/O 密集型任务，当碰到CPU密集型任务时，即只用CPU计算的操作，比如要对数据加解密(node.bcrypt.js)，数据压缩和解压(node-tar)，这时 Node.js 就会亲自处理，一个一个的计算，前面的任务没有执行完，后面的任务就只能干等着 。 我们看如下代码： 12345678910var start = Date.now();//获取当前时间戳setTimeout(function () { console.log(Date.now() - start); for (var i = 0; i &lt; 1000000000; i++){//执行长循环 }}, 1000);setTimeout(function () { console.log(Date.now() - start);}, 2000); 最终我们的打印结果是：（结果可能因为你的机器而不同） 1210003738 对于我们期望2秒后执行的setTimeout函数其实经过了3738毫秒之后才执行，换而言之，因为执行了一个很长的for循环，所以我们整个Node.js主线程被阻塞了，如果在我们处理100个用户请求中，其中第一个有需要这样大量的计算，那么其余99个就都会被延迟执行。如果操作系统本身就是单核，那也就算了，但现在大部分服务器都是多 CPU 或多核的，而 Node.js 只有一个 EventLoop，也就是只占用一个 CPU 内核，当 Node.js 被CPU 密集型任务占用，导致其他任务被阻塞时，却还有 CPU 内核处于闲置状态，造成资源浪费。 其实虽然Node.js可以处理数以千记的并发，但是一个Node.js进程在某一时刻其实只是在处理一个请求。 对于非阻塞的IO可以去看Unix网络编程里面定义的几种io模型。 因此，Node.js 并不适合 CPU 密集型任务。 参考： nodejs单线程？非阻塞I/O？异步？","link":"/2022/02/15/nodejs%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F%E9%9D%9E%E9%98%BB%E5%A1%9EI-O%EF%BC%9F%E5%BC%82%E6%AD%A5%EF%BC%9F/"},{"title":"前端模块化开发中webpack、npm、node、nodejs之间的关系","text":"webpack Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 webpack是一个工具，这个工具可以帮你处理好各个包/模块之间的依赖关系（modules with dependencies），并将这些复杂依赖关系的静态文件打包成一个或很少的静态文件，提供给浏览器访问使用；除此之外，webpack因为可以提高兼容性，可以将一些浏览器尚不支持的新特性转换为可以支持格式，进而减少由新特性带来的浏览器的兼容性问题 好，我们通过介绍，我们有个概念，webpack是一个打包工具，可以帮你把你的项目这里的项目其实就是指通过模块化开发的项目 打包为简洁版的浏览器可识别的静态资源 npm介绍了webpack，我们可能会疑问，我的JS，CSS，HTML文件分开写，挺好的呀，为什么要使用webpack工具，进行复杂的各项配置。在传统前端开发模式下，我们确实是按照JS/CSS/HTML文件分开写的模式就可以，但是随着前端的发展，社区的壮大，各种前端的库和框架层出不穷，我们项目中可能会使用很多额外的库，如何有效管理这些引入的库文件是一个大问题，而且我们知道基于在HTML中使用&lt;script&gt;引入的方式，有两个弊端，一个是会重复引入，二是当库文件数量很多时管理成为一个大难题。面对这样的局面，为了简化开发的复杂度，前端社区涌现了很多实践方法。模块化就是其中一项成功实践，而npm就是这样在社区 其实就是node社区中产生的 npm 为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。npm 由三个独立的部分组成： 网站 注册表（registry） 命令行工具 (CLI) 网站 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。注册表 是一个巨大的数据库，保存了每个包（package）的信息。CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。 这是npm的官方网站给出的介绍，一般来说提起npm有两个含义，一个是说npm官方网站，一个就是说npm包管理工具。npm社区或官网是一个巨大的Node生态系统，社区成员可以随意发布和安装npm生态中的包，也就是不用在重复造轮子了，别人造好了，你直接安装到你的项目中就可以使用，但是因为前面说了，当包引入数量很多时管理就成为了一个问题，这个就是npm为开发者行了方便之处，npm已经为你做好了依赖和版本的控制，也就是说使用npm可以让你从繁杂的依赖安装和版本冲突中解脱出来，进而关注你的业务而不是库的管理。 而webpack就是将你从npm中安装的包打包成更小的浏览器可读的静态资源，这里需要注意的是，webpack只是一个前端的打包工具，打包的是静态资源，和后台没有关系，虽然webpack依赖于node环境 what is node or nodejs？其实node和nodejs两个概念没有太大差别，我个人认为唯一的区别就是，人们说起node的时候语境更多的是再说node环境，而说nodejs时更多的是在说node是一门可以提供后端能力的技术。本质上来说，node就是nodejs，nodejs就是node 简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行&gt;Javascript的速度非常快，性能非常好。 node环境基于V8引擎提供了一种可以让JS代码跑在后端的能力，这就是node。其实这里的node本身和我们这篇讲的前端模块化没啥关系。但是因为npm是产生与node社区，node中也是通过npm来加载模块的，所以有必要说一下他们之间的关系。 npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制 webpack npm node之间关系？ webpack是npm生态中的一个模块，我们可以通过全局安装webpack来使用webpack对项目进行打包； webpack的运行依赖于node的环境，没有node是不能打包的，但是webpack打包后的项目本身只是前端静态资源和后台没有关系，也就是说不依赖与node，只要有后台能力的都可以部署项目 npm是于Node社区中产生的，是nodejs的官方包管理工具，当你下载安装好node的时候，npm cli就自动安装好了 正是因为npm的包管理，使得项目可以模块化的开发，而模块化的开发带来的这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别，而手动处理又是非常繁琐的，这就是webpack工具存在的意义 参考： 前端模块化开发中webpack、npm、node、nodejs之间的关系 摘录：Node.js介绍,摘自官网 Node.js12345678910111213Node.js is an open-source and cross-platform JavaScript runtime environment. It is a popular tool for almost any kind of project!Node.js runs the V8 JavaScript engine, the core of Google Chrome, outside of the browser. This allows Node.js to be very performant.A Node.js app runs in a single process, without creating a new thread for every request. Node.js provides a set of asynchronous I/O primitives in its standard library that prevent JavaScript code from blocking and generally, libraries in Node.js are written using non-blocking paradigms, making blocking behavior the exception rather than the norm.When Node.js performs an I/O operation, like reading from the network, accessing a database or the filesystem, instead of blocking the thread and wasting CPU cycles waiting, Node.js will resume the operations when the response comes back.This allows Node.js to handle thousands of concurrent connections with a single server without introducing the burden of managing thread concurrency, which could be a significant source of bugs.Node.js has a unique advantage because millions of frontend developers that write JavaScript for the browser are now able to write the server-side code in addition to the client-side code without the need to learn a completely different language.In Node.js the new ECMAScript standards can be used without problems, as you don't have to wait for all your users to update their browsers - you are in charge of deciding which ECMAScript version to use by changing the Node.js version, and you can also enable specific experimental features by running Node.js with flags. Introduction to npmnpm is the standard package manager for Node.js. In January 2017 over 350000 packages were reported being listed in &gt;the npm registry, making it the biggest single language code &gt;repository on Earth, and you can be sure there is a package for &gt;(almost!) everything. It started as a way to download and manage dependencies of Node.js &gt;packages, but it has since become a tool used also in frontend &gt;JavaScript. There are many things that npm does. Yarn and pnpm are alternatives to npm cli. You can check them out as &gt;well.","link":"/2022/02/15/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%ADwebpack%E3%80%81npm%E3%80%81node%E3%80%81nodejs%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"VUE初识【二】","text":"vue全局引入组件Vue.use()与Vue.component()的用法与区别main.js全局引入组件的两种方式 1234567// 1. Vue.use()import Alert from '@/components/alert/index.js'Vue.use(Alert)// 2. Vue.component()import Alert from \"@/components/alert/src/main.vue\"Vue.component('alert', Alert) ue.component()里面接收两个参数 第一个参数是自定义元素名称，也就是将来在别的组件中使用这个组件的标签名称。 第二个参数是将要注册的Vue组件。 Vue.use函数内部会调用参数的install方法,并且将Vue实例传入过去 Vue.use 和Vue.component 全局引入组件之间的区别： Vue.component 只是单纯的引入组件、不需要额外写支持的js文件 Vuew.use 除组件外，需要写额外的js实现install方法，但它不仅可以注入组件，还可以注入很多其他东西，比如全局实例属性等。 参考: https://juejin.cn/post/7021495820130353165http://www.zuo11.com/blog/2020/7/vue_global_comps.html","link":"/2022/02/18/VUE%E5%88%9D%E5%A7%8B%E3%80%90%E4%BA%8C%E3%80%91/"},{"title":"当按下回车时发生了什么？","text":"这个仓库试图回答一个古老的面试问题：当你在浏览器中输入 google.com 并且按下回车之后发生了什么？ 不过我们不再局限于平常的回答，而是想办法回答地尽可能具体，不遗漏任何细节。 这将是一个协作的过程，所以深入挖掘吧，并且帮助我们一起完善它。仍然有大量的细节等待着你来添加，欢迎向我们发送 Pull Requset！ 这些内容使用 Creative Commons Zero_ 协议发布。 目录按下”g”键接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 “google.com”，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 “google.com” 建议给你。 回车键按下为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。 USB键盘： 键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压 键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内 USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供 键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包 这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance） 这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层 虚拟键盘（触屏设备）： 在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标 然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮 虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息 这个消息又返回来向当前活跃的应用通知一个“按键按下”事件 产生中断[非USB键盘]键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。 (Windows)一个 WM_KEYDOWN 消息被发往应用程序HID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。 Win32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。 Windows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。 当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。 (Mac OS X)一个 KeyDown NSEvent被发往应用程序中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。 (GNU/Linux)Xorg 服务器监听键码值当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。 解析URL 浏览器通过 URL 能够知道下面的信息： Protocol “http” 使用HTTP协议 Resource “/“ 请求的资源是主页(index) 输入的是 URL 还是搜索的关键字？当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。 转换非 ASCII 的 Unicode 字符 浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符 这里主机名是 google.com ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode_ 编码 检查 HSTS 列表 浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站 如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送 注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack_ 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。 DNS 查询 浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns &lt;chrome://net-internals/#dns&gt;_）。 如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。 gethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同_ 如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。 查询本地 DNS 服务器 如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询 如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询 ARP 过程要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。 首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC 如果缓存没有命中： 查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。 查询选择的网络接口的 MAC 地址 我们发送一个二层（ OSI 模型_ 中的数据链路层）ARP 请求： ARP Request:: Sender MAC: interface:mac:address:here Sender IP: interface.ip.goes.here Target MAC: FF:FF:FF:FF:FF:FF (Broadcast) Target IP: target.ip.goes.here 根据连接主机和路由器的硬件类型不同，可以分为以下几种情况： 直连： 如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。 集线器： 如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。 交换机： 如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。 如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求 如果路由器也“连接”在其中，它会返回一个 ARP Reply ARP Reply:: Sender MAC: target:mac:address:here Sender IP: target.ip.goes.here Target MAC: interface:mac:address:here Target IP: interface.ip.goes.here 现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了： 使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议 如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回 使用套接字当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个TCP流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。 这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range) TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。 这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。 到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输： 以太网_ WiFi_ 蜂窝数据网络_ 对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点_ 处理。节点的目标地址和源地址将在后面讨论。 大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点_ 进行处理。 最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域(autonomous system, 缩写 AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部 time to live (TTL) 域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。 上面的发送和接受过程在 TCP 连接期间会发生很多次： 客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号 服务器端接收到 SYN 包，如果它可以建立连接： 服务器端选择它自己的初始序列号 服务器端设置 SYN 位，表明自己选择了一个初始序列号 服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包 客户端通过发送下面一个封包来确认这次连接： 自己的序列号+1 接收端 ACK+1 设置 ACK 位 数据通过下面的方式传输： 当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N 另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号 关闭连接时： 要关闭连接的一方发送一个 FIN 包 另一方确认这个 FIN 包，并且发送自己的 FIN 包 要关闭的一方使用 ACK 包来确认接收到了 FIN TLS 握手 客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。 服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥 客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥 服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥 客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值 服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密 从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容 HTTP 协议如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。 如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:: GET / HTTP/1.1 Host: google.com Connection: close [其他头部] “其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。） HTTP/1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开。例如： Connection:close 不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含 “close” 选项。 在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。 服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:: 200 OK [响应头部] 然后是一个换行，接下来有效载荷(payload)，也就是 www.google.com 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。 如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:: 304 Not Modified [响应头部] 这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。 在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET /$(相对www.google.com的URL) HTTP/1.1 。 如果HTML引入了 www.google.com 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。 HTTP 服务器请求处理HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。 HTTPD 接收请求 服务器把请求拆分为以下几个参数： HTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法 域名：google.com 请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径) 服务器验证其上已经配置了 google.com 的虚拟主机 服务器验证 google.com 接受 GET 方法 服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等) 如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求 服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。 服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者 浏览器背后的故事当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作： 解析 —— HTML，CSS，JS 渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制 浏览器浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。 浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。 不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素： 一个地址栏 后退和前进按钮 书签选项 刷新和停止按钮 主页按钮 浏览器高层架构 组成浏览器的组件有： 用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分 浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作 渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上 网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现 UI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现 Javascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码 数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制 HTML 解析浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。 HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。 解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。 解析算法 HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点: 语言本身的“宽容”特性 HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们 解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容 由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。 解析结束之后 浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。 此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。 注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。 CSS 解析 根据 CSS词法和句法_ 分析CSS文件和 &lt;style&gt; 标签包含的内容以及 style 属性的值 每个CSS文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象 CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器 页面渲染 通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值 通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点的首选(preferred)宽度 通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度 通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度 使用上面的计算结果构建每个节点的坐标 当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见http://dev.w3.org/csswg/css2/ 和 http://www.w3.org/Style/CSS/current-work 创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层 页面上的每个层都被分配了纹理(?) 每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制 上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量 计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。 GPU 渲染 在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU 当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。 Window Server后期渲染与用户引发的处理渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。 _Creative Commons Zero: https://creativecommons.org/publicdomain/zero/1.0/_CSS词法和句法: http://www.w3.org/TR/CSS2/grammar.html_Punycode: https://en.wikipedia.org/wiki/Punycode_以太网: http://en.wikipedia.org/wiki/IEEE_802.3_WiFi: https://en.wikipedia.org/wiki/IEEE_802.11_蜂窝数据网络: https://en.wikipedia.org/wiki/Cellular_data_communication_protocol_analog-to-digital converter: https://en.wikipedia.org/wiki/Analog-to-digital_converter_网络节点: https://en.wikipedia.org/wiki/Computer_network#Network_nodes不同的操作系统有所不同 : https://en.wikipedia.org/wiki/Hosts%28file%29#Location_in_the_file_system_downgrade attack: http://en.wikipedia.org/wiki/SSL_stripping_OSI 模型: https://en.wikipedia.org/wiki/OSI_model","link":"/2022/02/18/%E5%BD%93%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"},{"title":"2022年3月6日","text":"2022年3月6日早晨，外婆永远离我而去，听闻消息，心神恍惚，无法相信如此突然，高铁上想起，总是悔恨自己没能见上外婆最后一面，为什么不去看外婆，明明只需要3个小时不到，为什么这么抠门，自己真不是个东西。每每想起外婆，心中百般情绪无法平息，眼里总时会泛起泪水，都说人的一生需要童年去治愈，可自己的大半个童年的参与者突然离世，而我却没有见上最后一面，我一生都无法原谅自己。外婆生于四十年代末，是当年上山下乡运动中的一员，从广东漂泊到江西的一个山沟沟，经历的苦难是现在的我无法想象。她和大多数书中描写的上山下乡运动中的人一样，是坚强勤劳的，可她的人生为何也如多数书中描述的一样，是充满苦难的一生。到底是因为勤劳而充满苦难，还是因为人生太多苦难而勤劳?我不知道，我也不可能得到答案了。在山沟沟里，外婆辛苦操劳一生，用自己的一双手将六个孩子拉扯长大，孩子都成家后还来带我们这些孙辈，个中辛苦已无处知晓。外婆用她的言传和身教教会了我很多东西，她的一生是勤俭节约的，有什么好吃的、好玩的都先留着，等我们去放假过节去玩就拿出来给我们吃，她自己却不吃或者吃一些边角料。如今外婆离去，世上再也没有谁会特意留着屋后板栗树上的板栗，只为了等我们去玩的时候拿出来给我们吃。再也没有人会特意将枇杷树下的草除掉，等我们放暑假来摘枇杷。再也没有了，没有了。外婆是勤劳的人，她总是停不下自己的双手，孙辈也逐渐长大后，本是自己安享晚年，不用操劳的时候，她却担心儿女孙辈在外吃的不好，古稀之年一个人弄了个菜园，可最终却摔倒在了菜园。为了儿女孙辈她付出了太多，小的时候从书中读到无私奉献默默无闻时，只是纸上读来终觉浅，未曾真正理解这八个字，外婆的一生担得起这八个字，这八个字配的上外婆。外婆勤劳的背后藏着太多的苦难，她也是外太公的女儿，也是手心上的宝贝，不是谁一生下来就是农民，当年的上山下乡让一名城市女性走向一名勤劳的农民，我无法想象其中之苦，可为何如此勤劳的人一生为何如此短暂，为何在人生的最后阶段也是痛苦的，我叹这世道太过无常，叹这人间疾苦。纵使现在千丝万绪，已无力挽回。人生在世，多多陪伴家人。追悔莫及，我只恨自己，无法原谅自己。","link":"/2022/03/07/20220306/"},{"title":"SSL&#x2F;TLS及证书概述【转】","text":"SSL/TLS及证书概述 握手的交互图： 1234567891011121314151617181920+--------+ +--------+| | 1. ClientHello | || |-------------------------------------&gt;| || | | || | 2. ServerHello | || | 3. Certificate | || | 4. ServerKeyExchange (optional) | || | 5. CertificateRequest (optional) | || | 6. ServerHelloDone | || |&lt;------------------------------------ | || Client | | Server || | 7. Certificate (optional) | || | 8. ClientKeyExchange | || | 9. CertificateVerify (optional) | || | 10. Finished | || |------------------------------------&gt; | || | | || | 11. Finished | || |&lt;------------------------------------ | |+--------+ +--------+","link":"/2022/03/17/SSL-TLS%E5%8F%8A%E8%AF%81%E4%B9%A6%E6%A6%82%E8%BF%B0%E3%80%90%E8%BD%AC%E3%80%91/"},{"title":"Linux工具记录","text":"前言记录下在Linux系上常用的一些软件，工具。 软件 软件名称 运行环境 用途 备注 地址 GNOME Linux系 系统GUI 官网：GNOME VNC-View Windows/Linux… 远程控制工具软件 VNC® Viewer VNC® Server WinSCP Windows 在本地与远程计算机间安全的复制文件 是一个流行的 SFTP 客户端和 Microsoft Windows 的 FTP 客户端！使用在本地计算机和远程服务器之间复制文件FTP、FTPS、SCP、SFTP、WebDAV 或 S3 文件传输协议 WinSCP Download 命令 code 用途 备注 $PWD 当前工作路径 在Linux系统中，pwd命令用作显示工作目录的路径名称,全称是“Print Working Directory” 文件目录操作命令 code 用途 备注 mkdir testfolder 创建一个文件夹 如果不能删除或者建立的话，可以使用sudo命令，如 sudo rm -rf 文件夹名称,也可先su root，拥有root权限再操作。 rmdir testfolder 删除一个空文件夹 … rm a.txt b.txt 删除一个文件或多个文件 … rm -rf test2 删除一个非空文件夹下的一切 …","link":"/2022/04/01/Linux%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"},{"title":"kettle填坑【二】","text":"运行环境： Kettle Version 9.2 sqljdbc_6.0.8112.200 java version “1.8.0_301” MS Sql Server2016 已开启强制加密[Configuration Manager-&gt;SQL server 网络配置-&gt;MSSQLSERVER的协议-&gt;右键点击属性-&gt;Force Encryption] ktr文件中的连接配置： MSSQL类型1234567891011121314&lt;connection&gt; &lt;name&gt;测试数据库&lt;/name&gt; &lt;server&gt;192.168.1.1&lt;/server&gt; &lt;type&gt;MSSQL&lt;/type&gt; &lt;access&gt;Native&lt;/access&gt; &lt;database&gt;test&lt;/database&gt; &lt;port&gt;1433&lt;/port&gt; &lt;username&gt;sa&lt;/username&gt; &lt;password&gt;xxxxxxxxx&lt;/password&gt; &lt;servername/&gt; &lt;data_tablespace/&gt; &lt;index_tablespace/&gt; &lt;attributes&gt;xxxxxx...&lt;/attributes&gt;&lt;/connection&gt; MSSQL(NATIVE)类型12345678910111213&lt;connection&gt; &lt;name&gt;test&lt;/name&gt; &lt;server&gt;${test.server}&lt;/server&gt; &lt;type&gt;MSSQLNATIVE&lt;/type&gt; &lt;access&gt;Native&lt;/access&gt; &lt;database&gt;${test.database}&lt;/database&gt; &lt;port&gt;1433&lt;/port&gt; &lt;username&gt;${test.username}&lt;/username&gt; &lt;password&gt;${test.pwd}&lt;/password&gt; &lt;servername/&gt; &lt;data_tablespace/&gt; &lt;index_tablespace/&gt;&lt;/connection&gt; Kettle/PDI使用MS Sql Server类型连接MS Sql Server失败连接类型：MS Sql Server连接方式：Native（JDBC） 具体报错： Driver class ‘net.sourceforge.jtds.jdbc.Driver’ could not be found, make sure the ‘MS SQL Server’ driver (jar file) is installed. 解决方法：下载jtds.jar包，将文件移动到data-integration\\lib 中，下载地址：jTDS - SQL Server and Sybase JDBC driver Files Kettle/PDI使用MS Sql Server类型连接MS Sql Server失败，提示参数错误。连接类型：MS Sql Server连接方式：Native（JDBC） 具体报错： Connection failed. Verify all connection parameters and confirm that the appropriate driver is installed.I/O Error: DB server closed connection. 问题引起原因：Kettle连接数据库方法类型使用MSSQL是使用jtds连接数据库，但连接开启强制加密的数据库会提示参数缺失。 解决方法： 暂时还没找到，临时方法改用连接类型：MS Sql Server（Native） 连接方式：Native（JDBC）处理 Kettle/PDI使用MS Sql Server（Native）类型连接MS Sql Server失败，提示jar缺失连接类型：MS Sql Server（Native）连接方式：Native（JDBC） 具体报错： Driver class ‘sun.jdbc.odbc.JdbcOdbcDriver’ could not be found, make sure the ‘MS SQL Server’ driver (jar file) is installed. sun.jdbc.odbc.JdbcOdbcDriver 解决方法：从此下列链接下载sqljdbc jar文件 将其放在 data-integration/lib 文件夹中 Download Microsoft JDBC Driver 6.0 for SQL Server (tar.gz)JDBC历史版本 Kettle/PDI使用MS Sql Server（Native）类型连接MS Sql Server失败，提示无法建立安全连接连接类型：MS Sql Server（Native）连接方式：Native（JDBC） 具体报错： com.microsoft.sqlserver.jdbc.SQLServerException: 驱动程序无法通过使用安全套接字层(SSL)加密与 SQL Server 建立安全连接。错误:“The server selected protocol version TLS10 is not accepted by client preferences [TLS12]” 问题引起的原因：从1.8_171开始，会禁用3DES加密原文摘录： 3DES Cipher Suites Disabled To improve the strength of SSL/TLS connections, 3DES cipher suites have been disabled in SSL/TLS connections in the JDK via the jdk.tls.&gt;disabledAlgorithms Security Property. 解决方法：修改%JAVA_HOME%/jre/lib/security/java.security文件中数据库加密方式，找到jdk.tls.disabledAlgorithms配置节点，将TLSv1、TLSv1.1、3DES_EDE_CBC从禁止名单中剔除。 E:\\Java\\jdk1.8\\jre\\lib\\security\\java.security12345678# 原配置 ：# jdk.tls.disabledAlgorithms=SSLv3, TLSv1, TLSv1.1, RC4, DES, MD5withRSA, \\# DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \\# include jdk.disabled.namedCurves# 改动后配置：jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, \\ DH keySize &lt; 1024, EC keySize &lt; 224, anon, NULL, \\ include jdk.disabled.namedCurves 参考：https://blog.csdn.net/chch87/article/details/86504581 书签摘录 https://www.staroon.dev/categories/Kettle/https://inf.news/zh-hans/technique/549875ce18ea3b72c350f4449370c3ad.htmlhttps://xiaoym.gitee.io/2019/08/08/kettle-2/#%E9%9C%80%E6%B1%82-2https://ai.plainenglish.io/pentaho-data-integration-installation-guide-easy-yet-powerful-etl-tool-80930cff46c6https://ai.plainenglish.io/getting-started-with-pentaho-data-integration-kettle-and-its-components-ef1e71101323https://ai.plainenglish.io/what-is-the-pdi-client-spoon-in-pentaho-data-integration-kettle-df65b33879achttps://medium.com/@shravankumar.suvarnahttps://sourceforge.net/projects/pentaho/files/https://mvnrepository.com/artifact/pentaho-kettlehttps://stackoverflow.com/questions/11634181/pentaho-data-integration-sql-connectionhttps://help.hitachivantara.com/Documentation/Pentaho/9.2/Setup/JDBC_drivers_reference#r_pentaho_my_sql_jdbc_drivers_referencehttps://jira.pentaho.com/browse/PDI-11536https://jira.pentaho.com/projects/PDI/issues/PDI-16383?filter=allopenissueshttps://sourceforge.net/projects/jtds/files/","link":"/2022/04/01/kettle%E5%A1%AB%E5%9D%91%E4%BA%8C/"},{"title":"vim常用命令快捷键","text":"操作和重复操作 命令 操作 a 在当前光标位置后追加文本 :w 保存 :wq 保存并退出 :q 退出 :q! 强制退出，放弃改动 :set nu 显示行号 :set nonu 不显示行号 d 高级删除指令： dw ：删除一个单词 df ：配合 f ，删除从光标处到 ( 的字符，单行操作 dd ：删除当前行 d2w ：删除两个单词 d2t ：删除当前位置到后面第二个 , 之间的内容，不包含 , （t = to） v 选择模式，用上下左右选择文本，按相应的指令直接执行，如：选中后执行 d 就直接删除选中的文本 基础编辑，移动光标 命令 操作 $ 行尾 ^ 行首 w 下一个单词 (词首） e 下一个单词（词尾） b 前一个单词 x del 删除后一个字符 X backspace 删除前一个字符 u 撤销 ctrl+r 重做 k 上 h 下 g 左 l 右 i 插入，开始写东西 s 覆盖 esc 退出输入模式，进入普通模式，可执行各种命令 搜索 命令 操作 / 从当前位置向后搜索 ？ 从当前位置后前搜索 n 搜索完之后，如果有多个结果，跳到 下一个匹 配项 N 跳到 上一个 匹配项 * 直接匹配当前光标下面的字符串，移到下一个匹配项，跟/ ? 没有关系 # 上一个匹配项","link":"/2022/04/01/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"Nginx代理Oracle数据库连接","text":"开始使用本地1500端口反向代理 10.120.1.78:9800 得Oracle连接。 nginx.conf1234567891011121314151617181920# stream 代理,代理oracle连接stream { log_format proxy '$remote_addr [$time_local] ' '$protocol $status $bytes_sent $bytes_received ' '$session_time \"$upstream_addr\" ' '\"$upstream_bytes_sent\" \"$upstream_bytes_received\" \"$upstream_connect_time\"'; access_log logs/tcp-access.log proxy ; error_log logs/tcp_error.log; upstream oracle{ server 10.120.1.78:9800 weight=1 max_fails=2 fail_timeout=30s; } server { listen 1500 so_keepalive=on; #so_keepalive,会话保持，防止查询飘走; proxy_connect_timeout 3600s; #设置那么大，是为了防止动不动就断开连接 proxy_timeout 3600s; proxy_pass oracle; }}","link":"/2022/04/21/Nginx%E4%BB%A3%E7%90%86Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"},{"title":"Nginx代理WebService","text":"Nginx代理WebServicewebservice 为IP地址使用本地8091端口代理http://110.10.110.17:4658/calculator.asmx?wsdl 服务 nginx.conf123456789101112131415161718192021222324252627282930313233http{ upstream router { server 110.10.110.17:4658 weight=1; } server { listen 8091; server_name localhost; charset utf-8; proxy_intercept_errors on; location / { proxy_pass http://router; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto; proxy_set_header Via \"nginx\"; proxy_read_timeout 660; proxy_connect_timeout 10; proxy_send_timeout 60; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } }} 域名WebserviceNginx代理的Webservice如果是域名访问路径，需要根据被代理WebService实际的Host请求头值来配置数据使用本地8091端口代理http://www.webxml.com.cn/WebServices/WeatherWS.asmx?wsdl服务 domain_webservice_nginx.conf123456789101112http{ #其它配置相同... server { #...... location / { proxy_pass http://www.webxml.com.cn; proxy_set_header Host $proxy_host:$proxy_port; #其它配置相同... } #...... }} 重点关注几个配置项： upstream：用于配置 nginx 后端服务器（即 upstream，上游服务器），这里我们配置了两个后端服务器，并设置转发的权重分别为 2 和 1 proxy_pass：配置代码转发，即使用上面 upstream router 作为后端服务器转发 proxy_read_timeout：nginx 与后端服务器连接成功后，后端服务器响应的超时时间，即后端服务器处理请求的超时时间，由于后端服务器处理请求的最长时间为 600 秒，这里设置 660 秒 proxy_connect_timeout：nginx 与后端服务器连接的超时时间 proxy_send_timeout：后端服务器完成请求处理后，传输完整数据的超时时间先启动两个后端服务器，这两个后端服务器均对处提供 WebService 接口。然后使用 docker-compose up -d 启动 nginx 作为 WebService 接口反向代理。 客户端访问 nginx ，可以看到客户端 WebService 请求被正常转发到了两个 WebService 后端服务器处理，然后客户端通过 nginx 正常获取了后端服务器的返回结果。 原文链接：https://blog.csdn.net/lihao21/article/details/110856326","link":"/2022/04/21/Nginx%E4%BB%A3%E7%90%86WebService/"},{"title":"Nginx初始【一】","text":"Nginx 变量http://nginx.org/en/docs/varindex.html Notenginx关闭.bat1234@REM nginx命令：正常停止或关闭。即处理完所有请求后再停止服务nginx -s quit@REM cmd命令：根据程序名来关闭进程。这里强制关闭nginx.exe，防止上一步未停止nginx。注：这个命令会杀掉所有正在运行的nginxtaskkill /f /t /im nginx.exe nginx启动.bat1start nginx nginx重启.bat123456nginx -s reloadnginx -s quittaskkill /f /t /im nginx.exestart nginxnginx -Vcmd nginx重载.bat1nginx -s reload","link":"/2022/04/21/Nginx%E5%88%9D%E5%A7%8B%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"Nginx服务配置为Windows系统服务","text":"Nginx服务配置为Windows系统服务+日志处理参考引用： http://www.yaohaixiao.com/blog/how-to-configure-nginx-service-as-windows-system-service/https://www.xilixili.net/2018/01/04/winsw-with-nginx/https://github.com/winsw/winsw winsw+nginx安装步骤 下载winsw.exe文件,重命名为nginx-service.exe 创建nginx-service.xml文件。 将nginx-service.exe和nginx-service.xml放在nginx.exe的同一目录下。 运行nginx-service.exe install nginx-service.xml安装服务；winsw install 运行nginx-service.exe start nginx-service.xml运行服务；winsw install 运行nginx-service.exe status nginx-service.xml查看服务状态；winsw status CLI命令文档：https://github.com/winsw/winsw/blob/v3/docs/cli-commands.md#cli-commands配置文件说明文档：https://github.com/winsw/winsw/blob/v3/docs/xml-config-file.md配置文件示例：https://github.com/winsw/winsw/blob/v3/samples 运行目录： 1234567E:nginx│ nginx.exe├─nginx-winsw│ │ nginx-service.exe│ │ nginx-service.xml│ └─wswlogs│ nginx-service.wrapper.log 包装器及其子进程的默认工作目录是配置文件所在的目录。设置workingdirectory可以更改工作目录。 未设置workingdirectory值的情况下，设置executable为E:\\nginx\\nginx.exe，默认执行路径为E:\\nginx\\nginx-winsw\\nginx.exe 设置workingdirectory值为E:\\nginx，设置executable为E:\\nginx\\nginx.exe，执行路径为：E:\\nginx\\nginx.exe 配置文件中，&lt;logpath&gt;日志文件夹的路径是相对于nginx-service.exe所在目录，它的根目录是nginx-service.exe所在目录。受限于nginx-service.exe所在目录。不受workingdirectory值影响。 在未设置workingdirectory情况下，默认工作目录为nginx-service.exe所在目录，所以nginx-service.exe必须和nginx.exe在同一目录下才能成功启动。 sample.xml： sample.xml12345678910&lt;service&gt; &lt;id&gt;jenkins&lt;/id&gt; &lt;name&gt;Jenkins&lt;/name&gt; &lt;description&gt;This service runs Jenkins continuous integration system.&lt;/description&gt; &lt;env name=\"JENKINS_HOME\" value=\"%BASE%\"/&gt; &lt;executable&gt;java&lt;/executable&gt; &lt;arguments&gt;-Xrs -Xmx256m -jar \"%BASE%\\jenkins.war\" --httpPort=8080&lt;/arguments&gt; &lt;log mode=\"roll\"&gt;&lt;/log&gt;&lt;/service&gt; nginx-service.xml： nginx-service.xml1234567891011&lt;service&gt; &lt;id&gt;nginx&lt;/id&gt; &lt;name&gt;nginx&lt;/name&gt; &lt;description&gt;nginx服务&lt;/description&gt; &lt;logpath&gt;./logs&lt;/logpath&gt; &lt;logmode&gt;roll&lt;/logmode&gt; &lt;executable&gt;nginx.exe&lt;/executable&gt; &lt;stopexecutable&gt;nginx.exe&lt;/stopexecutable&gt; &lt;stopargument&gt;-s&lt;/stopargument&gt; &lt;stopargument&gt;stop&lt;/stopargument&gt; &lt;/service&gt; 自定义workingdirectory.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324&lt;!-- MIT License Copyright (c) 2008-2020 Kohsuke Kawaguchi, Sun Microsystems, Inc., CloudBees, Inc., Oleg Nenashev and other contributors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.--&gt;&lt;!-- This is a sample configuration of the Windows Service Wrapper. This configuration file should be placed near the WinSW executable, the name should be the same. E.g. for myapp.exe the configuration file name should be myapp.xml You can find more information about configuration options here: https://github.com/kohsuke/winsw/blob/master/doc/xmlConfigFile.md--&gt;&lt;service&gt; &lt;!-- SECTION: Mandatory options All options in other sections are optional --&gt; &lt;!-- ID of the service. It should be unique accross the Windows system--&gt; &lt;id&gt;nginxservice&lt;/id&gt; &lt;!-- Display name of the service --&gt; &lt;name&gt;Nginx Service (powered by WinSW)&lt;/name&gt; &lt;!-- Service description --&gt; &lt;description&gt;Nginx包装成Windows服务&lt;/description&gt; &lt;!-- Path to the executable, which should be started --&gt; &lt;executable&gt;E:\\nginx\\nginx.exe&lt;/executable&gt; &lt;!-- SECTION: Installation These options are being used during the installation only. Their modification will not take affect without the service re-installation. --&gt; &lt;!-- OPTION: serviceaccount Defines account, under which the service should run. --&gt; &lt;!-- &lt;serviceaccount&gt; &lt;domain&gt;YOURDOMAIN&lt;/domain&gt; &lt;user&gt;useraccount&lt;/user&gt; &lt;password&gt;Pa55w0rd&lt;/password&gt; &lt;allowservicelogon&gt;true&lt;/allowservicelogon&gt; &lt;/serviceaccount&gt; --&gt; &lt;!-- OPTION: onfailure Defines a sequence of actions, which should be performed if the managed executable fails. Supported actions: restart, reboot, none --&gt; &lt;!-- &lt;onfailure action=\"restart\" delay=\"10 sec\"/&gt; &lt;onfailure action=\"restart\" delay=\"20 sec\"/&gt; &lt;onfailure action=\"reboot\" /&gt; --&gt; &lt;!-- OPTION: resetfailure Time, after which the Windows service resets the failure status. Default value: 1 day --&gt; &lt;!-- &lt;resetfailure&gt;1 hour&lt;/resetfailure&gt; --&gt; &lt;!-- OPTION: securityDescriptor The security descriptor string for the service in SDDL form. For more information, see https://docs.microsoft.com/windows/win32/secauthz/security-descriptor-definition-language. --&gt; &lt;!--&lt;securityDescriptor&gt;&lt;/securityDescriptor&gt;--&gt; &lt;!-- SECTION: Executable management --&gt; &lt;!-- OPTION: arguments Arguments, which should be passed to the executable --&gt; &lt;!-- &lt;arguments&gt;-classpath c:\\cygwin\\home\\kohsuke\\ws\\hello-world\\out\\production\\hello-world test.Main&lt;/arguments&gt; --&gt; &lt;!-- OPTION: startarguments Arguments, which should be passed to the executable when it starts If specified, overrides 'arguments'. --&gt; &lt;!-- &lt;startarguments&gt;&lt;/startarguments&gt; --&gt; &lt;!-- OPTION: workingdirectory If specified, sets the default working directory of the executable Default value: Directory of the service wrapper executable. --&gt; &lt;workingdirectory&gt;E:\\nginx&lt;/workingdirectory&gt; &lt;!-- OPTION: priority Desired process priority. Possible values: Normal, Idle, High, RealTime, BelowNormal, AboveNormal Default value: Normal --&gt; &lt;priority&gt;Normal&lt;/priority&gt; &lt;!-- OPTION: stoptimeout Time to wait for the service to gracefully shutdown the executable before we forcibly kill it Default value: 15 seconds --&gt; &lt;stoptimeout&gt;15 sec&lt;/stoptimeout&gt; &lt;!-- OPTION: stopparentprocessfirst If set, WinSW will terminate the parent process before stopping the children. Default value: true --&gt; &lt;stopparentprocessfirst&gt;true&lt;/stopparentprocessfirst&gt; &lt;!-- OPTION: stopexecutable Path to an optional executable, which performs shutdown of the service. This executable will be used if and only if 'stoparguments' are specified. If 'stoparguments' are defined without this option, 'executable' will be used as a stop executable --&gt; &lt;stopexecutable&gt;E:\\nginx\\nginx.exe&lt;/stopexecutable&gt; &lt;!-- OPTION: stoparguments Additional arguments, which should be passed to the stop executable during termination. This OPTION also enables termination of the executable via stop executable --&gt; &lt;!-- 快速退出 --&gt; &lt;stoparguments&gt;-s stop&lt;/stoparguments&gt; &lt;!-- 退出 --&gt; &lt;!-- &lt;stoparguments&gt;-s quit&lt;/stoparguments&gt; --&gt; &lt;!-- SECTION: Service management --&gt; &lt;!-- OPTION: startmode Defines start mode of the service. Supported modes: Automatic, Manual, Boot, System (latter ones are supported for driver services only) Default mode: Automatic --&gt; &lt;startmode&gt;Automatic&lt;/startmode&gt; &lt;!-- OPTION: delayedAutoStart Enables the Delayed Automatic Start if 'Automatic' is specified in the 'startmode' field. See the WinSW documentation to get info about supported platform versions and limitations. --&gt; &lt;!--&lt;delayedAutoStart/&gt;--&gt; &lt;!-- OPTION: depend Optionally specifies services that must start before this service starts. --&gt; &lt;!-- &lt;depend&gt;Eventlog&lt;/depend&gt; &lt;depend&gt;W32Time&lt;/depend&gt; --&gt; &lt;!-- OPTION: waithint The estimated time required for a pending stop operation. Before the specified amount of time has elapsed, the service should make its next call to the SetServiceStatus function. Otherwise the service will be marked as non-responding Default value: 15 seconds --&gt; &lt;waithint&gt;15 sec&lt;/waithint&gt; &lt;!-- OPTION: sleeptime The time before the service should make its next call to the SetServiceStatus function. Do not wait longer than the wait hint. A good interval is one-tenth of the wait hint but not less than 1 second and not more than 10 seconds. Default value: 1 second --&gt; &lt;sleeptime&gt;1 sec&lt;/sleeptime&gt; &lt;!-- OPTION: interactive Indicates the service can interactwith the desktop. --&gt; &lt;!-- &lt;interactive/&gt; --&gt; &lt;!-- SECTION:Logging --&gt; &lt;!-- OPTION: logpath Sets a custom logging directory for all logs being produced by the service wrapper Default value: Directory, which contains the executor --&gt; &lt;logpath&gt;./wswlogs&lt;/logpath&gt; &lt;!-- OPTION: log Defines logging mode for logs produced by the executable. Supported modes: * append - Rust update the existing log * none - Do not save executable logs to the disk * reset - Wipe the log files on startup * roll - Roll logs based on size * roll-by-time - Roll logs based on time * rotate - Rotate logs based on size, (8 logs, 10MB each). This mode is deprecated, use \"roll\" Default mode: append Each mode has different settings. See https://github.com/kohsuke/winsw/blob/master/doc/loggingAndErrorReporting.md for more details --&gt; &lt;log mode=\"roll-by-time\"&gt; &lt;pattern&gt;yyyyMMdd&lt;/pattern&gt; &lt;/log&gt; &lt;!-- SECTION: Environment setup --&gt; &lt;!-- OPTION: env Sets or overrides environment variables. There may be multiple entries configured on the top level. --&gt; &lt;!-- &lt;env name=\"MY_TOOL_HOME\" value=\"C:\\etc\\tools\\myTool\" /&gt; &lt;env name=\"LM_LICENSE_FILE\" value=\"host1;host2\" /&gt; --&gt; &lt;!-- OPTION: download List of downloads to be performed by the wrapper before starting --&gt; &lt;!-- &lt;download from=\"http://www.google.com/\" to=\"%BASE%\\index.html\" /&gt; Download and fail the service startup on Error: &lt;download from=\"http://www.nosuchhostexists.com/\" to=\"%BASE%\\dummy.html\" failOnError=\"true\"/&gt; An example for unsecure Basic authentication because the connection is not encrypted: &lt;download from=\"http://example.com/some.dat\" to=\"%BASE%\\some.dat\" auth=\"basic\" unsecureAuth=“true” username=\"aUser\" password=“aPassw0rd\" /&gt; Secure Basic authentication via HTTPS: &lt;download from=\"https://example.com/some.dat\" to=\"%BASE%\\some.dat\" auth=\"basic\" username=\"aUser\" password=\"aPassw0rd\" /&gt; Secure authentication when the target server and the client are members of the same domain or the server domain and the client domain belong to the same forest with a trust: &lt;download from=\"https://example.com/some.dat\" to=\"%BASE%\\some.dat\" auth=\"sspi\" /&gt; --&gt; &lt;!-- SECTION: Other options --&gt; &lt;!-- OPTION: beeponshutdown Indicates the service should beep when finished on shutdown (if it's supported by OS). --&gt; &lt;!-- &lt;beeponshutdown/&gt; --&gt; &lt;!-- SECTION: Extensions This configuration section allows specifying custom extensions. More info is available here: https://github.com/kohsuke/winsw/blob/master/doc/extensions/extensions.md --&gt; &lt;!-- &lt;extensions&gt; Extension 1: id values must be unique &lt;extension enabled=\"true\" id=\"extension1\" className=\"winsw.Plugins.SharedDirectoryMapper.SharedDirectoryMapper\"&gt; &lt;mapping&gt; &lt;map enabled=\"false\" label=\"N:\" uncpath=\"\\\\UNC\"/&gt; &lt;map enabled=\"false\" label=\"M:\" uncpath=\"\\\\UNC2\"/&gt; &lt;/mapping&gt; &lt;/extension&gt; ... &lt;/extensions&gt; --&gt; &lt;/service&gt; nginx-service.exe 和nginx-service.xml文件路径： tree.bat12345678910111213141516D:nginx│ nginx-service.exe│ nginx-service.xml│ nginx.exe│├─conf│├─contrib│├─docs│├─html│├─logs│└─temp widows 命令： echo.bat12345678910111213141516@ECHO OFFREM 声明采用UTF-8编码chcp 65001@REM 启动echo 启动 nginx-service.exe start@REM 停止echo 停止 nginx-service.exe stop@REM 安装echo 安装 nginx-service.exe install@REM 卸载echo 卸载 nginx-service.exe uninstallpause Nginx日志处理思路nginx -s reopen命令控制Nginx重新打开日志文件(生成文件)的，通过WinSW封装一个reopen的操作的服务(可以保证SYSTEM权限)，剩下的就是定时任务了(注意运行账户改为SYSTEM)。 Nginx Logrote Service 批处理文件样例 logservice.xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;service&gt; &lt;id&gt;nginx-logrote&lt;/id&gt; &lt;name&gt;Nginx Logrote Service&lt;/name&gt; &lt;description&gt;基于Nginx的媒体流服务器的Logrote服务&lt;/description&gt; &lt;executable&gt;cleanlog.bat&lt;/executable&gt; &lt;startmode&gt;Manual&lt;/startmode&gt; &lt;logpath&gt;./logs&lt;/logpath&gt; &lt;logmode&gt;roll&lt;/logmode&gt;&lt;/service&gt; cleanlog.bat1234567891011121314151617@ECHO OFFCD logsFOR /f \"delims=\" %%i IN ('DIR /a-d /b access.log') DO ( IF %%~zi gtr 10485760 ( MOVE /Y %%i %%i.bak ))FOR /f \"delims=\" %%i IN ('DIR /a-d /b error.log') DO ( IF %%~zi gtr 10485760 ( MOVE /Y %%i %%i.bak ))CD ..nginx -s reopen 快捷bat卸载重装wsw123nginx-service.exe uninstall nginx-service.xmlnginx-service install nginx-service.xmlpause 开启wsw服务12nginx-service start nginx-service.xmlnginx-service status nginx-service.xml 停止wsw服务1nginx-service stop nginx-service.xml","link":"/2022/04/21/Nginx%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%BAWindows%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"},{"title":"v2ray部署Ubuntu18.0","text":"部署v2ray按照fhs-install-v2ray文档，一步步执行。 安装和更新 V2Ray1234# 安装可执行文件和 .dat 数据文件cd ~sudo wget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh sudo bash install-release.sh 安装最新发行的 geoip.dat 和 geosite.dat1234# 只更新 .dat 数据文件cd ~sudo wget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-dat-release.sh)sudo bash install-dat-release.sh 移除 V2Ray123cd ~sudo wget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh sudo bash install-release.sh --remove 安装完后启用服务12systemctl enable v2raysystemctl start v2ray v2ray帮助命令1234567891011121314151617181920212223242526272829303132#编辑配置文件sudo vim /usr/local/etc/v2ray/config.json#测试配置文件正确性/usr/local/bin/v2ray/v2ray --test --config /etc/v2ray/config.json# 查看运行状态sudo systemctl status v2ray# 查看端口占用sudo netstat -apn | grep v2ray# 查看程序日志sudo journalctl -b -u v2ray# 查看v2ray日志文件sudo vim /var/log/v2ray/access.log# 查看程序日志文件底部 10 行内容。sudo tail /var/log/v2ray/error.log# 启动sudo systemctl start v2ray# 停止sudo systemctl stop v2ray# 重启sudo systemctl restart v2ray## 查看防火墙状态：（active (running) 即是开启状态）sudo systemctl status firewalld## 查看已开放端口sudo firewall-cmd --list-all## 防火墙开放端口：（开放端口后需重载防火墙）sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent 配置服务端配置需要在服务器开启端口，这次测试部署的是腾讯云，在控制台添加就行。其它服务器商配置可能不同。下列配置了在端口6352的shadowsocks服务和6353端口的vmess服务,并配置了部份直连规则。更多节点配置见：配置文件 config.json12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061{ \"log\": { \"loglevel\": \"warning\", \"access\": \"/var/log/v2ray/access.log\", \"error\": \"/var/log/v2ray/error.log\" }, \"inbounds\": [ { \"port\": 6352, \"protocol\": \"shadowsocks\", \"settings\": { \"method\": \"aes-128-gcm\", \"ota\": false, \"password\": \"gndl\" } }, { \"port\": 6353, \"protocol\": \"vmess\", \"settings\": { \"clients\": [ { \"id\": \"17449fc0-ac82-4389-bf69-xxxxxxxxxx\", \"alterId\": 10 } ] } } ], \"outbounds\": [ { \"protocol\": \"freedom\", \"settings\": {} } ], \"routing\": { \"domainStrategy\": \"IPIfNonMatch\", \"rules\": [ { \"type\": \"field\", \"domain\": [ \"baidu.com\", \"qq.com\", \"bilibili.com\", \"geosite:cn\" ], \"ip\": [ \"0.0.0.0/8\", \"10.0.0.0/8\", \"fc00::/7\", \"fe80::/10\", \"geoip:cn\" ], \"port\": \"53,443,1000-2000\", \"network\": \"tcp,udp\", \"outboundTag\": \"direct\" } ], \"balancers\": [] }} 客户端配置config.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154{ \"log\": { \"access\": \"access.log\", \"error\": \"error.log\", \"loglevel\": \"warning\" }, \"inbounds\": [ { \"tag\": \"proxy\", \"port\": 10808, \"listen\": \"127.0.0.1\", \"protocol\": \"socks\", \"sniffing\": { \"enabled\": false, \"destOverride\": [ \"http\", \"tls\" ] }, \"settings\": { \"auth\": \"noauth\", \"udp\": true } } ], \"outbounds\": [ { \"tag\": \"proxy\", \"protocol\": \"vmess\", \"settings\": { \"vnext\": [ { \"address\": \"test.com\", \"port\": 10465, \"users\": [ { \"id\": \"0909f50b-7519-4720-8911-xxxxxxxxxxx\", \"alterId\": 0, \"email\": \"x@qq.com\", \"security\": \"auto\" } ] } ] }, \"streamSettings\": { \"network\": \"ws\", \"security\": \"tls\", \"tlsSettings\": { \"allowInsecure\": false, \"serverName\": \"xxx.test.xyz\" }, \"wsSettings\": { \"path\": \"/\", \"headers\": { \"Host\": \"xxx.test.xyz\" } } }, \"mux\": { \"enabled\": true, \"concurrency\": 8 } }, { \"tag\": \"direct\", \"protocol\": \"freedom\", \"settings\": {} }, { \"tag\": \"block\", \"protocol\": \"blackhole\", \"settings\": { \"response\": { \"type\": \"http\" } } } ], \"routing\": { \"domainStrategy\": \"IPIfNonMatch\", \"rules\": [ { \"type\": \"field\", \"inboundTag\": [ \"api\" ], \"outboundTag\": \"api\" }, { \"type\": \"field\", \"outboundTag\": \"proxy\", \"domain\": [ \"geosite:google\", \"geosite:telegram\", \"geosite:twitter\", \"geosite:facebook\", \"geosite:github\", \"geosite:steam\", \"geosite:tumblr\", \"geosite:speedtest\", \"geosite:bbc\", \"geosite:tiktok\", \"geosite:netflix\", \"geosite:gfw\", \"domain:babeljs.cn\", \"domain:codepen.io\" ] }, { \"type\": \"field\", \"outboundTag\": \"direct\", \"domain\": [ \"geosite:cn\" ] }, { \"type\": \"field\", \"outboundTag\": \"direct\", \"ip\": [ \"geoip:private\" ] }, { \"type\": \"field\", \"outboundTag\": \"block\", \"domain\": [ \"geosite:category-ads-all\" ] }, { \"type\": \"field\", \"outboundTag\": \"direct\", \"ip\": [ \"geoip:private\" ] }, { \"type\": \"field\", \"outboundTag\": \"direct\", \"ip\": [ \"geoip:cn\" ] }, { \"type\": \"field\", \"outboundTag\": \"direct\", \"domain\": [ \"geosite:cn\" ] } ] }}","link":"/2022/05/09/v2ray-shadowsocks%E9%83%A8%E7%BD%B2Ubuntu/"},{"title":"使用WorkerServices和.NETCore3.1构建Windows服务","text":"笔记 Adding the Quartz.NET hosted serviceYou need to do two things to register the Quartz.NET hosted service: Register the Quartz.NET required services with the DI container Register the hosted service 根据Quartz文档Microsoft DI Integration 中的描述，在微软的集成中，使用services.AddQuartzHostedService 将服务注册到 hosted service中 。根据源码可以看到是调用了services.AddSingleton方法，注册了一个单例生命周期的服务。 WorkerServices+Quartz+Windows服务 是否可实现？ 思路一开始以为services.AddQuartzHostedService 就已经是创建了一个服务，但是发现总是不对，问题在于没有添加 Host Service服务。而且AddQuartzHostedService 只是注册了一个单例生命周期的服务，并没有针对Windows服务做进一步的实现。没有实现OnStart 和OnStop 方法。所以一致报错。 在后面添加上services.AddHostedService&lt;Worker&gt;(); 后，程序可以正常运行，本质上Quartz还是需要依托于一个正常运行的HostService 。而一个正常的Windows服务程序则必须是一个可以长时间运行的 HostService 。需要从BackgroundService派生并覆盖实现必要的部份方法 参考： 为将作为服务应用程序的一部分而存在的服务提供基类。 在创建新的服务类时，必须从 ServiceBase 类 派生。在服务应用程序中定义服务类时从ServiceBase派生。任何有用的服务都会覆盖OnStart和OnStop方法。对于附加功能，您可以使用特定行为覆盖OnPause和OnContinue，以响应服务状态的变化。 DemoFile: program.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using Quartz;using WorkerServiceDemoNet6;IHost host = Host.CreateDefaultBuilder(args) .UseContentRoot(Directory.GetCurrentDirectory()) .UseWindowsService(option =&gt; { option.ServiceName = \"NET6.0 Test Windows Service\"; }) .ConfigureAppConfiguration((hostingContext, configuration) =&gt; { configuration.Sources.Clear(); IHostEnvironment env = hostingContext.HostingEnvironment; Console.WriteLine(\"ENVIRONMENT: \" + env == null ? \"\" : env.EnvironmentName ?? \"\"); configuration .SetBasePath(hostingContext.HostingEnvironment.ContentRootPath) .AddJsonFile(@\"appsettings.json\", optional: true, reloadOnChange: true) .AddEnvironmentVariables(); }) .ConfigureServices(services =&gt; { services.AddQuartz(q =&gt; { q.SchedulerId = \"Scheduler-Core\"; q.UseInMemoryStore(); q.UseDefaultThreadPool(tp =&gt; { tp.MaxConcurrency = 10; }); //Use a Scoped container to create jobs. I'll touch on this later q.UseMicrosoftDependencyInjectionJobFactory(); //q.AddJobAndTrigger&lt;TestJob&gt;(hostContext.Configuration); // Create a \"key\" for the job var jobKey = new JobKey(\"TestJob\"); // Register the job with the DI container q.AddJob&lt;TestJob&gt;(opts =&gt; opts.WithIdentity(jobKey)); // Create a trigger for the job q.AddTrigger(opts =&gt; opts .ForJob(jobKey) // link to the HelloWorldJob .WithIdentity(\"HelloWorldJob-trigger\") // give the trigger a unique name .WithCronSchedule(\"0/5 * * * * ?\")); // run every 5 seconds }); //Add the Quartz.NET hosted service services.AddQuartzHostedService( q =&gt; { q.WaitForJobsToComplete = true; q.AwaitApplicationStarted = true; }); }) .ConfigureServices(services =&gt; { services.AddHostedService&lt;Worker&gt;(); }) .Build();await host.RunAsync(); 转载：Create a Windows Service using BackgroundServiceBuilding a Windows service with Worker Services and .NET Core 3.1, part 1: Introduction Using Quartz.NET with ASP.NET Core and worker services.NET Core Workers as Windows Services 参考： AddTransient, AddScoped and AddSingleton Services Differences ASP.NET Core Service Lifetimes (Infographic)","link":"/2022/05/12/%E4%BD%BF%E7%94%A8WorkerServices%E5%92%8C-NETCore3-1%E6%9E%84%E5%BB%BAWindows%E6%9C%8D%E5%8A%A1/"},{"title":"EFCore初识【一】","text":"vue-cli DbContext &amp; DbcontextPool 比较DbContext &amp; DbcontextPool in ef-core","link":"/2022/05/26/EFCore%E5%88%9D%E8%AF%86%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"Git初识【一】","text":"常用命令git仓库命令 命令 操作 备注 git remote -v 查看远程仓库 git pull origin master 直接拉取并合并最新代码 git pull origin dev ：拉取远端origin/dev分支并合并到当前分支 git fetch origin master:master1 获取最新代码到本地临时分支 在本地建立master1分支，并下载远端的origin/master分支到master1分支中 git diff master1 查看版本差异 查看本地master1分支与当前分支的版本差异 git merge master1 合并最新分支到本地分支 合并本地分支master1到当前分支 git branch -D master1 删除本地临时分支 删除本地分支master1 git fetch origin master 获取最新代码到本地(本地当前分支为[branch]，获取的远端的分支为[origin/branch]) 获取远端的origin/master分支 git log -p master..origin/master 查看版本差异 查看本地master与远端origin/master的版本差异 git merge origin/master 合并最新代码到本地分支 合并远端分支origin/master到当前分支 git配置命令 命令 操作 备注 摘录创建仓库命令 命令 操作 备注 git init 初始化仓库 git clone 拷贝一份远程仓库，也就是下载一个项目。 提交与修改 命令 操作 备注 git add 添加文件到暂存区 git status 查看仓库当前的状态，显示有变更的文件。 git diff 比较文件的不同，即暂存区和工作区的差异。 git commit 提交暂存区到本地仓库。 git reset 回退版本。 git rm 将文件从暂存区和工作区中删除。 git mv 移动或重命名工作区文件。 提交日志 命令 操作 备注 git log 查看历史提交记录 git blame &lt;file&gt; 以列表形式查看指定文件的历史修改记录 远程操作 命令 操作 备注 git remote 远程仓库操作 git fetch 从远程获取代码库 git pull 下载远程代码并合并 git push 上传远程代码并合并 分支操作|:–|:–|:–||git branch|列出现有的分支|-r导致远程跟踪分支被列出；-a显示本地和远程分支||git branch (branchname)|创建分支命令|||git checkout (branchname)|切换分支命令|||git checkout -b (branchname)|创建新分支并立即切换到该分支下|||git branch -d (branchname)|删除分支|||git merge|合并分支|| Git命令-管理管理如果你正在管理一个 Git 仓库，或者需要通过一个复杂的方法来修复某些东西，Git 提供了一些管理命令来帮助你。 git gcgit gc 命令在你的仓库中执行 “garbage collection”，删除数据库中不需要的文件和将其他文件打包成一种更有效的格式。 此命令一般在背后为你工作，虽然你可以手动执行它-如果你想的话。 我们在维护 一节中研究此命令的几个示例。 git fsckgit fsck 命令用来检查内部数据库的问题或者不一致性。 我们只在 数据恢复 这一节中快速使用了一次此命令来搜索所有的悬空对象（dangling object）。 git refloggit reflog 命令分析你所有分支的头指针的日志来查找出你在重写历史上可能丢失的提交。 我们主要在 引用日志 一节中提到了此命令，并在展示了一般用法，及如何使用 git log -g 来通过 git log 的输出来查看同样的信息。 我们同样在 数据恢复 一节中研究了一个恢复丢失的分支的实例。 git filter-branchgit filter-branch 命令用来根据某些规则来重写大量的提交记录，例如从任何地方删除文件，或者通过过滤一个仓库中的一个单独的子目录以提取出一个项目。 在 从每一个提交中移除一个文件 一节中，我们解释了此命令，并探究了其他几个选项，例如 –commit-filter，–subdirectory-filter 及 –tree-filter 。 在 Git-p4 和 TFS 的章节中我们使用它来修复已经导入的外部仓库。 详情git add 添加当前目录下的所有文件到暂存区：git add . git rm 用法：git rm &lt;filename&gt;; 从暂存区和工作区中删除 demo目录下的test.txt 文件：git rm demo/test.txt 从暂存区和工作区中 强制删除 test.txt 文件：git rm -f test.txt 把文件从暂存区域移除，但仍然保留在当前工作目录中【从跟踪清单中删除 】：git rm --cached test.txt","link":"/2022/05/26/Git%E5%88%9D%E8%AF%86/"},{"title":"Redis常用命令","text":"Redis 常用操作命令，非常详细！ 管理命令 命令 操作 备注 redis-server [--port 6379] 启动Redis redis-server [xx/xx/redis.conf] 通过配置文件来启动Redis redis-cli.exe -h 127.0.0.1 -p 6379 -a test 连接本地6379端口的redis服务，使用密码test redis-cli shutdown 停止Redis key操作命令 命令 操作 备注 keys * 获取所有键 *表示通配符，表示任意字符，会遍历所有键显示所有的键列表，时间复杂度O(n)，在生产环境不建议使用。 dbsize 获取键总数 获取键总数时不会遍历所有的键，直接获取内部变量，时间复杂度O(1)。 exists akey bkey 查询键是否存在 可查询多个，返回存在的个数。 del akey bkey 删除键 可以删除多个，返回删除成功的个数。 move akey 2 移动键 把akey移到2号数据库 select 2 选择查询库 ttl akey 查询key的生命周期（秒） expire akey 60 设置过期时间 60s persist akey 设置永不过期 rename akey akey123 更改键名称 字符串操作命令 命令 操作 备注 set akey 测试 存放键值 get akey 获取键值 incr bkey 值递增/递减 如果字符串中的值是数字类型的，可以使用incr命令每次递增，不是数字类型则报错 mset akey 测试 bkey 66 批量存放键值 mget akey bkey 批量获取键值 strlen akey 获取值长度 append akey hi 追加内容 getrange akey 0 2 获取部分字符 获取索引0到4的字符串 集合操作命令集合有序集合列表操作命令散列操作命令","link":"/2022/05/27/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"CSS选择器","text":"","link":"/2022/06/10/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"title":"Client发送SOAP请求并接收响应","text":"SOAPHelper.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Net;using System.Xml;namespace Ryadel.Web.SOAP{ /// &lt;summary&gt; /// Helper class to send custom SOAP requests. /// &lt;/summary&gt; public static class SOAPHelper { /// &lt;summary&gt; /// Sends a custom sync SOAP request to given URL and receive a request /// &lt;/summary&gt; /// &lt;param name=\"url\"&gt;The WebService endpoint URL&lt;/param&gt; /// &lt;param name=\"action\"&gt;The WebService action name&lt;/param&gt; /// &lt;param name=\"parameters\"&gt;A dictionary containing the parameters in a key-value fashion&lt;/param&gt; /// &lt;param name=\"soapAction\"&gt;The SOAPAction value, as specified in the Web Service's WSDL (or NULL to use the url parameter)&lt;/param&gt; /// &lt;param name=\"useSOAP12\"&gt;Set this to TRUE to use the SOAP v1.2 protocol, FALSE to use the SOAP v1.1 (default)&lt;/param&gt; /// &lt;returns&gt;A string containing the raw Web Service response&lt;/returns&gt; public static string SendSOAPRequest(string url, string action, Dictionary&lt;string, string&gt; parameters, string soapAction = null, bool useSOAP12 = false) { // Create the SOAP envelope XmlDocument soapEnvelopeXml = new XmlDocument(); var xmlStr = (useSOAP12) ? @\"&lt;?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?&gt; &lt;soap12:Envelope xmlns:xsi=\"\"http://www.w3.org/2001/XMLSchema-instance\"\" xmlns:xsd=\"\"http://www.w3.org/2001/XMLSchema\"\" xmlns:soap12=\"\"http://www.w3.org/2003/05/soap-envelope\"\"&gt; &lt;soap12:Body&gt; &lt;{0} xmlns=\"\"{1}\"\"&gt;{2}&lt;/{0}&gt; &lt;/soap12:Body&gt; &lt;/soap12:Envelope&gt;\" : @\"&lt;?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?&gt; &lt;soap:Envelope xmlns:soap=\"\"http://schemas.xmlsoap.org/soap/envelope/\"\" xmlns:xsi=\"\"http://www.w3.org/2001/XMLSchema-instance\"\" xmlns:xsd=\"\"http://www.w3.org/2001/XMLSchema\"\"&gt; &lt;soap:Body&gt; &lt;{0} xmlns=\"\"{1}\"\"&gt;{2}&lt;/{0}&gt; &lt;/soap:Body&gt; &lt;/soap:Envelope&gt;\"; string parms = string.Join(string.Empty, parameters.Select(kv =&gt; String.Format(\"&lt;{0}&gt;{1}&lt;/{0}&gt;\", kv.Key, kv.Value)).ToArray()); var s = String.Format(xmlStr, action, new Uri(url).GetLeftPart(UriPartial.Authority) + \"/\", parms); soapEnvelopeXml.LoadXml(s); // Create the web request HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(url); webRequest.Headers.Add(\"SOAPAction\", soapAction ?? url); webRequest.ContentType = (useSOAP12) ? \"application/soap+xml;charset=\\\"utf-8\\\"\" : \"text/xml;charset=\\\"utf-8\\\"\"; webRequest.Accept = (useSOAP12) ? \"application/soap+xml\" : \"text/xml\"; webRequest.Method = \"POST\"; // Insert SOAP envelope using (Stream stream = webRequest.GetRequestStream()) { soapEnvelopeXml.Save(stream); } // Send request and retrieve result string result; using (WebResponse response = webRequest.GetResponse()) { using (StreamReader rd = new StreamReader(response.GetResponseStream())) { result = rd.ReadToEnd(); } } return result; } }} 参考引用： Client to send SOAP request and receive responseHow to perform a SOAP Web Service Request in ASP.NET C# without using WSDL, proxy classes or SoapClient","link":"/2022/07/11/Client%E5%8F%91%E9%80%81SOAP%E8%AF%B7%E6%B1%82%E5%B9%B6%E6%8E%A5%E6%94%B6%E5%93%8D%E5%BA%94/"},{"title":"什么是Key Lookup?","text":"Key Lookups 可能会导致性能问题性能调整查询时最容易修复的事情之一是 Key Lookups 或 RID Lookups。当查询优化器对特定表执行index seek并且该索引没有满足结果集所需的所有列时，就会出现key lookup运算符。 SQL Server 被迫使用主键返回聚集索引并检索满足请求所需的剩余列。 RID lookup是相同的操作，但在没有聚集索引的表（也称为堆）上执行。它使用row id 而不是主键来进行查找。如您所见，这些可能非常昂贵，并且可能导致 I/O 和 CPU 的性能大幅下降。 想象一个每分钟运行数千次的查询，其中包括一个或多个键查找。 这可能会导致由这些额外读取产生的巨大开销，它会影响整体引擎性能。 让我们看一个例子。 demo.sql1234SELECT [SalesOrderID],[CarrierTrackingNumber],[OrderQty],[ProductID],[UnitPrice],[ModifiedDate]FROM [AdventureWorks2014].[Sales].[SalesOrderDetail] Where [ModifiedDate]&gt; '2014/01/01' and [ProductID]=772 键查找运算符的成本是查询的 99%。 您可以看到它对 IX_SalesOrderDetail_ProductID 执行了索引查找，这非常有效，但是该索引没有满足查询所需的所有列。 然后优化器使用聚集索引 PK_SalesOrderDetail_SalesOrderID_SalesOrderDetailID 检索它需要的其他列。 您可以通过将鼠标悬停在查询计划窗口中的键查找上来查看它得到了什么。 Key 和 RID look ups 的好处是它们非常容易修复。 通过对非聚集索引 IX_SalesOrderDetail_ProductID 稍作修改，我们可以将查询计划从index seek和key lookup更改为非常小的索引查找。 我们所要做的就是重新创建该索引并将输出列表字段添加为该索引上的包含列。 demo.sql12345CREATE NONCLUSTERED INDEX [IX_SalesOrderDetail_ProductID] ON [Sales].[SalesOrderDetail]([ProductID] ASC)INCLUDE ([CarrierTrackingNumber],[UnitPrice], [ModifiedDate], [OrderQty])WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = ON, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] 正如您所看到的，我们现在只有一个 Index Seek 和一个更有效的计划。 参考引用： What’s a Key Lookup?Eliminating bookmark (key/rid) lookups","link":"/2022/07/11/%E4%BB%80%E4%B9%88%E6%98%AFKeyLookup/"},{"title":"调用webservice通过HTTP【实验】","text":"前言本文尝试使用HTTP请求实现调用webservice服务，需求效果参考SOAPUI。 调用WebService方法有多种： 1. 使用Visual Studio的”添加服务引用”功能,在代码中声明服务对象后，即可调用。优点 方便快捷，节约时间缺点: 前提条件是开发环境需要能够访问到服务地址，否则无法添加服务引用。 不适用频繁更新的webservice，每次调用的webservice的WSDL文件更新后，必须重新生成覆盖更新旧的代理类。不够便捷及时。 参考： 添加 Web 引用访问 Web 服务 2. 使用WSDL.exe工具生成代理类，将生成的类添加到项目中,在代码中创建类的实例对象后，即可调用。优点 方便快捷,只需要WSDL文件就能生成代理缺点: 不适用频繁更新的webservice，每次调用的webservice的WSDL文件更新后，必须重新生成覆盖更新旧的代理类。不够便捷及时。 生成代理类12C:\\Users\\user&gt;cd C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v10.0A\\bin\\NETFX 4.6.1 ToolsC:\\Users\\user&gt;wsdl.exe /l:cs /n:testnamespace /out: D:testproxy.cs https://www.crcind.com/csp/samples/SOAP.Demo.CLS?WSDL=1 参考： Web 服务描述语言工具 (Wsdl.exe).net wsdl.exe 生成java开发的webservice客户端类的时候报错，无法从命名空间获取绑定C# 利用VS自带的WSDL工具生成WebService服务类 3. 使用HTTP请求实现调用webservice服务思路 参考： C#进阶系列——WebApi 接口返回值不困惑：返回值类型详解 - 懒得安分 - 博客园WebService 之 WSDL文件 讲解 - 梦想的追求 - CSDN博客WebAPI 和 webservice的区别 - CYSONG168的专栏 - CSDN博客【WCF】什么是WCF - 白靖 - CSDN博客mvc接口、webapi、webservice 对比 - 思明 - 博客园使用 System.Net 和 SOAP 动态调用 Web 服务WebService中的WSDL详细解析_孤独地搬砖的博客-CSDN博客_wsdl是什么意思WSDL Tutorial: Web Services Description Language with ExampleWeb Service Definition Language (WSDL)Web Services Description Language (WSDL) Version 2.0 Part 1: Core Language","link":"/2022/07/12/%E8%B0%83%E7%94%A8webservice%E9%80%9A%E8%BF%87HTTP/"},{"title":"Blazor初识【一】","text":"https://dotnet.microsoft.com/zh-cn/learn/aspnet/blazor-tutorial/create","link":"/2022/07/13/Blazor%E5%88%9D%E8%AF%86/"},{"title":"清理IIS日志文件","text":"管理 IIS 日志文件存储通过脚本删除旧日志文件您可以通过运行脚本来控制日志文件的磁盘使用情况，该脚本会自动删除超过特定年龄的日志文件。在计划任务中运行此脚本将控制磁盘填满问题，而无需持续维护。 以下 VBScript 将检查文件夹中每个日志文件的年龄，并将删除任何早于指定年龄的日志文件。要根据您的目的自定义脚本，只需在脚本的第 1 行中更改文件夹的名称和路径，并在第 2 行中将最大使用期限更改为所需的天数。 retentionscript.vbs1234567891011121314sLogFolder = \"c:\\inetpub\\logs\\LogFiles\"iMaxAge = 30 'in daysSet objFSO = CreateObject(\"Scripting.FileSystemObject\")set colFolder = objFSO.GetFolder(sLogFolder)For Each colSubfolder in colFolder.SubFolders Set objFolder = objFSO.GetFolder(colSubfolder.Path) Set colFiles = objFolder.Files For Each objFile in colFiles iFileAge = now-objFile.DateCreated if iFileAge &gt; (iMaxAge+1) then objFSO.deletefile objFile, True end if NextNext 上面的脚本将扫描所有子文件夹，因此它将处理指定文件夹中和下的所有站点的日志。如果您想将该过程限制为单个站点，请适当更改路径。 要手动运行脚本，请在管理员命令行中执行以下脚本：cscript.exe c:\\scripts\\retentionscript.vbs 跑vbs脚本的bat，不用再输入文件路径，只需要bat和vbs文件在同一目录就行： cleanup.bat12345678@echo offecho 当前盘符和路径：%~dp0echo on@cd /d %~dp0cscript.exe retentionscript.vbs@echo offecho 清理日志完成pause 出处：Delete Old Log Files by Script","link":"/2022/07/14/%E6%B8%85%E7%90%86IIS%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"},{"title":"Lua初识【一】","text":"b站bug根因.lua123456789101112131415161718local _gcd_gcd = function(a,b) print(\"a:\",a,\"b:\",b) print(\"b == 0\",b == 0) if b == 0 then return a end return _gcd(b,a%b)endprint(50 /0 ) -- infprint(50%'0') -- n%0print(\"first :_gcd(52,0)：\",_gcd(50,'0'))print(\"second :_gcd('0',50%'0')：\",_gcd('0',50%'0'))","link":"/2022/07/16/Lua%E5%88%9D%E8%AF%86%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"WSDL文件结构分析","text":"WSDL是什么?WSDL 是一种可用于定义Web服务的语言WSDL 是用 XML 编写的WSDL 定义描述了如何访问 Web 服务以及它将执行什么操作。WSDL 代表Web Services Description Language（网络服务描述语言）WSDL 是 2007 年 6 月 26 日的 W3C 推荐标准 到目前为止已发布了2个主要版本，它们分别如下所述: WSDL 1.1 - 于2001年3月15日发布，WSDL 1.1的规范可通过访问网址：https://www.w3.org/TR/2001/NOTE-wsdl-20010315 了解。 WSDL 2.0 - 于2007年6月26日发布，WSDL 2.0的规范可通过访问网址：https://www.w3.org/TR/wsdl20 了解。 在高层次上，WSDL是一种允许编写WSDL文档的语言，因此： WSDL文档可以定义一组Web服务。Web服务可以定义为接口和一组端点。端点可以定义为地址和绑定。可以定义地址以告知提供服务的位置。可以定义绑定以告知如何格式化和传输消息。接口可以定义为一组操作。操作可以定义为输入和输出消息序列。 WSDL用来干什么的？WSDL（Web Service Description Language）用XML格式的文件来描述可用的Web服务。 WSDL文件被用来在Web Service生产者和消费者之间交流接口信息。 其实说白了就是一个标准，终端按照这个标准在网络中创建Web Service，客户端也按照此标准去连接这个服务，并且根据WSDL文件获知自己所需要的操作，客户端可以在不了解Web Service的实现细节的情况下使用Web Service的能力。 WSDL发展过程WSDL 1.0（2000年9月）是由IBM、微软和Ariba开发的，用于描述其SOAP工具包的Web服务。它是由两种服务描述语言结合而成的。IBM的NASSL（网络应用服务规范语言）和微软的SDL（服务描述语言）。 2001年3月发表的WSDL 1.1是WSDL 1.0的形式化。在1.0和1.1之间没有引入重大变化。 WSDL 1.2（2003年6月）是W3C的一个工作草案，但已经成为WSDL 2.0。根据W3C的说法。WSDL 1.2 对开发者来说比以前的版本更容易、更灵活。WSDL 1.2试图删除不具互操作性的功能，也更好地定义了HTTP 1.1绑定。WSDL 1.2不被大多数SOAP服务器/供应商所支持。 WSDL 2.0在2007年6月成为W3C的建议。WSDL 1.2被重新命名为WSDL 2.0，因为它与WSDL 1.1有很大的区别。这些变化如下。 为描述语言添加了进一步的语义删除了message结构不支持操作符重载PortTypes 重命名为interfacesPorts重命名为endpoints 所以说现在WSDL流行的两个版本是WSDL2.0 和 WSDL1.1。虽说WSDL2.0 是W3C推荐的版本，但是现在大多数的厂商支持的还是WSDL1.1。 WSDL1.1 和WSDL2.0WSDL 1.1 规范仅定义描述如何结合 SOAP 1.1、HTTP GET 和 POST 以及 MIME 使用 WSDL 的绑定。 WSDL 2.0 提供了一种模型和 XML 格式来描述 Web 服务。它使您能够将服务提供的抽象功能的描述与服务描述的具体细节分开，例如提供该功能的“方式”和“位置”。它还描述了消息交换模式的扩展、SOAP 模块以及用于描述 SOAP 1.2 和 HTTP 的此类具体细节的语言。 WSDL 2.0 规范还解决了 WSDL 1.1 中存在的许多技术问题和限制。 WSDL 1.1 规范由万维网联盟 (W3C)作为 WSDL 版本 1.1 的 W3C 注释发布。 WSDL 2.0 的规范在WSDL 2.0 版中作为 W3C 推荐标准发布。 WSDL 用法WSDL 通常与 SOAP 和 XML Schema 结合使用，以在 Internet 上提供 Web 服务。连接到 Web 服务的客户端程序可以读取 WSDL 以确定服务器上可用的功能。使用的任何特殊数据类型都以 XML 模式的形式嵌入到 WSDL 文件中。然后客户端可以使用 SOAP 实际调用 WSDL 中列出的函数之一。 WSDL 文档包含客户端调用 Web Service方法所需的所有信息： 作为方法参数或返回值的数据类型 各个方法的名称和签名（WSDL把方法称为操作） 每个方法允许的协议和消息格式 用于访问 Web Service的 URL WSDL 文档WSDL 将 Web Service分解为三个特定的、可识别的元素，这些元素一旦定义就可以组合或重用。 可以单独定义的 WSDL 的三个主要元素是: Types Operations Binding 一个 WSDL 文档有各种元素，但它们都包含在这三个主要元素中，它们可以作为单独的文档开发，然后它们可以组合或重用以形成完整的 WSDL 文件。 WSDL 元素WSDL 1.0WSDL2.0https://www.iteye.com/blog/jameswxx-250759 https://www.cnblogs.com/si-shaohua/archive/2012/04/28/2475257.html https://www.daimajiaoliu.com/daima/47dcc29ff900403","link":"/2022/07/22/WSDL%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"title":"git彻底移除敏感文件","text":"前言在日常开发项目中，可能会出现将包含数据库连接字符、中间件密钥等敏感信息提交并推送到远程仓库的情况，这时需要将文件删除。执行git rm config.json命令虽然删除了文件，但是在历史提交记录中仍然可以查看到数据内容。这时可以使用 核武器级选项：filter-branch 移除数据filter-branch描述允许您通过重写 &lt;rev-list options&gt; 中提到的分支来重写 Git 修订历史，在每个修订上应用自定义过滤器。这些过滤器可以修改每棵树（例如删除文件或对所有文件运行 perl 重写）或有关每次提交的信息。否则，将保留所有信息（包括原始提交时间或合并信息）。 12345678910111213141516# 移除test文件夹下config.json 文件，并擦洗所有涉及此文件的提交历史。git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch test/config.json' --prune-empty --tag-name-filter cat -- --all# 移除test文件夹下所有文件，并擦洗所有涉及此文件的提交历史。git filter-branch --force --index-filter 'git rm -r --cached --ignore-unmatch test' --prune-empty --tag-name-filter cat -- --all# 当你检查项目后，发现没有任何问题，则将命令提交到版本库中。git push origin --force --all# 你还需要提交你的git tags，用以更新服务器的git tags。git push origin --force --tags# 删除本地缓存git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdingit reflog expire --expire=now --allgit gc --prune=now 命令说明：git filter-branch option12--f --forece git filter-branch 拒绝以现有的临时目录开始，或者当已经使用 refs / original / 开始refs时，除非被强制。 1--index-filter &lt;command&gt; 这是重写索引的过滤器。它类似于树过滤器，但不检查树，这使得它更快。经常与git rm –cached –ignore-unmatch …一起使用 1--prune-empty 某些过滤器将生成空提交，使树保持不变。如果git-filter-branch只有一个或零个非修剪父项，则该选项指示git-filter-branch删除这些提交;因此，合并提交将保持不变。此选项不能与--commit-filter一起使用，但通过在提交过滤器中使用提供的git_commit_non_empty_tree功能可以实现相同的效果。 1--tag-name-filter &lt;command&gt; 这是用于重写标记名称的过滤器。传递时，将为每个指向重写对象（或指向重写对象的标记对象）的标记ref调用它。原始标记名称通过标准输入传递，新标记名称在标准输出上是预期的。原始标签不会被删除，但可以被覆盖;使用“—tag-name-filter cat”来简单地更新标签。在这种情况下，请务必小心并确保备份旧标签，以防转换发生冲突。支持几乎正确的标记对象重写。如果标记附加了消息，则将使用相同的消息，作者和时间戳创建新的标记对象。如果标签附有签名，则签名将被删除。根据定义，不可能保留签名。这是“几乎”正确的原因，因为理想情况下，如果标签没有改变（指向同一个对象，具有相同的名称等），它应该保留任何签名。情况并非如此，签名将永远删除，买家要小心。也不支持更改作者或时间戳（或标记消息）。指向其他标记的标记将被重写以指向底层提交。 缩小存储库的清单git-filter-branch可用于删除文件的子集，通常使用–index-filter和–subdirectory-filter的某种组合。人们期望生成的存储库小于原始存储库，但是你需要更多的步骤来实际使它变小，因为Git努力不会丢失你的对象，直到你告诉它。首先要确保： 如果blob在其生命周期内被移动，那么您确实删除了文件名的所有变体。 git log –name-only –follow –all – filename可以帮助您找到重命名。 你真的过滤了所有的refs：在调用git-filter-branch时使用–tag-name-filter cat – –all。然后有两种方法可以获得更小的存储库。更安全的方法是克隆，保持原始原封不动。 用git clone file:///path/to/repo克隆它。克隆将没有删除的对象。参见 git-clone [1] 。 （请注意，使用普通路径进行克隆只会将所有内容硬链接！） 忽略文件更新 情况：始终不需要git跟踪本地的一些文件 方法：使用.gitignore文件忽略 使用git init操作创建git控制管理之后，默认不会生成.gitignore文件。我们可以创建该文件，将对应的不需要的文件名或文件夹名添加进去。后面再使用git add .对所有新增文件更新到 git管理系统时不会追踪.gitignore中的文件，也不会在使用git status操作时有提示。 .gitignore适合添加一些IDE的配置文件，避免自己的配置文件在于他人协作或者项目迁移时产生影响。也适合添加编译生成的一些中间文件，以便保证git中添加的均为源代码。 需要注意的是.gitignore是用于管理不在index tree的文件，如果不小心将文件添加了进去，可以先使用git rm --cached filename命令将文件从托管中移除（不会删除文件本身），.gitignore就会生效。 情况：不需要将文件以后的更改更新到git，但是需要保留目前git中文件的状态 方法：git update-index --assume-unchanged filename 该操作标记文件，该文件后续的变化都不会更新到index tree。 如果需要恢复对文件的版本控制，执行以下操作: git update-index --no-assume-unchanged filename Notedu -hs &lt;flie/folder&gt;:查询文件/文件夹占用大小 参考： Git 工具 - 重写历史Git移除敏感数据Linux du 命令git使用-忽略文件更新的几种方法","link":"/2022/07/29/git%E5%BD%BB%E5%BA%95%E7%A7%BB%E9%99%A4%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6/"},{"title":"管理Chrome通过组策略","text":"前言Disable “Print…” in Context menu of selected text in Chrome 从该回答中获取到提示，使用chrome的组策略文件管理一些在chrome://flags中无法找到的一些功能选项。策略文件下载地址：https://chromeenterprise.google/browser/download/#manage-policies-tab rar压缩包内的结构： tree.bat123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288policy_templates│ VERSION│├─chromeos│ └─admx│ │ chromeos.admx│ │ google.admx│ ││ ├─de-DE│ │ chromeos.adml│ │ google.adml│ ││ ├─en-US│ │ chromeos.adml│ │ google.adml│ ││ ├─es-419│ │ chromeos.adml│ │ google.adml│ ││ ├─es-ES│ │ chromeos.adml│ │ google.adml│ ││ ├─fr-FR│ │ chromeos.adml│ │ google.adml│ ││ ├─id-ID│ │ chromeos.adml│ │ google.adml│ ││ ├─it-IT│ │ chromeos.adml│ │ google.adml│ ││ ├─ja-JP│ │ chromeos.adml│ │ google.adml│ ││ ├─ko-KR│ │ chromeos.adml│ │ google.adml│ ││ ├─nl-NL│ │ chromeos.adml│ │ google.adml│ ││ ├─pt-BR│ │ chromeos.adml│ │ google.adml│ ││ ├─ru-RU│ │ chromeos.adml│ │ google.adml│ ││ ├─th-TH│ │ chromeos.adml│ │ google.adml│ ││ ├─tr-TR│ │ chromeos.adml│ │ google.adml│ ││ ├─uk-UA│ │ chromeos.adml│ │ google.adml│ ││ ├─vi-VN│ │ chromeos.adml│ │ google.adml│ ││ ├─zh-CN│ │ chromeos.adml│ │ google.adml│ ││ └─zh-TW│ chromeos.adml│ google.adml│├─common│ └─html│ ├─de-DE│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─en-US│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─es-419│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─es-ES│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─fr-FR│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─id-ID│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─it-IT│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─ja-JP│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─ko-KR│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─nl-NL│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─pt-BR│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─ru-RU│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─th-TH│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─tr-TR│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─uk-UA│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─vi-VN│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ ├─zh-CN│ │ chrome_policy_atomic_groups_list.html│ │ chrome_policy_list.html│ ││ └─zh-TW│ chrome_policy_atomic_groups_list.html│ chrome_policy_list.html│└─windows ├─adm │ ├─de-DE │ │ chrome.adm │ │ │ ├─en-US │ │ chrome.adm │ │ │ ├─es-419 │ │ chrome.adm │ │ │ ├─es-ES │ │ chrome.adm │ │ │ ├─fr-FR │ │ chrome.adm │ │ │ ├─id-ID │ │ chrome.adm │ │ │ ├─it-IT │ │ chrome.adm │ │ │ ├─ja-JP │ │ chrome.adm │ │ │ ├─ko-KR │ │ chrome.adm │ │ │ ├─nl-NL │ │ chrome.adm │ │ │ ├─pt-BR │ │ chrome.adm │ │ │ ├─ru-RU │ │ chrome.adm │ │ │ ├─th-TH │ │ chrome.adm │ │ │ ├─tr-TR │ │ chrome.adm │ │ │ ├─uk-UA │ │ chrome.adm │ │ │ ├─vi-VN │ │ chrome.adm │ │ │ ├─zh-CN │ │ chrome.adm │ │ │ └─zh-TW │ chrome.adm │ ├─admx │ │ chrome.admx │ │ google.admx │ │ │ ├─de-DE │ │ chrome.adml │ │ google.adml │ │ │ ├─en-US │ │ chrome.adml │ │ google.adml │ │ │ ├─es-419 │ │ chrome.adml │ │ google.adml │ │ │ ├─es-ES │ │ chrome.adml │ │ google.adml │ │ │ ├─fr-FR │ │ chrome.adml │ │ google.adml │ │ │ ├─id-ID │ │ chrome.adml │ │ google.adml │ │ │ ├─it-IT │ │ chrome.adml │ │ google.adml │ │ │ ├─ja-JP │ │ chrome.adml │ │ google.adml │ │ │ ├─ko-KR │ │ chrome.adml │ │ google.adml │ │ │ ├─nl-NL │ │ chrome.adml │ │ google.adml │ │ │ ├─pt-BR │ │ chrome.adml │ │ google.adml │ │ │ ├─ru-RU │ │ chrome.adml │ │ google.adml │ │ │ ├─th-TH │ │ chrome.adml │ │ google.adml │ │ │ ├─tr-TR │ │ chrome.adml │ │ google.adml │ │ │ ├─uk-UA │ │ chrome.adml │ │ google.adml │ │ │ ├─vi-VN │ │ chrome.adml │ │ google.adml │ │ │ ├─zh-CN │ │ chrome.adml │ │ google.adml │ │ │ └─zh-TW │ chrome.adml │ google.adml │ └─examples chrome.reg 打开policy_templates\\common\\html\\zh-CN\\chrome_policy_list.html，查找自己需要控制的选项，打开regedit添加对应的项。 关闭菜单右键的分享页面选项说明：policy_templates/common/html/zh-CN/chrome_policy_list.html#DesktopSharingHubEnabled根据文档描述，关闭该功能的Reg如下： DesktopSharingHubEnabled.reg1234Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Software\\Policies\\Google\\Chrome]\"DesktopSharingHubEnabled\"=dword:00000000","link":"/2022/08/12/%E7%AE%A1%E7%90%86Chrome%E9%80%9A%E8%BF%87%E7%BB%84%E7%AD%96%E7%95%A5/"},{"title":"持久化Gist代码raw链接","text":"问题通常，Gist 文件的 raw 链接会随着版本二更改，但在使用上往往不便，因此需要持久化文件的 raw 链接地址。 解决方法获得 Gist 文件列表中的第一个文件： https://gist.github.com/gist_user/gist_id/raw/ 例如: https://gist.github.com/atenni/5604522/raw/ 即便更改了文件名，上述方法依然可以获得列表中的第一个文件。 获得多个文件： https://gist.github.com/gist_user/gist_id/raw/file_name 例如: https://gist.github.com/atenni/5604522/raw/README.md 参考 How to permalink to a gist’s raw file https://www.techkoala.top/permalink_gist_raw_file/","link":"/2022/08/17/%E6%8C%81%E4%B9%85%E5%8C%96Gist%E4%BB%A3%E7%A0%81raw%E9%93%BE%E6%8E%A5/"},{"title":"Nginx初识【二】","text":"Http代理Nginx常用反向代理配置规则 反向代理在http节点下，使用upstream配置服务地址，使用server的location配置代理映射。 Nginx.conf123456789101112131415upstream my_server { server 10.0.0.2:8080; keepalive 2000;}server { listen 80; server_name 192.168.0.1; client_max_body_size 1024M; #.... location /my/ { proxy_pass http://my_server/; proxy_set_header Host $host:$server_port; }} 通过该配置，访问nginx地址http://192.168.0.1:80/my的请求会被转发到my_server服务地址http://10.0.0.2:8080/。 需要注意的是，如果按照如下配置： Nginx.conf1234567891011121314upstream my_server { server 10.0.0.2:8080; keepalive 2000;}server { listen 80; server_name 192.168.0.1; client_max_body_size 1024M; location /my/ { proxy_pass http://my_server; proxy_set_header Host $host:$server_port; }} 那么，访问nginx地址http://10.0.0.1:80/my的请求会被转发到my_server服务地址http://10.0.0.2:8080/my。这是因为proxy_pass参数中如果不包含url的路径，则会将location的pattern识别的路径作为绝对路径。 重定向报文代理即便配置了nginx代理，当服务Response返回重定向报文时（http code为301或302），会将重定向的目标url地址放入http response报文的header的location字段内。用户浏览器收到重定向报文时，会解析出该字段并作跳转。此时新的请求报文将直接发送给服务地址，而非nginx地址。为了能让nginx拦截此类请求，必须修改重定向报文的location信息。 nginx.conf123456location /my/ { proxy_pass http://my_server; proxy_set_header Host $host:$server_port; proxy_redirect / /my/;} 使用proxy_redirect可以修改重定向报文的location字段，例子中会将所有的根路径下的url代理到nginx的/my/路径下返回给用户。比如服务返回的重定向报文的location原始值为/login，那么经过nginx代理后，用户收到的报文的location字段为/my/login。此时，浏览器将会跳转到nginx的/my/login地址进行访问。 需要注意的是，服务返回的重定向报文的location字段有时会填写绝对路径（包含服务的ip/域名和端口），有时候会填写相对路径，此时需要根据实际情况进行甄别。 nginx.conf123456location /my/ { proxy_pass http://my_server; proxy_set_header Host $host:$server_port; proxy_redirect http://my_server/ http://$host:$server_port/my/;} 上述配置便是将my_server服务的根路径下的所有路径代理到nginx地址的/my/路径下。当nginx配置只有一个server时，http://$host:$server_port前缀可以省略。 报文数据替换使用nginx代理最常见的情况就是http响应报文内写死了服务地址或web绝对路径。写死服务地址的情况比较少见，但也偶尔存在。最棘手的是写死了web绝对路径，尤其是绝对路径都没有公共前缀。举个例子来说： 一般的web页面会包含如下类似路径： /public：用于静态页面资源，如js脚本/public/js，样式表/public/css，图片/public/img等。 /static：和/public类似。 /api：用于后台服务API接口。 /login：用于登录验证。 其他。 对于这样的服务，可能的代理配置如下： nginx.conf123456789101112131415161718location /my/ { proxy_pass http://my_server/; proxy_set_header Host $host:$server_port; proxy_redirect / /my/;}location /login/ { proxy_pass http://my_server/public; proxy_set_header Host $host:$server_port;}location /public/ { proxy_pass http://my_server/public; proxy_set_header Host $host:$server_port;}location /api/ { proxy_pass http://my_server/api; proxy_set_header Host $host:$server_port;} 由于web页面或静态资源内写死了类似的绝对路径，那么对于用户来说，通过页面内的链接进行跳转时，都会请求到nginx服务对应的路径上。一旦存在另一个服务也包含类似的路径，也需要nginx进行代理，那么矛盾就出现了：访问nginx的同一个路径下的请求究竟转发给哪一个服务？ 要解决这个问题，必须在用户收到报文前，将报文的数据中包含的绝对路径都添加统一的前缀，如/my/public，/my/api，/my/login，这样nginx代理配置则可以简化为： nginx.conf123456789101112location /my/ { proxy_pass http://my_server/; proxy_set_header Host $host:$server_port; proxy_redirect / /my/;}location /other/ { proxy_pass http://other_server/; proxy_set_header Host $host:$server_port; proxy_redirect / /other/;} nginx的ngx_http_sub_module模块提供了类似的报文数据替换功能，该模块默认不会安装，需要在编译nginx时添加–with-http_sub_module参数，或者直接下载nginx的rpm包。 使用sub_filter对数据包进行替换的语法如下： nginx.conf1234567891011location /my/ { proxy_pass http://my_server/; proxy_set_header Host $host:$server_port; sub_filter 'href=\"/' 'href=\"/my/'; sub_filter 'src=\"/' 'src=\"/my/'; #sub_filter '10.170.24.244:7957' $host:$server_port; #sub_filter_types application/json application/x-javascript text/plain application/javascript; sub_filter_types text/html; sub_filter_once off;} 上述配置会将/my/下的所有响应报文内容的href=”/替换为href=”/my，以及src=”/替换为src=”/my，即为所有的绝对路径添加公共前缀。 注意，如果需要配置多个sub_filter，必须保证nginx是1.9.4版本之上的。 即便如此，sub_filter也不能解决所有问题。目前流行的js框架都会有自动渲染url的功能，也就是说，很多绝对路径并非写死在静态页面内，也是由js代码框架动态生成的，面对这样的情况，sub_filter也是无能为力了。对于这样的情况，笔者只能由衷地奉劝，还是安静的改代码吧！ Nginx配置SSL转发代理下列配置Nginx通过8406端口SSL转发代理http://192.168.2.17:8407。 nginx.conf1234567891011121314151617181920212223242526272829http { ... ssl_protocols TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; ... server{ listen 8406 ssl; server_name localhost; # SSL ssl_certificate cert/192-168-2-17_LIS.crt; ssl_certificate_key cert/192-168-2-17_LIS.key; ssl_trusted_certificate cert/192-168-2-17_RootCA.crt; proxy_read_timeout 2400s; location /{ # proxy_ssl_server_name on; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host:$server_port; proxy_set_header X-NginX-Proxy true; proxy_pass http://192.168.2.17:8407; proxy_set_header X-Request-URI $scheme://$host:$server_port$request_uri; proxy_redirect http://192.168.2.17:8407 https://$host:$server_port; } error_page 497 https://$host:$server_port$request_uri; } ...} 笔记重定向失败原因：未带端口转发 关键代码：proxy_set_header Host $host:$server_port; 参考： https://www.kancloud.cn/qq13867685/openresty-api-cn/159026https://blog.csdn.net/QIU176161650/article/details/124948351","link":"/2022/08/23/Nginx%E5%88%9D%E8%AF%86%E3%80%90%E4%BA%8C%E3%80%91/"},{"title":"vsocde便携版设置文件关联图标","text":"参考文章：https://blog.csdn.net/weixin_44220976/article/details/116354243 vscode_icon.reg123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\.json\\OpenWithProgids]\"VSCode.json\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.json]@=\".json\"[HKEY_CLASSES_ROOT\\VSCode.json\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\json.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.json\\shell][HKEY_CLASSES_ROOT\\VSCode.json\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.json\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.json\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.json\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.json]@=\".json\"[HKEY_CLASSES_ROOT\\VSCode.json\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\json.ico\\\"\"[HKEY_CLASSES_ROOT\\.html\\OpenWithProgids]\"VSCode.html\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.html]@=\".html\"[HKEY_CLASSES_ROOT\\VSCode.html\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\html.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.html\\shell][HKEY_CLASSES_ROOT\\VSCode.html\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.html\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.html\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.html\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.html]@=\".html\"[HKEY_CLASSES_ROOT\\VSCode.html\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\html.ico\\\"\"[HKEY_CLASSES_ROOT\\.bower\\OpenWithProgids]\"VSCode.bower\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.bower]@=\".bower\"[HKEY_CLASSES_ROOT\\VSCode.bower\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\bower.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.bower\\shell][HKEY_CLASSES_ROOT\\VSCode.bower\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.bower\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.bower\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.bower\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.bower]@=\".bower\"[HKEY_CLASSES_ROOT\\VSCode.bower\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\bower.ico\\\"\"[HKEY_CLASSES_ROOT\\.c\\OpenWithProgids]\"VSCode.c\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.c]@=\".c\"[HKEY_CLASSES_ROOT\\VSCode.c\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\c.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.c\\shell][HKEY_CLASSES_ROOT\\VSCode.c\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.c\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.c\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.c\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.c]@=\".c\"[HKEY_CLASSES_ROOT\\VSCode.c\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\c.ico\\\"\"[HKEY_CLASSES_ROOT\\.config\\OpenWithProgids]\"VSCode.config\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.config]@=\".config\"[HKEY_CLASSES_ROOT\\VSCode.config\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\config.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.config\\shell][HKEY_CLASSES_ROOT\\VSCode.config\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.config\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.config\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.config\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.config]@=\".config\"[HKEY_CLASSES_ROOT\\VSCode.config\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\config.ico\\\"\"[HKEY_CLASSES_ROOT\\.cpp\\OpenWithProgids]\"VSCode.cpp\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.cpp]@=\".cpp\"[HKEY_CLASSES_ROOT\\VSCode.cpp\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\cpp.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.cpp\\shell][HKEY_CLASSES_ROOT\\VSCode.cpp\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.cpp\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.cpp\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.cpp\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.cpp]@=\".cpp\"[HKEY_CLASSES_ROOT\\VSCode.cpp\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\cpp.ico\\\"\"[HKEY_CLASSES_ROOT\\.csharp\\OpenWithProgids]\"VSCode.csharp\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.csharp]@=\".csharp\"[HKEY_CLASSES_ROOT\\VSCode.csharp\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\csharp.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.csharp\\shell][HKEY_CLASSES_ROOT\\VSCode.csharp\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.csharp\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.csharp\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.csharp\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.csharp]@=\".csharp\"[HKEY_CLASSES_ROOT\\VSCode.csharp\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\csharp.ico\\\"\"[HKEY_CLASSES_ROOT\\.css\\OpenWithProgids]\"VSCode.css\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.css]@=\".css\"[HKEY_CLASSES_ROOT\\VSCode.css\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\css.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.css\\shell][HKEY_CLASSES_ROOT\\VSCode.css\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.css\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.css\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.css\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.css]@=\".css\"[HKEY_CLASSES_ROOT\\VSCode.css\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\css.ico\\\"\"[HKEY_CLASSES_ROOT\\.go\\OpenWithProgids]\"VSCode.go\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.go]@=\".go\"[HKEY_CLASSES_ROOT\\VSCode.go\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\go.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.go\\shell][HKEY_CLASSES_ROOT\\VSCode.go\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.go\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.go\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.go\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.go]@=\".go\"[HKEY_CLASSES_ROOT\\VSCode.go\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\go.ico\\\"\"[HKEY_CLASSES_ROOT\\.java\\OpenWithProgids]\"VSCode.java\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.java]@=\".java\"[HKEY_CLASSES_ROOT\\VSCode.java\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\java.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.java\\shell][HKEY_CLASSES_ROOT\\VSCode.java\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.java\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.java\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.java\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.java]@=\".java\"[HKEY_CLASSES_ROOT\\VSCode.java\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\java.ico\\\"\"[HKEY_CLASSES_ROOT\\.javascript\\OpenWithProgids]\"VSCode.javascript\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.javascript]@=\".javascript\"[HKEY_CLASSES_ROOT\\VSCode.javascript\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\javascript.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.javascript\\shell][HKEY_CLASSES_ROOT\\VSCode.javascript\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.javascript\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.javascript\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.javascript\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.javascript]@=\".javascript\"[HKEY_CLASSES_ROOT\\VSCode.javascript\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\javascript.ico\\\"\"[HKEY_CLASSES_ROOT\\.less\\OpenWithProgids]\"VSCode.less\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.less]@=\".less\"[HKEY_CLASSES_ROOT\\VSCode.less\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\less.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.less\\shell][HKEY_CLASSES_ROOT\\VSCode.less\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.less\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.less\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.less\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.less]@=\".less\"[HKEY_CLASSES_ROOT\\VSCode.less\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\less.ico\\\"\"[HKEY_CLASSES_ROOT\\.markdown\\OpenWithProgids]\"VSCode.markdown\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.markdown]@=\".markdown\"[HKEY_CLASSES_ROOT\\VSCode.markdown\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\markdown.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.markdown\\shell][HKEY_CLASSES_ROOT\\VSCode.markdown\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.markdown\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.markdown\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.markdown\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.markdown]@=\".markdown\"[HKEY_CLASSES_ROOT\\VSCode.markdown\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\markdown.ico\\\"\"[HKEY_CLASSES_ROOT\\.python\\OpenWithProgids]\"VSCode.python\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.python]@=\".python\"[HKEY_CLASSES_ROOT\\VSCode.python\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\python.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.python\\shell][HKEY_CLASSES_ROOT\\VSCode.python\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.python\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.python\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.python\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.python]@=\".python\"[HKEY_CLASSES_ROOT\\VSCode.python\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\python.ico\\\"\"[HKEY_CLASSES_ROOT\\.sql\\OpenWithProgids]\"VSCode.sql\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.sql]@=\".sql\"[HKEY_CLASSES_ROOT\\VSCode.sql\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\sql.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.sql\\shell][HKEY_CLASSES_ROOT\\VSCode.sql\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.sql\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.sql\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.sql\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.sql]@=\".sql\"[HKEY_CLASSES_ROOT\\VSCode.sql\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\sql.ico\\\"\"[HKEY_CLASSES_ROOT\\.xml\\OpenWithProgids]\"VSCode.xml\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.xml]@=\".xml\"[HKEY_CLASSES_ROOT\\VSCode.xml\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\xml.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.xml\\shell][HKEY_CLASSES_ROOT\\VSCode.xml\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.xml\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.xml\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.xml\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.xml]@=\".xml\"[HKEY_CLASSES_ROOT\\VSCode.xml\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\xml.ico\\\"\"[HKEY_CLASSES_ROOT\\.typescript\\OpenWithProgids]\"VSCode.typescript\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.typescript]@=\".typescript\"[HKEY_CLASSES_ROOT\\VSCode.typescript\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\typescript.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.typescript\\shell][HKEY_CLASSES_ROOT\\VSCode.typescript\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.typescript\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.typescript\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.typescript\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.typescript]@=\".typescript\"[HKEY_CLASSES_ROOT\\VSCode.typescript\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\typescript.ico\\\"\"[HKEY_CLASSES_ROOT\\.default\\OpenWithProgids]\"VSCode.default\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.default]@=\".default\"[HKEY_CLASSES_ROOT\\VSCode.default\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\default.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.default\\shell][HKEY_CLASSES_ROOT\\VSCode.default\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.default\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.default\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.default\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.default]@=\".default\"[HKEY_CLASSES_ROOT\\VSCode.default\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\default.ico\\\"\"[HKEY_CLASSES_ROOT\\.md\\OpenWithProgids]\"VSCode.md\"=\"\"[HKEY_CLASSES_ROOT\\VSCode.md]@=\".md\"[HKEY_CLASSES_ROOT\\VSCode.md\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\markdown.ico\\\"\"[HKEY_CLASSES_ROOT\\VSCode.md\\shell][HKEY_CLASSES_ROOT\\VSCode.md\\shell\\edit][HKEY_CLASSES_ROOT\\VSCode.md\\shell\\edit\\command]@=\"notepad.exe \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.md\\shell\\open][HKEY_CLASSES_ROOT\\VSCode.md\\shell\\open\\command]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\Code.exe\\\" \\\"%1\\\"\"[HKEY_CLASSES_ROOT\\VSCode.md]@=\".md\"[HKEY_CLASSES_ROOT\\VSCode.md\\DefaultIcon]@=\"\\\"G:\\\\Soft\\\\VSCode\\\\resources\\\\app\\\\resources\\\\win32\\\\markdown.ico\\\"\"","link":"/2022/08/26/vsocde%E4%BE%BF%E6%90%BA%E7%89%88%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94%E5%9B%BE%E6%A0%87/"},{"title":"使用JMeter进行压力测试","text":"前言Postman的Runner不支持并行调用，无法模拟出多用户并发的情况。所以使用JMeter进行压力测试和一些并发测试。 练习DemoCASTest.jmx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;jmeterTestPlan version=\"1.2\" properties=\"5.0\" jmeter=\"5.5\"&gt; &lt;hashTree&gt; &lt;TestPlan guiclass=\"TestPlanGui\" testclass=\"TestPlan\" testname=\"CASTest\" enabled=\"true\"&gt; &lt;stringProp name=\"TestPlan.comments\"&gt;&lt;/stringProp&gt; &lt;boolProp name=\"TestPlan.functional_mode\"&gt;false&lt;/boolProp&gt; &lt;boolProp name=\"TestPlan.tearDown_on_shutdown\"&gt;true&lt;/boolProp&gt; &lt;boolProp name=\"TestPlan.serialize_threadgroups\"&gt;false&lt;/boolProp&gt; &lt;elementProp name=\"TestPlan.user_defined_variables\" elementType=\"Arguments\" guiclass=\"ArgumentsPanel\" testclass=\"Arguments\" testname=\"User Defined Variables\" enabled=\"true\"&gt; &lt;collectionProp name=\"Arguments.arguments\"/&gt; &lt;/elementProp&gt; &lt;stringProp name=\"TestPlan.user_define_classpath\"&gt;&lt;/stringProp&gt; &lt;/TestPlan&gt; &lt;hashTree&gt; &lt;ThreadGroup guiclass=\"ThreadGroupGui\" testclass=\"ThreadGroup\" testname=\"更新测试接口\" enabled=\"true\"&gt; &lt;stringProp name=\"ThreadGroup.on_sample_error\"&gt;continue&lt;/stringProp&gt; &lt;elementProp name=\"ThreadGroup.main_controller\" elementType=\"LoopController\" guiclass=\"LoopControlPanel\" testclass=\"LoopController\" testname=\"循环控制器\" enabled=\"true\"&gt; &lt;boolProp name=\"LoopController.continue_forever\"&gt;false&lt;/boolProp&gt; &lt;stringProp name=\"LoopController.loops\"&gt;1&lt;/stringProp&gt; &lt;/elementProp&gt; &lt;stringProp name=\"ThreadGroup.num_threads\"&gt;70&lt;/stringProp&gt; &lt;stringProp name=\"ThreadGroup.ramp_time\"&gt;1&lt;/stringProp&gt; &lt;boolProp name=\"ThreadGroup.scheduler\"&gt;false&lt;/boolProp&gt; &lt;stringProp name=\"ThreadGroup.duration\"&gt;&lt;/stringProp&gt; &lt;stringProp name=\"ThreadGroup.delay\"&gt;&lt;/stringProp&gt; &lt;boolProp name=\"ThreadGroup.same_user_on_next_iteration\"&gt;true&lt;/boolProp&gt; &lt;/ThreadGroup&gt; &lt;hashTree&gt; &lt;HTTPSamplerProxy guiclass=\"HttpTestSampleGui\" testclass=\"HTTPSamplerProxy\" testname=\"HTTP请求\" enabled=\"true\"&gt; &lt;elementProp name=\"HTTPsampler.Arguments\" elementType=\"Arguments\" guiclass=\"HTTPArgumentsPanel\" testclass=\"Arguments\" testname=\"用户定义的变量\" enabled=\"true\"&gt; &lt;collectionProp name=\"Arguments.arguments\"&gt; &lt;elementProp name=\"service\" elementType=\"HTTPArgument\"&gt; &lt;boolProp name=\"HTTPArgument.always_encode\"&gt;false&lt;/boolProp&gt; &lt;stringProp name=\"Argument.value\"&gt;UpdateTotal&lt;/stringProp&gt; &lt;stringProp name=\"Argument.metadata\"&gt;=&lt;/stringProp&gt; &lt;boolProp name=\"HTTPArgument.use_equals\"&gt;true&lt;/boolProp&gt; &lt;stringProp name=\"Argument.name\"&gt;service&lt;/stringProp&gt; &lt;/elementProp&gt; &lt;elementProp name=\"appid\" elementType=\"HTTPArgument\"&gt; &lt;boolProp name=\"HTTPArgument.always_encode\"&gt;false&lt;/boolProp&gt; &lt;stringProp name=\"Argument.value\"&gt;1999042740418347&lt;/stringProp&gt; &lt;stringProp name=\"Argument.metadata\"&gt;=&lt;/stringProp&gt; &lt;boolProp name=\"HTTPArgument.use_equals\"&gt;true&lt;/boolProp&gt; &lt;stringProp name=\"Argument.name\"&gt;appid&lt;/stringProp&gt; &lt;/elementProp&gt; &lt;elementProp name=\"data\" elementType=\"HTTPArgument\"&gt; &lt;boolProp name=\"HTTPArgument.always_encode\"&gt;false&lt;/boolProp&gt; &lt;stringProp name=\"Argument.value\"&gt;{&amp;quot;hoscode&amp;quot;:&amp;quot;${hoscode}&amp;quot;,&amp;quot;st&amp;quot;:&amp;quot;${st}&amp;quot;,&amp;quot;ed&amp;quot;:&amp;quot;${ed}&amp;quot;}&lt;/stringProp&gt; &lt;stringProp name=\"Argument.metadata\"&gt;=&lt;/stringProp&gt; &lt;boolProp name=\"HTTPArgument.use_equals\"&gt;true&lt;/boolProp&gt; &lt;stringProp name=\"Argument.name\"&gt;data&lt;/stringProp&gt; &lt;/elementProp&gt; &lt;/collectionProp&gt; &lt;/elementProp&gt; &lt;stringProp name=\"HTTPSampler.domain\"&gt;&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.port\"&gt;&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.protocol\"&gt;&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.contentEncoding\"&gt;&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.path\"&gt;/API/PlatDict/UpdateTotal&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.method\"&gt;POST&lt;/stringProp&gt; &lt;boolProp name=\"HTTPSampler.follow_redirects\"&gt;true&lt;/boolProp&gt; &lt;boolProp name=\"HTTPSampler.auto_redirects\"&gt;false&lt;/boolProp&gt; &lt;boolProp name=\"HTTPSampler.use_keepalive\"&gt;true&lt;/boolProp&gt; &lt;boolProp name=\"HTTPSampler.DO_MULTIPART_POST\"&gt;false&lt;/boolProp&gt; &lt;stringProp name=\"HTTPSampler.embedded_url_re\"&gt;&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.connect_timeout\"&gt;&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.response_timeout\"&gt;&lt;/stringProp&gt; &lt;/HTTPSamplerProxy&gt; &lt;hashTree&gt; &lt;CSVDataSet guiclass=\"TestBeanGUI\" testclass=\"CSVDataSet\" testname=\"CSV 数据文件设置\" enabled=\"true\"&gt; &lt;stringProp name=\"delimiter\"&gt;,&lt;/stringProp&gt; &lt;stringProp name=\"fileEncoding\"&gt;UTF-8&lt;/stringProp&gt; &lt;stringProp name=\"filename\"&gt;../workspace/JMterTest.csv&lt;/stringProp&gt; &lt;boolProp name=\"ignoreFirstLine\"&gt;true&lt;/boolProp&gt; &lt;boolProp name=\"quotedData\"&gt;false&lt;/boolProp&gt; &lt;boolProp name=\"recycle\"&gt;true&lt;/boolProp&gt; &lt;stringProp name=\"shareMode\"&gt;shareMode.group&lt;/stringProp&gt; &lt;boolProp name=\"stopThread\"&gt;false&lt;/boolProp&gt; &lt;stringProp name=\"variableNames\"&gt;st,ed,hoscode&lt;/stringProp&gt; &lt;/CSVDataSet&gt; &lt;hashTree/&gt; &lt;/hashTree&gt; &lt;ConfigTestElement guiclass=\"HttpDefaultsGui\" testclass=\"ConfigTestElement\" testname=\"HTTP请求默认值\" enabled=\"true\"&gt; &lt;elementProp name=\"HTTPsampler.Arguments\" elementType=\"Arguments\" guiclass=\"HTTPArgumentsPanel\" testclass=\"Arguments\" testname=\"用户定义的变量\" enabled=\"true\"&gt; &lt;collectionProp name=\"Arguments.arguments\"/&gt; &lt;/elementProp&gt; &lt;stringProp name=\"HTTPSampler.domain\"&gt;127.0.0.1&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.port\"&gt;7957&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.protocol\"&gt;http&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.contentEncoding\"&gt;&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.path\"&gt;&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.concurrentPool\"&gt;6&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.connect_timeout\"&gt;&lt;/stringProp&gt; &lt;stringProp name=\"HTTPSampler.response_timeout\"&gt;&lt;/stringProp&gt; &lt;/ConfigTestElement&gt; &lt;hashTree/&gt; &lt;HeaderManager guiclass=\"HeaderPanel\" testclass=\"HeaderManager\" testname=\"HTTP信息头管理器\" enabled=\"true\"&gt; &lt;collectionProp name=\"HeaderManager.headers\"&gt; &lt;elementProp name=\"Content-Type\" elementType=\"Header\"&gt; &lt;stringProp name=\"Header.name\"&gt;Content-Type&lt;/stringProp&gt; &lt;stringProp name=\"Header.value\"&gt;application/x-www-form-urlencoded&lt;/stringProp&gt; &lt;/elementProp&gt; &lt;/collectionProp&gt; &lt;/HeaderManager&gt; &lt;hashTree/&gt; &lt;ResponseAssertion guiclass=\"AssertionGui\" testclass=\"ResponseAssertion\" testname=\"响应断言\" enabled=\"true\"&gt; &lt;collectionProp name=\"Asserion.test_strings\"&gt; &lt;stringProp name=\"49586\"&gt;200&lt;/stringProp&gt; &lt;/collectionProp&gt; &lt;stringProp name=\"Assertion.custom_message\"&gt;test error&lt;/stringProp&gt; &lt;stringProp name=\"Assertion.test_field\"&gt;Assertion.response_code&lt;/stringProp&gt; &lt;boolProp name=\"Assertion.assume_success\"&gt;false&lt;/boolProp&gt; &lt;intProp name=\"Assertion.test_type\"&gt;8&lt;/intProp&gt; &lt;/ResponseAssertion&gt; &lt;hashTree/&gt; &lt;ResultCollector guiclass=\"ViewResultsFullVisualizer\" testclass=\"ResultCollector\" testname=\"查看结果树\" enabled=\"true\"&gt; &lt;boolProp name=\"ResultCollector.error_logging\"&gt;false&lt;/boolProp&gt; &lt;objProp&gt; &lt;name&gt;saveConfig&lt;/name&gt; &lt;value class=\"SampleSaveConfiguration\"&gt; &lt;time&gt;true&lt;/time&gt; &lt;latency&gt;true&lt;/latency&gt; &lt;timestamp&gt;true&lt;/timestamp&gt; &lt;success&gt;true&lt;/success&gt; &lt;label&gt;true&lt;/label&gt; &lt;code&gt;true&lt;/code&gt; &lt;message&gt;true&lt;/message&gt; &lt;threadName&gt;true&lt;/threadName&gt; &lt;dataType&gt;true&lt;/dataType&gt; &lt;encoding&gt;false&lt;/encoding&gt; &lt;assertions&gt;true&lt;/assertions&gt; &lt;subresults&gt;true&lt;/subresults&gt; &lt;responseData&gt;false&lt;/responseData&gt; &lt;samplerData&gt;false&lt;/samplerData&gt; &lt;xml&gt;false&lt;/xml&gt; &lt;fieldNames&gt;true&lt;/fieldNames&gt; &lt;responseHeaders&gt;false&lt;/responseHeaders&gt; &lt;requestHeaders&gt;false&lt;/requestHeaders&gt; &lt;responseDataOnError&gt;false&lt;/responseDataOnError&gt; &lt;saveAssertionResultsFailureMessage&gt;true&lt;/saveAssertionResultsFailureMessage&gt; &lt;assertionsResultsToSave&gt;0&lt;/assertionsResultsToSave&gt; &lt;bytes&gt;true&lt;/bytes&gt; &lt;sentBytes&gt;true&lt;/sentBytes&gt; &lt;url&gt;true&lt;/url&gt; &lt;threadCounts&gt;true&lt;/threadCounts&gt; &lt;idleTime&gt;true&lt;/idleTime&gt; &lt;connectTime&gt;true&lt;/connectTime&gt; &lt;/value&gt; &lt;/objProp&gt; &lt;stringProp name=\"filename\"&gt;&lt;/stringProp&gt; &lt;/ResultCollector&gt; &lt;hashTree/&gt; &lt;ResultCollector guiclass=\"StatVisualizer\" testclass=\"ResultCollector\" testname=\"聚合报告\" enabled=\"true\"&gt; &lt;boolProp name=\"ResultCollector.error_logging\"&gt;false&lt;/boolProp&gt; &lt;objProp&gt; &lt;name&gt;saveConfig&lt;/name&gt; &lt;value class=\"SampleSaveConfiguration\"&gt; &lt;time&gt;true&lt;/time&gt; &lt;latency&gt;true&lt;/latency&gt; &lt;timestamp&gt;true&lt;/timestamp&gt; &lt;success&gt;true&lt;/success&gt; &lt;label&gt;true&lt;/label&gt; &lt;code&gt;true&lt;/code&gt; &lt;message&gt;true&lt;/message&gt; &lt;threadName&gt;true&lt;/threadName&gt; &lt;dataType&gt;true&lt;/dataType&gt; &lt;encoding&gt;false&lt;/encoding&gt; &lt;assertions&gt;true&lt;/assertions&gt; &lt;subresults&gt;true&lt;/subresults&gt; &lt;responseData&gt;false&lt;/responseData&gt; &lt;samplerData&gt;false&lt;/samplerData&gt; &lt;xml&gt;false&lt;/xml&gt; &lt;fieldNames&gt;true&lt;/fieldNames&gt; &lt;responseHeaders&gt;false&lt;/responseHeaders&gt; &lt;requestHeaders&gt;false&lt;/requestHeaders&gt; &lt;responseDataOnError&gt;false&lt;/responseDataOnError&gt; &lt;saveAssertionResultsFailureMessage&gt;true&lt;/saveAssertionResultsFailureMessage&gt; &lt;assertionsResultsToSave&gt;0&lt;/assertionsResultsToSave&gt; &lt;bytes&gt;true&lt;/bytes&gt; &lt;sentBytes&gt;true&lt;/sentBytes&gt; &lt;url&gt;true&lt;/url&gt; &lt;threadCounts&gt;true&lt;/threadCounts&gt; &lt;idleTime&gt;true&lt;/idleTime&gt; &lt;connectTime&gt;true&lt;/connectTime&gt; &lt;/value&gt; &lt;/objProp&gt; &lt;stringProp name=\"filename\"&gt;&lt;/stringProp&gt; &lt;/ResultCollector&gt; &lt;hashTree/&gt; &lt;/hashTree&gt; &lt;/hashTree&gt; &lt;/hashTree&gt;&lt;/jmeterTestPlan&gt; JMetertest.csv12st,ed,hoscode2022-07-01,2022-08-31,QJ00101 无UI启动run.bat1G: cd Soft\\apache-jmeter-5.5\\bin jmeter -n -t G:\\Soft\\apache-jmeter-5.5\\WorkSpace\\CASTest.jmx -l G:\\Soft\\apache-jmeter-5.5\\WorkSpace\\result\\result.txt -e -o G:\\Soft\\apache-jmeter-5.5\\WorkSpace\\webreport 参考服务端性能测试-工具篇使用 JMeter 进行压力测试文章截图：","link":"/2022/08/31/%E4%BD%BF%E7%94%A8JMeter%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"},{"title":"SQLSERVER查询超时问题","text":"问题描述公司有一个正常运行的winform小程序,具体功能是定时跑一个任务，任务内容是从第三方数据库中查询出数据，存入另一个库。已经正常运行了一个多月，最近发现，从三天前开始，一些任务一直报`”Timeout 时间已到。在操作完成之前超时时间已过或服务器未响应。” 。但实际上服务器的网络是能够正常连接上第三方数据库的，并且使用UI工具执行相同SQL是非常快的。 分析问题导致查询超时的原因会有很多种，根据这个答案的描述： This type of timeout can have three causes; There’s a deadlock somewhere The database’s statistics and/or query plan cache are incorrect The query is too complex and needs to be tuned 首先排除了第一条，因为在查询工具中同样的查询语句是可以查询出数据的，不存在死锁、事务等问题。其次第二条所描述的统计信息问题，因为数据库有定时任务进行统计信息的维护，所以不存在这个问题。最后只剩下分析sql语句问题了，在工具中运行SQL执行计划分析，是可以走索引快速查询出数据的。这里因为程序使用的是ADO.NET的参数化查询，所以可能会存在实际生成的sql语句和数据库工具中的不一致。 问题定位WinForm程序使用SqlClient对SQL Server数据库进行访问，其中使用到了参数化查询功能，进一步分析参数化查询片段代码是否正确。 问题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162string IP=\"\";string SYS =\"\";string sSql = @\"select * FROM Table_User WHERE loginIP=@IP AND loginSys=@SYS\";SqlParameter[] param = new SqlParameter[]{ new SqlParameter(\"@IP\",IP), new SqlParameter(\"@SYS\",SYS)};using (SqlConnection conn = new SqlConnection(GetConnectString(_Type))){ using (SqlCommand sqlCommand = new SqlCommand()) { try { PrepareCommand(sqlCommand, conn, null, SQLString, cmdParms); int result = sqlCommand.ExecuteNonQuery(); sqlCommand.Parameters.Clear(); return result; } catch (SqlException ex) { foreach (SqlParameter sqlParameter in cmdParms) { SQLString = SQLString.Replace(sqlParameter.ParameterName, (sqlParameter.Value == null) ? \"\" : sqlParameter.Value.ToString()); } throw new Exception(ex.Message + \" SQL:\" + SQLString); } }}void PrepareCommand(SqlCommand cmd, SqlConnection conn, SqlTransaction trans, string cmdText, SqlParameter[] cmdParms){ if (conn.State != ConnectionState.Open) { conn.Open(); } cmd.Connection = conn; cmd.CommandText = cmdText; if (trans != null) { cmd.Transaction = trans; } cmd.CommandType = CommandType.Text; if (cmdParms == null) { return; } foreach (SqlParameter sqlParameter in cmdParms) { if ((sqlParameter.Direction == ParameterDirection.InputOutput || sqlParameter.Direction == ParameterDirection.Input) &amp;&amp; sqlParameter.Value == null) { sqlParameter.Value = DBNull.Value; } cmd.Parameters.Add(sqlParameter); }} 问题原因根据微软文档描述：SqlParameter.DbType 属性，默认值为 NVarChar在第三方库中的表结构字段类型都为VarChar类型，而SqlCommand中,因为没有设置参数类型，导致使用默认的NVarChar类型的SqlParameter进行参数化查询。字段类型不匹配导致Sql查询从索引扫描变成了全表扫描，直接导致查询缓慢的问题。 问题修复 使用SqlParameter(String, SqlDbType, Int32)替代SqlParameter(String, Object)，添加正确的DbType和size 直接使用SqlServer的查询分析器的默认匹配类型特点，改造sql语句。【不推荐】 排查故障参考 Timeout expired. The timeout period elapsed prior to completion of the operation or the server is not responding. The statement has been terminated参数化查询比拼接字符串慢的原因原因： 经过查阅资料和自己的分析后，得知原来是字符类型的不匹配造成的。因为这个数据表是客户数据库中的，我只是提取数据，而我一般建数据表都使用NVarchar类型,而客户的这个表使用的是Char(32)，在查询分析器中直接写字符串作为查询条件时，查询优化器认为条件中等号两边的字符类型是相同的，从而会选择聚集索引查询，而在ADO.NET中使用SqlParameter后，因为字段类型错误导致了Sql查询从索引扫描变成了表扫描… 所以为了避免在Sql查询中由于条件字段类型不匹配而导致表扫描，记得以后在创建SqlParameter时声明SqlDbType就解决问题了。","link":"/2022/09/05/SQLSERVER%E5%8F%82%E6%95%B0%E5%8C%96%E6%9F%A5%E8%AF%A2%E7%BC%93%E6%85%A2%E9%97%AE%E9%A2%98/"},{"title":"sqlserver事务日志增长过快应对策略","text":"SQL Server事务日志处理方法1. 将数据库恢复模式设置为简单模式2. 定时收缩数据库日志文件收缩数据库日志文件大小： 12345678910111213141516--需要注意的是在收缩日志文件时，数据库不能有正在活动的备份事务。--将plat_lis数据库中的日志文件收缩到 1 MB。 USE testDB; GO -- 通过将数据库恢复模型更改为 SIMPLE 来截断日志。ALTER DATABASE testDB SET RECOVERY SIMPLE; GO -- Shrink the truncated log file to 1 MB. DBCC SHRINKFILE (testDB_log, 1); GO -- 重置数据库恢复模式。ALTER DATABASE testDB SET RECOVERY FULL; GO 3. 定时完全（full）备份数据库、截断事务日志事务日志的截断与收缩 截断事务日志事务日志会自动截断的操作： 1. 备份事务日志 2. 设置简单模式再设置回来 3. 使用backup log with no_log或 backup log with truncate_only 4. 从未对数据库进行过完全（full）备份概要总结：所谓的截断(truncated)只是将可恢复状态的VLF转换到可重用状态 参考事务日志的截断与收缩完整数据库备份 (SQL Server)SqlServer日志增长过快应对策略 引用截图：","link":"/2022/09/07/sqlserver%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E5%A2%9E%E9%95%BF%E8%BF%87%E5%BF%AB%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5/"},{"title":"服务端性能测试（转载）","text":"参考服务端性能测试 - 入门指南 (慎入: 6000 字长文)","link":"/2022/09/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"},{"title":"设计用户认证模块的最佳实践","text":"前言 转载自：Best Practices for Designing a User Authentication Module 摘录 设计身份验证模块的最佳实践将用户帐户和用户身份的概念分开。这种分离允许用户将多个身份验证因素链接到单个用户帐户并随意更改这些因素。 笔记一、用户认证模块的表设计应该尽可能的将用户账户信息和用户登录的信息区分开来，将用户个人属性和用户认证用到的属性进一步原子化。二、用户应该在系统中存在内部唯一的标识值（与用户登录信息无关），通过内部标识值去进行登录验证操作的关联，确保数据的一致性。三、用户权限设计时，尽可能的将授权信息和用户信息表解耦，使用内部标识符进行关联，数据的准确性通过系统代码去控制。四、应该尽量将各个模块根据实际需求、业务抽象成具体的表，将其按照功能模块建立模型关系或通过程序代码控制；不应该将大量数据属性聚合在一张表中，过于耦合的数据库结构，会降低系统的健壮性，不利于未来的拓展开发。 Demo数据库Sql","link":"/2022/09/29/%E8%AE%BE%E8%AE%A1%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"字符编码笔记","text":"字节、字符、字符编码概念 字节：是计算机存储数据的存储单元，是一个8位的二进制数 计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。 字符：指类字形单位或符号，包括字母、数字、运算符号、标点符号和其他符号，以及一些功能性符号，比如”1”, “汉”, “お”,”℃”等等。 字符是电子计算机或无线电通信中字母、数字、符号的统称，其是数据结构中最小的数据存取单位，通常由8个二进制位(一个字节)来表示一个字符。 字符是计算机中经常用到的二进制编码形式，也是计算机中最常用到的信息形式。 字符编码：是大家对计算机如何使用字节来表示一个字符的约定，可分为ASCII编码，ANSI编码（本地化编码），UNICODE编码（国际化编码）三种。 也称字集码，是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。 编码：是信息从一种形式或格式转换为另一种形式的过程，也称为“计算机编程语言的代码”，简称“编码”。 用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。 编码在电子计算机、电视、遥控和通讯等方面广泛使用。 “字节”与“字符”它们完全不是一个位面的概念，所以两者之间没有“区别”这个说法。不同编码里，字符和字节的对应关系不同： ①ASCII码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。 ②UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 ③Unicode编码中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。 符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。 ④UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。 ⑤UTF-32编码中，世界上任何字符的存储都需要4个字节。 ANSI编码有很多种，但是都只是规定自己国家的语言，这时候出现了UNICODE编码，该编码类似于ANSI，使用多个字节表示一个字符，UNICODE编码把世界上各种主要语言都进行了编码，当然UNICDOE编码也出现了很多种编码方案，比如使用8个二进制位的UTF8以及使用16个二进制位的UTF16等等。 编码字符编码 ASCII 码：单字节编码。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。 ASCII Code - The extended ASCII table 非 ASCII 编码：多字节编码。英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel(ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128–255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 UNICODE编码：宽字节编码正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。 Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 Unicode 的问题需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 它们造成的结果是： 出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 Unicode 在很长一段时间内无法推广，直到互联网的出现。 UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。**重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。** UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode 和 UTF-8 之间的转换关系表 (字母x表示可用编码的位。 ) 码点的位数 码点起值 码点终值 字节序列 Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 7 U+0000 U+007F 1 0xxxxxxx 11 U+0080 U+07FF 2 110xxxxx 10xxxxxx 16 U+0800 U+FFFF 3 1110xxxx 10xxxxxx 10xxxxxx 21 U+10000 U+1FFFFF 4 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 26 U+200000 U+3FFFFFF 5 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 31 U+4000000 U+7FFFFFFF 6 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 在ASCII码的范围，用一个位元组表示，超出ASCII码的范围就用位元组表示，这就形成了我们上面看到的UTF-8的表示方法，这样的好处是当UNICODE文件中只有ASCII码时，储存的文件都为一个位元组，所以就是普通的ASCII文件无异，读取的时候也是如此，所以能与以前的ASCII文件相容。 大于ASCII码的，就会由上面的第一位元组的前几位表示该unicode字元的长度，比如110xxxxx前三位的二进位表示告诉我们这是个2BYTE的UNICODE字元；1110xxxx是个三位的UNICODE字元，依此类推；xxx的位置由字符编码数的二进制表示的位填入。越靠右的x具有越少的特殊意义。只用最短的那个足够表达一个字符编码数的多字节串。注意在多字节串中，第一个字节的开头”1”的数目就是整个串中字节的数目。 以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 笔记 Unicode编码系统可分为编码方式和实现方式两个层次 Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 一个字节(byte)由8位二进制数组成 一个十六进制数可以转成4位二进制数 Unicode编码方式使用两个字节(byte)进行编码和字符的关联，即4位十六进制数，即16位二进制数， UTF-8 是Unicode编码系统的实现方式之一 拓展知识字符编码方案的演变摘录：总结字符编码方案的演变，我们大致上可简单地划分为三个阶段： ① ASCII 编码方案阶段 → ② ANSI 编码方案阶段 → ③ Unicode / UCS 编码方案阶段。 ASCII 编码：在第一个阶段的 ASCII 编码方案阶段，ASCII 编码方案主要适用于美国（与美国同文的英国大致上也适用）。 ASCII 编码（本地化编码）：后来计算机发展到欧洲各国以及世界各地，开始发展到了作为第二阶段的 ANSI 编码方案阶段，各个国家和地区先后各自制定了既兼容 ASCII 但又互不兼容的 ANSI 编码方案。 UNICODE编码（国际化编码）：ANSI 编码方案阶段的各自为政，为世界各个国家和地区基于计算机的信息交流带来了极大的不便，痛定思痛之余，终于通过 Unicode / UCS 编码方案的制定发展到了第三阶段，最终 Unicode 编码方案胜出。 参考： 字符编码（三：Unicode 编码系统与字节序） Unicode编码系统可分为编码方式和实现方式两个层次编码方式： 统一码的编码方式与ISO 10646的通用字符集概念相对应。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示2^16（即65536）个字符。基本满足各种语言的使用。实际上目前版本的统一码并未完全使用这16位编码，而是保留了大量空间以作为特殊使用或将来扩展。 上述16位统一码字符构成基本多文种平面。最新（但未实际广泛使用）的统一码版本定义了16个辅助平面，两者合起来至少需要占据21位的编码空间，比3字节略少。但事实上辅助平面字符仍然占用4字节编码空间，与UCS-4保持一致。未来版本会扩充到ISO 10646-1实现级别3，即涵盖UCS-4的所有字符。UCS-4是更大而尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示231个字符，完全可以涵盖一切语言所用的符号。 基本多文种平面的字符的编码为U+hhhh，其中每个h代表一个十六进制数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。 实现方式： Unicode的实现方式不同于编码方式。一个字符的Unicode编码确定。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）。 Little endian 和 Big endian上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过0xFFFF）。以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候： 4E在前，25在后，这就是 Big endian 方式； 25在前，4E在后，这是 Little endian 方式; 这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。 第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。 那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？ Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。 如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。 参考资料字符编码笔记：ASCII，Unicode 和 UTF-8字节码：ASCII编码：单字节编码，ANSI编码：多字节编码，UNICODE编码：宽字节编码","link":"/2022/10/10/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"},{"title":"Windows服务创建和发布（NET45）","text":"创建Windows服务使用 BackgroundService 创建 Windows 服务教程：创建 Windows 服务应用 创建Windows安装程序WiX Toolsetwix3WiX 工具集教程 Wix 软件打包（一）Wix 软件打包（二）Wix 软件打包（三） Inno Setup","link":"/2022/10/11/Windows%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8F%91%E5%B8%83%EF%BC%88NET45%EF%BC%89/"},{"title":"进制转换笔记","text":"进制转换算法（Convert）在数字后面加上不同的字母来表示不同的进位制。B（Binary)表示二进制，O（Octal）表示八进制，D（Decimal）或不加表示十进制，H（Hexadecimal）表示十六进制。例如：(101011)B=(53)O=(43)D=(2B)H 十进制 → 二进制 方法：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。 例：将十进制的(43)D转换为二进制的步骤如下： 将商43除以2，商21余数为1； 将商21除以2，商10余数为1； 将商10除以2，商5余数为0； 将商5除以2，商2余数为1； 将商2除以2，商1余数为0； 将商1除以2，商0余数为1； 读数，因为最后一位是经过多次除以2才得到的，因此它是最高位，读数字从最后的余数向前读，101011，即(43)D=(101011)B。 十进制 → 十六进制 方法1：除16取余法，即每次将整数部分除以16，余数为该位权上的数，而商继续除以16，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。 例：将十进制的(796)D转换为十六进制的步骤如下： 将商796除以16，商49余数为12，对应十六进制的C； 将商49除以16，商3余数为1； 将商3除以16，商0余数为3； 读数，因为最后一位是经过多次除以16才得到的，因此它是最高位，读数字从最后的余数向前读，31C，即(796)D=(31C)H。 方法2：使用间接法，先将十进制转换成二进制，然后将二进制又转换成十六进制； 二进制 → 十进制 方法：二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。 例：将二进制的(101011)B转换为十进制的步骤如下： 第0位 1 x 2^0 = 1； 第1位 1 x 2^1 = 2； 第2位 0 x 2^2 = 0； 第3位 1 x 2^3 = 8； 第4位 0 x 2^4 = 0； 第5位 1 x 2^5 = 32； 读数，把结果值相加，1+2+0+8+0+32=43，即(101011)B=(43)D。 二进制转十六进制从后向前计算，每4位二进制数转换为一位十六进制数。 方法：取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。 例：将二进制的(11010111)B转换为十六进制的步骤如下： 0111 = 7； 1101 = D； 读数，读数从高位到低位，即(11010111)B=(D7)H。 十六进制转二进制方法：取一分四法，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。 例：将十六进制的(D7)H转换为二进制的步骤如下： D = 1101； 7 = 0111； 读数，读数从高位到低位，即(D7)H=(11010111)B。 参考八、十、十六进制转换（图解篇）","link":"/2022/10/11/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%AC%94%E8%AE%B0/"},{"title":"记录一次Http协议升级Https的经历","text":"前言准备工作获取TLS证书申请证书自签证书【这次只做了自签证书尝试】 申请证书自签证书配置TLS证书IIS配置证书优点缺点 IIS配置Https后的问题Nginx代理Https优点无需改动太多，而且方便配置TLS版本，方便兼容TLS1 、TLS1.1等过时版本。 缺点 Nginx代理后的问题","link":"/2022/10/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Http%E5%8D%8F%E8%AE%AE%E5%8D%87%E7%BA%A7Https%E7%9A%84%E7%BB%8F%E5%8E%86/"},{"title":"Node.js常识和误区笔记","text":"Node.js的底层原理https://juejin.cn/post/7008504029277847565 https://jameshfisher.com/2020/10/15/how-does-require-work-in-electron/ https://jameshfisher.com/2020/09/27/what-does-the-require-function-do-in-nodejs/ Node.js和JavaScript区别本质：Javascript是一种web前端语言，主要用于web开发中，由浏览器解析执行 Node.js是一个可以快速构建网络服务及应用的平台，是用Javascript语言构建的服务平台，可用于后端建立服务器 区别：Javascript主要应用前端 是编程语言 客户端编程语言(需要浏览器的JavaScript解释器进行解释执行) Node.js主要应用后端 1个平台 运行环境(一个基于Chrome JavaScript运行时建立的平台，它是对Google V8引擎进行了封装的运行环境) 顶层对象不同，在Ecmascript部分Node.js和Javascript其实是一样的，比如与数据类型的定义、语法结构，内置对象。但在Javascript中的顶层对象是window对象，但是在Node.js中没有什么window对象，Node.js中的顶层对象是global对象。这就是二者的差异性。 在window对象中，定义一个var a全局变量是可以通过Window来访问的(window.a)，但是在Node.js中是不能通过global.a来访问的 简单的说node.js就是把浏览器的解释器封装起来作为服务器运行平台，用类似javascript的结构语法进行编程，在node.js上运行。 链接：https://www.jianshu.com/p/21d3130ca059 http://www.inode.club/node/errors.html","link":"/2022/11/08/Node.js%E5%B8%B8%E8%AF%86%E5%92%8C%E8%AF%AF%E5%8C%BA%E7%AC%94%E8%AE%B0/"},{"title":"Prometheus+Grafana部署实践笔记","text":"参考 https://prometheus.io/docs/instrumenting/writing_exporters/https://grafana.com/docs/grafana/latest/getting-started/build-first-dashboard/https://grafana.com/docs/grafana/latest/alerting/alerting-rules/create-grafana-managed-rule/ 安装下载软件包Prometheus：https://prometheus.io/download/Grafana：https://grafana.com/grafana/download prometheus-2.41.0.windows-amd64.zipgrafana-9.3.2.windows-amd64.zip Prometheus Exporter：windows_exporter：https://github.com/prometheus-community/windows_exporterblackbox_exporter：https://github.com/prometheus/blackbox_exporter WinSW封装Config File: 配置Prometheusprometheus.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145# my global configglobal: scrape_interval: 60s # Set the scrape interval to every 15 seconds. Default is every 1 minute. evaluation_interval: 60s # Evaluate rules every 15 seconds. The default is every 1 minute. # scrape_timeout is set to the global default (10s).# Alertmanager configuration# alerting:# alertmanagers:# - static_configs:# - targets:# - alertmanager:9093# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.rule_files: # - \"first_rules.yml\" # - \"second_rules.yml\"# 一个仅包含一个要抓取的端点的抓取配置：# 这是普罗米修斯本身。scrape_configs: # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config. - job_name: \"prometheus\" # metrics_path defaults to '/metrics' # scheme defaults to 'http'. static_configs: - targets: [\"localhost:9090\"] # 79服务器节点状态监控数据 - job_name: 'ServerNodeStatus_79' static_configs: - targets: ['10.170.10.79:9182'] # 79服务器节点状态监控数据 # 78服务器节点状态监控数据 - job_name: 'ServerNodeStatus_78' static_configs: - targets: ['10.170.10.78:9182'] # 82服务器节点状态监控数据 - job_name: 'ServerNodeStatus_82[DB]' static_configs: - targets: ['10.170.10.82:9182'] # 10.170.10.78 服务器上的应用Http状态监控 - job_name: \"AppStatus_78\" metrics_path: /probe #获取指标的访问路径 params: module: [http_2xx] #使用GET http 200模块 file_sd_configs: - refresh_interval: 1m #探测目标配置文件刷新间隔，修改AppStatus*.yml后无需重启blackbox。 files: - \"D:/A_Prometheus/Probe_*_78.yml\" relabel_configs: - source_labels: [__address__] target_label: __param_target - source_labels: [__param_target] target_label: instance - target_label: __address__ replacement: 10.170.10.79:9115 #blackbox 开放地址 # 10.170.10.79 服务器上的应用Http状态监控 - job_name: \"AppStatus_79\" metrics_path: /probe #获取指标的访问路径 params: module: [http_2xx] #使用GET http 200模块 file_sd_configs: - refresh_interval: 1m #探测目标配置文件刷新间隔，修改AppStatus*.yml后无需重启blackbox。 files: - \"D:/A_Prometheus/Probe_*_79.yml\" relabel_configs: - source_labels: [__address__] target_label: __param_target - source_labels: [__param_target] target_label: instance - target_label: __address__ replacement: 10.170.10.79:9115 #blackbox 开放地址 # LIS平台接入的接口http GET状态监控 - job_name: \"ServiceStatus_LIS\" metrics_path: /probe #获取指标的访问路径 params: module: [http_2xx] #使用GET http 200模块 file_sd_configs: - refresh_interval: 1m #探测目标配置文件刷新间隔，修改AppStatus*.yml后无需重启blackbox。 files: - \"D:/A_Prometheus/Probe_ServiceStatus_LIS.yml\" relabel_configs: - source_labels: [__address__] target_label: __param_target - source_labels: [__param_target] target_label: instance - target_label: __address__ replacement: 10.170.10.79:9115 #blackbox 开放地址 # LIS平台接入的接口http POST状态监控 - job_name: \"ServiceStatus_LIS_POST\" metrics_path: /probe #获取指标的访问路径 params: module: [http_post_2xx] #使用POST http 200模块 file_sd_configs: - refresh_interval: 1m #探测目标配置文件刷新间隔，修改AppStatus*.yml后无需重启blackbox。 files: - \"D:/A_Prometheus/Probe_ServiceStatus_LIS_POST.yml\" relabel_configs: - source_labels: [__address__] target_label: __param_target - source_labels: [__param_target] target_label: instance - target_label: __address__ replacement: 10.170.10.79:9115 #blackbox 开放地址 # 采集信息的接口Http GET状态监控 - job_name: \"ServiceStatus_COLL\" metrics_path: /probe #获取指标的访问路径 params: module: [http_2xx] #使用GET http 200模块 file_sd_configs: - refresh_interval: 1m #探测目标配置文件刷新间隔，修改AppStatus*.yml后无需重启blackbox。 files: - \"D:/A_Prometheus/Probe_ServiceStatus_COLL.yml\" relabel_configs: - source_labels: [__address__] target_label: __param_target - source_labels: [__param_target] target_label: instance - target_label: __address__ replacement: 10.170.10.79:9115 #blackbox 开放地址 # 检验报告/采集信息中间库 TCP监控 - job_name: \"DBStatus_LIS\" metrics_path: /probe #获取指标的访问路径 params: module: [tcp_connect] #使用tcp_connect模块 file_sd_configs: - refresh_interval: 1m #探测目标配置文件刷新间隔，修改AppStatus*.yml后无需重启blackbox。 files: - \"D:/A_Prometheus/Probe_DBStatus_LIS.yml\" relabel_configs: - source_labels: [__address__] target_label: __param_target - source_labels: [__param_target] target_label: instance - target_label: __address__ replacement: 10.170.10.79:9115 #blackbox 开放地址 windows_exporterconfig.yml123456789101112131415161718collectors: enabled: \"[defaults],memory,iis,process\"#仅启用服务收集器collector: service: services-where: \"Name='nginx' OR Name='Redis'\" iis: site-whitelist: \"Plat|PatLis\" app-whitelist: \"Plat|PatLis\" process: whitelist: \"(dbprobe-local|afw|Enjoyor|enjoyor|PushDataWorkService|Redis|nginx).*\"log: level: warntelemetry: addr: \":9182\" path: /metrics #最大并发请求数。0禁用。 max-requests: 5 blackbox_exporterblackbox.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778modules: http_2xx: prober: http timeout: 60s http: method: GET preferred_ip_protocol: \"ip4\" no_follow_redirects: false tls_config: insecure_skip_verify: true # fail_if_ssl: false # fail_if_not_ssl: false # fail_if_body_matches_regexp: # - \"Could not connect to database\" # fail_if_body_not_matches_regexp: # - \"Download the latest version here\" # fail_if_header_matches: # 验证未设置任何 Cookie # - header: Set-Cookie # allow_missing: true # regexp: '.*' # fail_if_header_not_matches: # - header: Access-Control-Allow-Origin # regexp: '(\\*|example\\.com)' # ip_protocol_fallback: false # no fallback to \"ip6\" http_post_2xx: prober: http http: method: POST preferred_ip_protocol: \"ip4\" no_follow_redirects: false tls_config: insecure_skip_verify: true headers: Content-Type: application/json body: '{}' tcp_connect: prober: tcp pop3s_banner: prober: tcp tcp: query_response: - expect: \"^+OK\" tls: true tls_config: insecure_skip_verify: false grpc: prober: grpc grpc: tls: true preferred_ip_protocol: \"ip4\" grpc_plain: prober: grpc grpc: tls: false service: \"service1\" ssh_banner: prober: tcp tcp: query_response: - expect: \"^SSH-2.0-\" - send: \"SSH-2.0-blackbox-ssh-check\" irc_banner: prober: tcp tcp: query_response: - send: \"NICK prober\" - send: \"USER prober prober prober :prober\" - expect: \"PING :([^ ]+)\" send: \"PONG ${1}\" - expect: \"^:[^ ]+ 001\" icmp: prober: icmp icmp_ttl5: prober: icmp timeout: 5s icmp: preferred_ip_protocol: \"ip4\" ttl: 5 Probe Typeweb application : Probe_AppStatus_78.yml123- targets: #web application - https://10.170.10.78:8466 database : Probe_DBStatus_LIS.yml123- targets: #数据库地址 - 10.110.10.110:1433 webservice: Probe_ServiceStatus_COLL.yml123- targets: #webservice - http://192.168.33.99:8060/WebService/WebServce.asmx http POST WebAPI : Probe_ServiceStatus_LIS_POST.yml123- targets: # http POST WebAPI - http://192.134.24.120:8902/Interface/GetIndex Grafana配置访问协议和端口地址custom.ini1234567[server]# Protocol (http, https, h2, socket)protocol = https# The http port to usehttp_port = 7070 配置Grafana默认主题custom.ini12345# Default UI theme (\"dark\" or \"light\")default_theme = light# Default locale (supported IETF language tag, such as en-US)default_locale = zh-CN Grafana SSL ConfigGrafana Config: Custom.ini12345678#################################### Server ####################################[server]# Protocol (http, https, h2, socket)protocol = https......# https certs &amp; key filecert_file = D:\\A_Prometheus\\grafana-oss\\cert\\Grafana.crtcert_key = D:\\A_Prometheus\\grafana-oss\\cert\\Grafana.key 如果是使用自建CA根证书签署Grafana自签名证书的，需要将根证书的CRT内容合并到Grafana的CRT中。 1cat ROOTCA.crt &gt; Grafana.crt Grafana 通知模板配置Grafana 自定义中文Alert模板 Grafana面板地址：https://github.com/YuanjianZhang/Grafana_Deploy","link":"/2022/11/23/Prometheus-Grafana%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"},{"title":"认识SOAP","text":"","link":"/2022/11/25/%E8%AE%A4%E8%AF%86SOAP/"},{"title":"XML Schema初识","text":"定义","link":"/2022/11/28/XML-Schema%E5%88%9D%E8%AF%86/"},{"title":"XML Schema和DTD有什么区别","text":"https://stackoverflow.com/questions/1544200/what-is-difference-between-xml-schema-and-dtd https://stackoverflow.com/a/1544368: DTD 和 XML Schema 之间的关键区别在于 XML Schema 使用基于 XML 的语法，而DTD 具有从 SGML DTD 保留下来的独特语法。尽管 DTD 经常因为需要学习新语法而受到批评，但语法本身非常简洁。 XML Schema 的情况正好相反，它很冗长，但也使用了标记和 XML，因此 XML 的作者应该会发现 XML Schema 的语法不那么令人生畏。 https://stackoverflow.com/a/10608432: XML 架构定义 (XSD) 和文档类型定义 (DTD) 之间的差异包括： XML Schema是用 XML 编写的，而 DTD 是从 SGML 语法派生的。 XML Schema定义元素和属性的数据类型，而 DTD 不支持数据类型。 XML Schema允许支持命名空间，而 DTD 不支持。 XML Schema定义了子元素的数量和顺序，而 DTD 没有。 您可以使用 XML DOM 自行操作 XML Schema，但在 DTD 的情况下这是不可能的。 使用 XML Schema的用户不需要学习一门新语言，但使用 DTD 对用户来说却很困难。 XML Schema提供安全的数据通信，即发送方可以以接收方能够理解的方式描述数据，但&gt;在 DTD 的情况下，接收方可能会误解数据。 XML Schema是可扩展的，而 DTD 是不可扩展的。 并非所有这些要点都是 100% 准确的，但您明白了要点。 另一方面： DTD 允许您定义新的 ENTITY 值以在 XML 文件中使用。 DTD 允许您将其本地扩展到单个 XML 文件。","link":"/2022/11/28/XML-Schema%E5%92%8CDTD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"},{"title":"xml中的xsd、xsi、xmlns的含义","text":"XML是可扩展标记语言，它定义了按格式编码文件的一系列规则[3]，编码的文件是机器可读和人可读的。XML文件对于机器可读是基于XSD(XML Schema Definition)[1]的。XSD是受W3C推荐的XML文件的结构描述文件的规范文档，其中详细说明了如何正式描述XML文件中的元素[3]；也就是说，XSD是XML文件的结构描述文件（比如.xsd文件，一个XSD的实例，它是依照XSD的规范来书写的）的规范文档。编译xml的方式是跨语言的，不同语言的解析方式相同，只是具有不同的语言形式。java中解析XML的方式之一是DOM解析，他是基于jdk的lang包中DocumentBuilderFactory类的，如下所示[2]。","link":"/2022/11/28/xml%E4%B8%AD%E7%9A%84xsd%E3%80%81xsi%E3%80%81xmlns%E7%9A%84%E5%90%AB%E4%B9%89/"},{"title":"Nginx配置Basic Auth","text":"Basic Auth模块文档地址：Module ngx_http_auth_basic_module 生成加密的密码Nginx支持Basic Auth身份认证，当启用此功能时，浏览器会弹出窗口要求用户输入用户名和密码，输入正确才允许访问网页。注意：用于后台解析验证，只是使用Nginx做权限控制，密码可以不加密 在让Nginx启用Basic Auth身份认证前，首先要生成一个密码文件，格式如下： 123username1:password1username2:password2:commentusername3:password2 每一行为一条用户信息，每条用户信息包含3个字段：用户名、密码、注释，其中注释可以省略，字段间使用冒号分隔。其中第二个字段，即密码的部分并不是明文保存的，而是经过hash运算过的字符串，这样可以避免密码以明文方式呈现，对密码的hash运算可以使用openssl passwd命令生成。 注意： 只是使用Nginx做权限控制，不进行后台解析处理的，第二个字段密码可以不加密 加密的字符不适用IIS 生成示例例如要将字符串abc进行hash运算，使用的命令及输出的结果如下： 12$ openssl passwd abc5SzUqTnPPSXCY 注意：由于在hash运算时自动加入了随机的salt，因此相同的字符串每次进行hash时，产生的结果都是不一样的。 默认的算法为：Standard Unix password algorithm，此算法最多只支持对8个字符进行hash。可以选择使用其他的算法，通过openssl帮助查看可用的算法： 12345678910111213141516171819$ openssl help passwdUsage: passwd [options]Valid options are: -help Display this summary -in infile Read passwords from file -noverify Never verify when reading password from terminal -quiet No warnings -table Format output as table -reverse Switch table columns -salt val Use provided salt -stdin Read passwords from stdin -6 SHA512-based password algorithm -5 SHA256-based password algorithm -apr1 MD5-based password algorithm, Apache variant -1 MD5-based password algorithm -aixmd5 AIX MD5-based password algorithm -crypt Standard Unix password algorithm (default) -rand val Load the file(s) into the random number generator -writerand outfile Write random data to the specified file 从上述帮助信息中可以看到还可以选择SHA512、SHA256、MD5等方式进行hash。根据使用的openssl版本的不同，可用的算法也可能会不同。 下面，我们使用一个例子来说明如何用命令行批量对密码信息进行hash。 首先创建一个文件user.txt，包含3条用户信息，每行为一条信息，使用冒号作为字段分隔符，字段分别为用户名、明文密码、注释（只在第1条和第3条信息中包含），注意请不要在用户名、密码或注释中包含冒号： 1234cat user.txtuser1:abcde:commentuser2:xyz123m3ng9i:123456:mengqi.info 然后使用下面的命令生成密码文件passwd.txt： 1cut -d \":\" -f 2 user.txt | openssl passwd -6 -stdin | paste -d \":\" user.txt - | tr -d '\\r' | awk 'BEGIN{FS=\":\";OFS=\":\"}{if (NF==4) print $1,$4,$3; else if (NF==3) print $1,$3}' &gt; passwd.txt 以上命令组合了cut、openssl、paste、tr、awk5个命令，作用简单说明如下： cut: 取出user.txt的第二个字段（密码明文），将结果输出到stdout；openssl: 将stdin中输入的数据（3条密码明文）使用SHA512形式进行hash，输出到stdout；paste: 将user.txt中的原始内容与hash过的密码组合起来，输出到stdout；tr: 去除可能出现的\\r符号；awk: 从stdin中提取出用户名、hash过的密码、注释字段，将结果输出到passwd.txt。生成的密码文件内容如下，可以看到和user.txt相比，新生成的文件中，密码字段已经被hash： 1234$ cat passwd.txtuser1:$6$gjGELGyOCDsUrRtG$OcQy9GXbdpZ9Iujd1Jmzwyd5dJaXxyWUgcsiQxAOAbBj/OEQChPSD0iojfDIn3qKd82Spm5yVd3qAUmJno0KP.:commentuser2:$6$ak/BIY4C7knXMVq5$hVGDCcKaz5ExcJ2Fv9xusW6ZdqCoWQrveqrK3pWgtbUebi5CCsO4e9GbxgGfSThuVILIfJUaIBjUv7B.60nez1m3ng9i:$6$euEJqJ4PmiMdJJXC$gPLLrYkPWz.LqW50RcMA/rPzOTI9j1pWjxSlgXtHd8RJbBedpxjf.w67QnjG2m8MIxnY9G.fDCIlbDw5E2aXu.:mengqi.i Nginx 配置123456789101112server { listen 7070; server_name localhost; location / { proxy_pass http://10.170.24.114:7077/; ..... auth_basic \"Please enter your username and password\"; auth_basic_user_file htpasswd; autoindex on; }} auth_basic指令开启Nginx的Basic Auth认证功能，并设置了一个字符串，该字符串可能会显示在浏览器的密码输入提示窗口中（根据浏览器的不同，有些会显示，有些不会显示），你可以在HTTP Response header中的WWW-Authenticate字段看到这个字符串。 auth_basic_user_file指令设置了密码文件的路径 autoindex打开了目录浏览功能 重启Nginx服务后，访问localhost:7070就会要求输入用户名、密码。 备注:一定要注意auth_basic_user_file路径，如果文件不存在，会不厌其烦的出现403。 如果只想某一个页面支持Basic Auth，可以将auth_basic配置到location里： 1234location /test { auth_basic \"Please enter your username and password\"; auth_basic_user_file htpasswd; }","link":"/2022/11/30/Nginx%E9%85%8D%E7%BD%AEBasic-Auth/"},{"title":"2022第一次感染新冠记载","text":"2022-12-19 周一 早上起床就感觉头有点晕，但影响不大，只是当作起的太早。到了公司上班后，因为上周已经有同事确定感染，所以公司未开空调，并且打开了窗户；12月份的杭州+不开空调+开窗，直接导致我吹了一上午的寒风，当时整个人就感觉不对劲，头开始晕晕沉沉，当时也只是以为没有休息好导致的，加上下班后，在路边等公交又吹了几十分钟的寒风。直接导致我一回到房间，整个人开始出现各种症状，先是头晕加重，身体开始发热，两个小时内，体温从37.5升到了38.5，当时个人感觉还是很好的，只是早早的躺在了床上。 半夜开始，头痛+发热，折腾一晚上没睡着。 2022-12-20 周二 早上起来，整个人头痛欲裂，浑身发热，全身酸痛，体温是38.3，随便吃了点东西就又躺了中午起来量了下体温，39.4，赶紧吃了颗布洛芬缓释胶囊，又睡下。到了晚上，体温已经正常，爬起来吃了点东西，玩了会手机后，又吃了颗布洛芬后睡觉。 2022-12-21 周三 早上起来，整个人状态感觉恢复了很多，就是喉咙开始痛起来了，以为退烧了，一量体温还是38.4，期间起床活动，头还是会晕，还是躺了一天，中午的时候，量了下体温，38.9，又起来吃了颗布洛芬。 2022-12-22 周四 早上起来，体温还是38左右，不过没有再上过38.5，也就没再吃退烧药，开始出现其它并发症，开始咳嗽，喉咙也开始痛，喝水像吞刀片，有很明显的气喘、体力不支、心悸的后遗症。不过人也有了点力气，抗原还是两道杠。 2022-12-23 周五 体温在第四天恢复了正常，37左右，低烧，整个人也恢复了精神，基本正常了。 后遗症有： 喉咙痛 咳嗽 体力虚弱 胸闷、心悸 流涕 用脑久了会出现头晕情况","link":"/2022/12/27/2022%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%84%9F%E6%9F%93%E6%96%B0%E5%86%A0%E8%AE%B0%E8%BD%BD/"},{"title":"认识ProtoBuf","text":"参考 深入 ProtoBuf - 简介深入 ProtoBuf - 编码 初识何为 ProtoBuf我们先来看看官方文档给出的定义和描述： protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。 Protocol Buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。 你可以定义数据的结构，然后使用特殊生成的源代码轻松的在各种数据流中使用各种语言进行编写和读取结构数据。你甚至可以更新数据结构，而不破坏由旧数据结构编译的已部署程序。 简单来讲， ProtoBuf 是结构数据序列化 方法，可简单类比于 XML，其具有以下特点： 语言无关、平台无关。即 ProtoBuf 支持 Java、C++、Python 等多种语言，支持多个平台 高效。即比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单 扩展性、兼容性好。你可以更新数据结构，而不影响和破坏原有的旧程序 关于 ProtoBuf 的一些思考 官方文档以及网上很多文章提到 ProtoBuf 可类比 XML 或 JSON。 那么 ProtoBuf 是否就等同于 XML 和 JSON 呢，它们是否具有完全相同的应用场景呢？ 个人认为如果要将 ProtoBuf、XML、JSON 三者放到一起去比较，应该区分两个维度。一个是数据结构化，一个是数据序列化。这里的数据结构化主要面向开发或业务层面，数据序列化面向通信或存储层面，当然数据序列化也需要“结构”和“格式”，所以这两者之间的区别主要在于面向领域和场景不同，一般要求和侧重点也会有所不同。数据结构化侧重人类可读性甚至有时会强调语义表达能力，而数据序列化侧重效率和压缩。 总结 XML、JSON、ProtoBuf 都具有数据结构化和数据序列化的能力 XML、JSON更注重数据结构化，关注人类可读性和语义表达能力。 ProtoBuf 更注重数据序列化，关注效率、空间、速度，人类可读性差，语义表达能力不足（为保证极致的效率，会舍弃一部分元信息） ProtoBuf 的应用场景更为明确，XML、JSON 的应用场景更为丰富。","link":"/2022/12/27/%E8%AE%A4%E8%AF%86ProtoBuf/"},{"title":"IIS应用HTTP协议升级HTTPS","text":"前言应用旧访问地址：http://192.168.1.1:6622/xxxx SSL证书生成绑定证书一、IIS配置证书绑定，启用HTTPS优点：方便、快捷，删除原先端口绑定的HTTP，添加新的HTTPS协议至原端口。 缺点：如果应用程序在很多地方使用，协议升级后，原地址：http://192.168.1.1:6622 这种访问形式会失效，如果存在大量引用，会导致工作量大、难排查的问题 改进IIS配置里删除应用的旧绑定端口（6622），新增一个端口（6500）用于Nginx代理目标 tips: IIS里6500端口可以不配置证书，使用Nginx中配置的证书。通过Nginx监听原先端口，配置SSL证书文件，利用Nginx自带的497状态，将HTTP访问升级至HTTPS访问 配置文件： nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142server { listen 6622 ssl; server_name 192.168.1.1; # SSL ssl_certificate cert/DEMO.crt; ssl_certificate_key cert/DEMO.key; # 中间证书 ssl_trusted_certificate cert/RootCA.crt; error_page 497 301 =307 https://$host:6622$request_uri; location /{ proxy_pass http://$host:6500; #请求转发至新端口 proxy_redirect off; proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Ssl on; }}# 情况 服务器只开放6530 一个https的端口# nginx 通过监听6530的访问情况，使用497处理http访问异常，重定向至https的6530端口# https访问后，nginx内部代理访问内网的6529端口【实际服务所在端口】，# 再 使用proxy_redirect 修改6529传来的应答头中的\"Location\"和\"Refresh\"字段# 这样就实现了http和https的兼容，并且不需要修改其它项目中的地址。server { listen 6530 ssl; server_name localhost; # SSL ssl_certificate cert/124-221-233-39_DEMO.crt; ssl_certificate_key cert/124-221-233-39_DEMO.key; ssl_trusted_certificate cert/124-221-233-39_RootCA.crt; location /{ # proxy_ssl_server_name on; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host:$server_port;; proxy_set_header X-NginX-Proxy true; proxy_pass http://10.0.4.13:6529; proxy_redirect http://10.0.4.13:6529 /; } error_page 497 301 =307 https://$host:$server_port$request_uri;} 参考：https://stackoverflow.com/questions/16669773/nginx-reverse-proxy-to-backend-running-on-localhosthttps://blog.csdn.net/faye0412/article/details/75200607https://blog.csdn.net/jycjyc/article/details/106191981https://blog.csdn.net/qq_27745471/article/details/124735251How to redirect on the same port from http to https with nginx reverse proxynginx redirect http to https with custom port server 二、使用IIS的URL重写组件【只适用有域名的】 参考：https://aboutssl.org/iis-redirection-http-to-https/https://learn.microsoft.com/en-us/answers/questions/762252/iis-10-redirect-http-to-httpsmysitecom.htmlIIS中实现HTTPS的自动跳转URL 重写模块配置引用URL Rewrite Module 2.0 Configuration ReferenceIIS Server Variables","link":"/2022/12/28/IIS%E5%BA%94%E7%94%A8HTTP%E5%8D%8F%E8%AE%AE%E5%8D%87%E7%BA%A7HTTPS/"},{"title":"Oracle创建视图并授权","text":"Oracle 创建视图Oracle 用户创建、授权Oracle创建用户、角色、授权、建表空间Oracle创建视图(View) Sqltest.sql123456789101112131415161718192021222324252627282930313233343536373839404142434445--在CDR有创建视图权限的帐户下，创建视图test2CREATE OR REPLACE VIEW TEST2 ASSELECT HIS_PAT_PAGE from HIS_PAT_INFOWITH READ ONLY--在使用DBA或者有权限的用户帐户下执行create user VTEST identified by VTEST;--创建用户VTESTgrant create session to VTEST;--授予登录权限grant select on CDR.\"TEST2\" to VTEST;--授予VTEST用户查看CDR的TEST2视图权限grant CREATE SYNONYM to VTEST; --授权VTEST用户创建同义词权限create synonym VTEST.TEST2 for CDR.TEST2;--创建同义词 TEST2 替代CDR.TEST2--使用VTEST用户登录查询select * fromselect * from TEST2 where rownum &lt;5;--同义词select * from CDR.TEST2 where rownum &lt;5;--没有同义词，必须使用用户名前缀。--在使用DBA或者有权限的用户帐户下执行--撤销授权REVOKE CREATE SYNONYM FROM VTEST;--撤销创建同义词权限REVOKE select on CDR.\"TEST2\" FROM VTEST;--撤销TEST2视图的查看权限--删除用户drop user VTEST cascade;--使用 cascade参数可以删除该用户的全部objects【并没有删除相应的表空间】--删除视图TEST2drop view TEST2 CASCADE参数: CASCADE 使用 cascade参数可以删除该用户的全部objects。要说明的如下： 如果用户的schema中有表，则在删除表的时候自动删除与该表相关的主键和外键。 如果用户的schema中有表，则在删除表的时候自动删除与该表相关的索引。 删除用户时，用户在其他用户中的objects不会被删除，只会被置为无效。 视图，同义词，存储过程，函数，包； 其他用户建立的基于被删除用户的物化视图不会被删除，只是不能在刷新了。 用户模式下的所有触发器全部被删除 被删除用户建立的其他用户不会被删除 参考 oracle删除当前用户以及当前用户所有表、索引等操作Oracle中drop user和drop user cascade的区别 拓展笔记oracle表名不打双引号查不到原因1、oracle表和字段是有大小写的区别。oracle默认是大写，如果我们用双引号括起来的就区分大小写，如果没有，系统会自动转成大写。 2、我们在使用navicat使用可视化创建数据库时候，navicat自动给我们加上了“” Oracle 创建、查看用户 查看所有用户： 12345select * from dba_users;--描述数据库的所有用户 select * from all_users;--列出对当前用户可见的数据库的所有用户 select * from user_users;--描述当前用户。此视图不显示 PASSWORD 、 PROFILE 、 PASSWORD_VERSIONS 、 EDITIONS_ENABLED 、 AUTHENTICATION_TYPE 和 LAST_LOGIN 列。 查看用户或角色系统权限(直接赋值给用户或角色的系统权限)： 123select * from dba_sys_privs;--描述授予用户和角色的系统权限 select * from user_sys_privs;-- (查看当前用户所拥有的权限) 查看角色(只能查看登陆用户拥有的角色)所包含的权限 12select * from role_sys_privs; 查看用户对象权限： 12345select * from dba_tab_privs; select * from all_tab_privs; select * from user_tab_privs; 查看所有角色： 1select * from dba_roles; 查看用户或角色所拥有的角色： 123select * from dba_role_privs; select * from user_role_privs; 查看哪些用户有sysdba或sysoper系统权限(查询时需要相应权限) 1select * from V$PWFILE_USERS SqlPlus中查看一个用户所拥有权限 1234select * from dba_sys_privs where grantee='username'; --其中的username即用户名要大写才行。--比如： select * from dba_sys_privs where grantee='TOM'; REVOKE回收权限 回收角色权限 1REVOKE CONNECT,RESOURCE FROM chenmh; 回收系统权限 1REVOKE CREATE FROM chenmh; 回收用户对象权限,回收zhang用户下person表的所有权限，如果是单个授予的权限需要单个的收回 1REVOKE ALL PRIVILEGES ON zhang.person FROM chenmh;","link":"/2022/12/28/Oracle%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE%E5%B9%B6%E6%8E%88%E6%9D%83/"},{"title":"Shell笔记","text":"获取入参方式一：$0,$1,$2..采用$0,$1,$2..等方式获取脚本命令行传入的参数，值得注意的是，$0获取到的是脚本路径以及脚本名，后面按顺序获取参数，当参数超过10个时(包括10个)，需要使用${10},${11}….才能获取到参数，但是一般很少会超过10个参数的情况。 test.sh1234567#!/bin/bashecho \"脚本$0\"echo \"第一个参数$1\"echo \"第二个参数$2\"……echo \"第十个参数$10\"echo \"第十个参数${10}\" 在shell中执行脚本，结果如下 123456789101112131415$&gt;./test.sh a b c d e f g h i j#shell中将会输出：脚本名./test.sh第一个参数a第二个参数b第三个参数c第四个参数d第五个参数e第六个参数f第七个参数g第八个参数h第九个参数i第十个参数a0第十个参数j 可以看到${10}正确读取到了第十个参数，而$10被分成$1读取到第一个参数a然后拼接字符串0，于是输出a0。 优点：获取参数更容易，执行脚本时需要的输入少 缺点：必须按照顺序输入参数，如果中间漏写则参数对应就会错误 方式二：getopts语法格式：getopts [option[:]] [DESCPRITION] VARIABLEoption：表示为某个脚本可以使用的选项“:”：如果某个选项（option）后面出现了冒号（”:”），则表示这个选项后面可以接参数（即一段描述信息DESCPRITION）VARIABLE：表示将某个选项保存在变量VARIABLE中 test.sh1234567891011121314151617while getopts \":a:b:c:\" optdo case $opt in a) echo \"参数a的值$OPTARG\" ;; b) echo \"参数b的值$OPTARG\" ;; c) echo \"参数c的值$OPTARG\" ;; ?) echo \"未知参数\" exit 1;; esacdone 用一个while循环加case分支获取不同参数，:a:b:c相当于定义参数的变量名，有时候可能会有未知参数，所以增加一个?的分支。 在shell中执行脚本，结果如下 1234567891011121314151617$&gt;./test.sh -a 1 -b 2 -c 3#在shell中的输出参数a的值1参数b的值2参数c的值3$&gt;./test.sh -a 1 -c 3#在shell中的输出参数a的值1参数c的值3$&gt;./test.sh -a 1 -c 3 -d 4#在shell中的输出参数a的值1参数c的值3未知参数 优点：由于使用了-a加参数值的方式进行一一匹配，所以不会参数匹配错误，同时也可以缺省参数，并不会导致参数错误，同时也便于后期参数的扩展和移植 缺点：脚本执行时参数需要的输入会增多 字符串变量截取、替换和删除获取变量字符串长度想要知道\"www.baidu.com\"的变量net的长度十分简单，通过$","link":"/2022/12/28/Shell%E7%AC%94%E8%AE%B0/"},{"title":"TLS1.2和TLS1.1的区别","text":"参考 TLS/SSL 协议详解 (28) TLS 1.0、TLS 1.1、TLS 1.2之间的区别 区别点1：对finished报文（Encrypted handshake message）影响TLS 1.0 TLS 1.1 在计算finish时，进行的是MD5+ SHA1组合方式运算，而在TLS 1.2下，摘要算法变成了单次SHA256。 伪代码如下 12345678910111213141516171819If(version &gt;= TLS1_2){ If (cipher.mac == SHA384) { restult = SHA384(handshake_in ); } Else { restult = SHA256(handshake_in); }}Else{ restult = md5(handshake_in) + sha1(handshake_in);} 其中handshake_in是 字符串常量+所有握手信息（类型为Handshake的message）。 例如 作为client端handshake_in =“client finidhed” + all_handshake作为Server 端handshake_in = “server finidhed” + all_handshake 注：对于加密套件存在SHA384及其以上的高级摘要算法，无论TLS哪个版本，都用 加密套件指定的 握手摘要算法计算 摘要，如上伪代码所示（RFC上说对于每一种新的算法， 都需要指定default还是SHAXXX，但是在实现上，都是根据MAC是什么，SHAXXX就是什么）。 其实加密套件中指定的摘要算法是用来在加密时进行HMAC的，并不影响握手流程中的运算，但是如果两端协商的加密套件支持SHAXXX，那么必然表示两端支持SHAXXX算法，那么在SHAXXX安全性高于SHA256的情况下，握手阶段需要摘要算法就没必要那么‘死’只用SHA256。当然目前也没有比SHA384更高的了。 总结来说： 1：TLS 1.2需要增加2个字节表明签名算法类型（非对称+摘要）。而TLS1.2之前的协议默认就用md5+sha1的形式计算摘要，非对称算法肯定使用私钥类型对应的算法，这个无需显示表明。 2：ECDSA签名需要特殊对待。 2：对PRF算法的影响先用伪代码梳理逻辑： 123456789101112131415If(version &gt;= TLS1_2){ If (cipher.mac == SHA384) { TLS1_2_PRF(SHA384, in, srcret); } Else { TLS1_2_PRF(SHA256, in, srcret); }}Else{ TLS1_PRF(MD5,SHA1, in, srcret);} 1：对于SHA384的判断，上面已经说过，这里不再赘述。2：可以看到TLS1.2和TLS 1.0 TLS 1.1的PRF实现也不同，参数不同。 TLS 1.2 的PRF单次P_HASH，P_HASH使用的是SHA256 TLS 1.1 的PRF两次P_HASH，第一次P_HASH使用的是MD5，以及secret的前半部分；第二次P_HASH使用的SHA1，以及secret的后半部分。两次P_HASH的结果进行亦或（xor），得到最后结果。 注意secret如果是偶数，则正好各一半，如果是奇数： 例如secret是1234567，则前一半 指的是1234，后一半指的是4567，中间一个字节公用。 3：对Certificate verify的影响Certificate vertify是客户端在发送证书后，为了表明自己是证书的拥有者，用自己的私钥对之前收到、发送的握手信息进行签名。（和finished类似）。 同样签名前，需要对握手信息进行HASH运算。 TLS1.0 TLS1.1： 使用MD5+SHA1的形式对握手信息进行摘要运算，这个流程和计算finished一样，只是不加字符串常量’XXX finished’。 注：有一个例外，对于ECDSA签名算法（客户端证书是ECC证书），只做单次SHA1计算。 TLS 1.2： TLS 1.2 下， certificate verify报文格式和之前的不同，多出2个字节（Signature Hash Algorithm），表示hash_alg以及sign_alg。具体握手摘要根据hash_alg进行单次计算。 同样，如果加密套件存在SHA384，则使用SHA384 4：对server key exchange的影响TLS1.2下和 certificate verify类似，报文格式较之前版本有不同。多了2个字节表示HASH算法和签名算法。 5：对加密的影响这个变化是TLS1.1开始变化的，不是TLS1.2。 为了对抗beast攻击，SSL在加密数据前，需要填充一个BLOCK_SIZE（IV_SIZE）长度的随机数，这个随机值也被作为数据的一部分进行加密，在解密时，同样进行解密，然后丢弃。 CBC下，对于上述这个场景我们其实可以进行优化，这个BLOCK_SIZE的数据对于发送端来说可以不进行加密，然后下一个数据块的Write_IV改成这个随机数，这样CBC模式就可以完整的工作。对于解密方来说，这个BLOCK_SIZE的数据可以不解密，然后解密下一个块时的Read_IV变成这个随机数，CBC模式也能正常工作。减少了一个BLOCK_SIZE的解密、加密数据。详细优化方案见我的博客 http://blog.csdn.net/mrpre/article/details/78093370","link":"/2022/12/28/TLS1-2%E5%92%8CTLS1-1%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"Windows+OpenSSL创建自签名证书脚本","text":"前言如果您想经常创建自签名证书，可以使用以下 shell 脚本。您只需要使用要添加到证书的域名或 IP 执行脚本。 将以下 shell 脚本另存为ssl.sh 准备工作 Git For Windows Git Bash 脚本ssl.sh脚本ssl.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#! /bin/bash# 自签证书【IP版】# Grafana# ./test.sh -co \"SOYBEAN\" -cou \"SOYBEAN\" -ccn \"192.168.1.1\" -cdomain \"192.168.1.1\" -so \"SOYBEAN\" -sou \"192.168.1.2\" -scn \"Grafana\" -sdomain \"192.168.1.2\"if [ -s \"$PWD/m_msg.sh\" ]; then source \"$PWD/m_msg.sh\"fiif [ -s \"$PWD/common.sh\" ]; then source \"$PWD/common.sh\"fi# 固定参数【按需修改】_C_C=\"CN\"_C_ST=\"ZJ\"_C_L=\"HZ\"_S_C=\"CN\"_S_ST=\"ZJ\"_S_L=\"HZ\"_S_Days=3650# 参数# Root CA# 根CA 所在 IP/域名_C_DOMAIN=# CA组织、单位名称_C_O=_C_OU=# Common Name_C_CN=# 签发证书序列号_C_SRL=\"rootCA.SRL\"# Server_S_O=_S_OU=# 服务的 Common Name_S_CN=_S_DOMAIN=# openssl_dhparamFlag=# 参数获取# Setup getopt.long_opts=\"co:,cou:,ccn:,cdomain:,so:,sou:,scn:,sdomain:,dhparam\"getopt_cmd=$(getopt -a -o : --l \"$long_opts\" \\ -- \"$@\") || { echo -e \"\\nERROR: Getopt failed. Extra args\\n\" exit 1 }eval set -- \"$getopt_cmd\"while true; do case \"$1\" in --co) _C_O=\"$2\" shift ;; --cou) _C_OU=\"$2\" shift ;; --ccn) _C_CN=\"$2\" shift ;; --cdomain) _C_DOMAIN=\"$2\" shift ;; --so) _S_O=\"$2\" shift ;; --sou) _S_OU=\"$2\" shift ;; --scn) _S_CN=\"$2\" shift ;; --sdomain) _S_DOMAIN=\"$2\" shift ;; --dhparam) _dhparamFlag=\"1\" ;; --) shift break ;; esac shiftdoneif [ ${#_C_DOMAIN} -lt 1 ]; then printERROR \"错误：未提供【C_DOMAIN】参数！\" exit 1elif [ ${#_C_O} -lt 1 ]; then printERROR \"错误：未提供【C_O】参数！\" exit 1elif [ ${#_C_OU} -lt 1 ]; then printERROR \"错误：未提供【C_OU】参数！\" exit 1elif [ ${#_C_CN} -lt 1 ]; then printERROR \"错误：未提供【C_CN】参数！\" exit 1elif [ ${#_S_O} -lt 1 ]; then printERROR \"错误：未提供【S_O】参数！\" exit 1elif [ ${#_S_OU} -lt 1 ]; then printERROR \"错误：未提供【S_OU】参数！\" exit 1elif [ ${#_S_CN} -lt 1 ]; then printERROR \"错误：未提供【S_CN】参数！\"elif [ ${#_S_DOMAIN} -lt 1 ]; then printERROR \"错误：未提供【S_DOMAIN】参数！\"fi# 根CA 所在 IP/域名 格式化【处理特殊符号】替换\".\"为\"-\"_C_DOMAINFORMAT=$(getFormaterStr \"$_C_DOMAIN\");# 根CA 私钥、证书文件名称_C_FileName=\"${_C_DOMAINFORMAT}_RootCA\"# 根CA 输出文件夹路径【默认为_C_DOMAINFORMAT】_FilePath=\"./${_C_DOMAINFORMAT}\"# 根 CA 证书、私钥路径【默认目录为根据_FilePath】_CAKey=\"${_C_FileName}.key\"_CACrt=\"${_C_FileName}.crt\"# 脚本工作目录work_path=$(dirname \"$(readlink -f \"$0\")\")printINFO \"脚本工作目录:$work_path\"# 这里的-x 参数判断 $FilePath 是否存在并且是否具有可执行权限,不存在创建目录,存在输出路径；if [ ! -x \"$_FilePath\" ]; then mkdir \"$_FilePath\" &amp;&amp; cd \"$_\" &amp;&amp; printINFO \"文件输出目录：$PWD\"else cd \"$_FilePath\" &amp;&amp; printINFO \"文件输出目录：$PWD\"fi# Server 证书序列号,默认1【十进制】SERIAL_NUM=$(getSerialNum) ; printINFO \"Server 证书序列号：$SERIAL_NUM\"# Server 私钥、证书文件名称# 生成文件名称格式为：$_C_DOMAINFORMAT_$_S_CN_S_FileName=\"${_C_DOMAINFORMAT}_\"$(getFormaterStr \"$_S_CN\");#当前命令行所在路径是否存在根 CA 证书和私钥FileFLAG=\"true\"if [ ! -s \"$_CAKey\" ]; then printERROR \"根 CA 私钥 ${_CAKey} 不存在\";FileFLAG=\"false\"elif [ ! -s \"$_CACrt\" ]; then printERROR \"根 CA 证书 ${_CACrt} 不存在\";FileFLAG=\"false\"else FileFLAG=\"true\"fiif [ $FileFLAG = \"true\" ]; then printOK \"文件已存在，使用下列文件创建SSL证书：根CA证书：${_CAKey}，根CA私钥：${_CACrt} \"else printINFO \"创建根 CA 证书和 CA 私钥 \" # 创建根 CA 证书和 CA 私钥【-nodes:无密码】 openssl req -x509 \\ -sha256 -days 3560 \\ -nodes \\ -newkey rsa:2048 \\ -subj \"//C=${_C_C}/C=${_C_C}/ST=${_C_ST}/L=${_C_L}/O=${_C_O}/OU=${_C_OU}/CN=${_C_CN}\" \\ -keyout \"${_C_FileName}\".key -out \"${_C_FileName}\".crtfiprintOK \"生成 Server 私钥 ： ${_S_FileName}.key\"# 生成 Server 私钥openssl genrsa -out \"${_S_FileName}\".key 2048printOK \"创建 csr 配置： csr.conf \"# 创建 csr 配置cat &gt;csr.conf &lt;&lt;EOF[ req ]default_bits = 2048prompt = nodefault_md = sha256req_extensions = req_extdistinguished_name = dn[ dn ]C = $_S_CST = $_S_STL = $_S_LO = $_S_OOU = $_S_OUCN = $_S_CN[ req_ext ]subjectAltName = @alt_names[ alt_names ]#DNS.1 = ${_S_DOMAIN}IP.1 = ${_S_DOMAIN}EOFprintOK \"使用 Server 私钥创建 CSR 请求\"# 使用Server 私钥创建 CSR 请求openssl req -new -key \"${_S_FileName}\".key -config csr.conf -out \"${_S_FileName}\".csrprintOK \"为 Server CSR 请求创建一个外部配置文件：cert.conf\"# 为 Server CSR 请求创建一个外部配置文件cat &gt;cert.conf &lt;&lt;EOFauthorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentsubjectAltName = @alt_names[alt_names]#DNS.1 = ${_S_DOMAIN}IP.1 = ${_S_DOMAIN}EOFprintOK \"使用自签名 CA ${_CACrt} 创建 SSl证书 ：${_S_FileName}.crt\"# 使用自签名 CA 创建 SSl证书openssl x509 -req \\ -in \"${_S_FileName}\".csr \\ -CA \"${_C_FileName}\".crt -CAkey \"${_C_FileName}\".key \\ -days \"${_S_Days}\" \\ -sha256 -extfile cert.conf \\ -CAcreateserial \\ -set_serial \"${SERIAL_NUM}\" \\ -out \"${_S_FileName}\".crtprintOK \"合成 pkcs#12 证书\"# 转换证书编码格式# 合成 pkcs#12 证书(含私钥和CA 证书)openssl pkcs12 -export -name \"${_S_CN}\" -caname \"${_C_CN}\" \\ -in \"${_S_FileName}\".crt \\ -inkey \"${_S_FileName}\".key \\ -nodes \\ -password pass: \\ -chain \\ -CAfile \"${_C_FileName}\".crt \\ -out \"${_S_FileName}\".pfxif [ $_dhparamFlag ]then openssl dhparam 2048 -check -out dhparam.pem ; printOK \"已生成dhparam.pem ! \"fiprintSUCCESS \"CA 证书内容：\"openssl x509 -in \"${_C_FileName}\".crt -noout -textprintSUCCESS \"SSl证书内容：\"openssl x509 -in \"${_S_FileName}\".crt -noout -textprintSUCCESS \"CRT证书链 合成\"cat \"${_S_FileName}\".crt \"${_C_FileName}\".crt &gt; \"${_S_FileName}_ALL\".crtprintSUCCESS \"CRT证书链 合成内容：\"openssl x509 -in \"${_S_FileName}_ALL\".crt -noout -text m_msg.sh脚本m_msg.sh12345678910111213141516171819202122#! /bin/bash# echo 颜色样式OK=\"\\033[42;37m \"# OK=\"\\033[32m \"SUCCESS=\"\\033[42;37m \"INFO=\"\\033[34m \"ERROR=\"\\033[41;30m \"RESET=\"\\033[0m \"printOK() { echo -e \"${OK}==== $* ====${RESET}\"}printSUCCESS() { echo -e \"${SUCCESS}==== $* ====${RESET}\"}printINFO() { echo -e \"${INFO}==== $* ====${RESET}\"}printERROR() { echo -e \"${ERROR}==== $* ====${RESET}\"} common.sh脚本common.sh12345678910111213141516171819202122232425262728293031323334353637#! /bin/bash# 方法# dec to hexdec2hex() { printf \"%x\" \"$1\"}# rootCA.SRL获取证书序列号【十进制数】，并更新数值# 根据文件中的数值返回对应的十六进制值# 文件不存在或无值，默认返回 0x1getSerialNum() { if [ ! -s \"rootCA.SRL\" ]; then cat &gt;rootCA.SRL &lt;&lt;EOF1EOF else num=$(&lt;rootCA.SRL) &amp;&amp; cat &gt;rootCA.SRL &lt;&lt;EOF$((num + 1))EOF fi #十进制转十六进制 strserialnum=$(&lt;rootCA.SRL) printf \"%s\"\"$(dec2hex \"$strserialnum\")\"}getFormaterStr() { para=$1 for char in \".\" \":\" \"\\\\\" \"*\" \"?\"; do para=${para//\"$char\"/-} done echo \"$para\"} ssl.sh 脚本的使用1./ssl.sh -co \"SOYBEAN\" -cou \"SOYBEAN\" -ccn \"192.168.1.1\" -cdomain \"192.168.1.1\" -so \"SOYBEAN\" -sou \"192.168.1.2\" -scn \"Grafana\" -sdomain \"192.168.1.2\" 该脚本将创建我们使用各个命令创建的所有证书和密钥。 SSL 证书和私钥使用您作为脚本参数传递的IP命名。 Sign.sh脚本【按需修改脚本内容，执行脚本生成证书，可生成V1版本证书，用于兼容特殊环境。】下列脚本生成了CA根证书 以及CAS服务证书： Tips:通过-extfile x509.ext -extensions ca该参数，可以控制生成的证书是否添加证书拓展属性，该参数行默认添加，可以自行移除，移除后生成的证书为V1版本，无拓展属性。 sign.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#! /bin/bash# V1证书 移除此参数：-extfile x509.ext -extensions ca # https://www.openssl.org/docs/man3.0/man1/openssl-x509.html#-extfile # https://***/openssl-x509.html#-reqcat &gt;x509.ext &lt;&lt;EOF[ ca ]# X509 extensions for a cakeyUsage = critical, cRLSign, keyCertSignbasicConstraints = CA:TRUE, pathlen:0subjectKeyIdentifier = hashauthorityKeyIdentifier = keyid:always,issuer:always[ server ]# X509 extensions for a serverkeyUsage = critical,digitalSignature,keyEnciphermentextendedKeyUsage = serverAuth,clientAuthbasicConstraints = critical,CA:FALSEsubjectKeyIdentifier = hashauthorityKeyIdentifier = keyid,issuer:alwaysEOF# CA 根证书openssl req -new -sha256 -nodes -newkey rsa:2048 \\-subj \"//C=CN/C=CN/ST=ZJ/L=HZ/O=SOYBEAN/OU=SOYBEAN/CN=SOYBEANCA\" \\-keyout CA.key \\-out CA.csr \\openssl x509 -req -sha256 -days 3650 \\-extfile x509.ext -extensions ca \\-in CA.csr \\-signkey CA.key \\-out CA.pem# CASopenssl req -new -sha256 -nodes \\-newkey rsa:2048 \\-subj \"//C=CN/C=CN/ST=ZJ/L=HZ/O=SOYBEAN/OU=SOYBEAN/CN=CASSERVER\" \\-keyout CAS.key \\-out CAS.csr \\openssl x509 -req -sha256 \\-CA CA.pem -CAkey CA.key \\-days 3650 -CAcreateserial -CAserial CA.srl \\-extfile x509.ext -extensions server \\-in CAS.csr \\-out CAS.pemopenssl pkcs12 -export -nodes -password pass: \\-name \"CAS\" \\-caname \"SOYBEANCA\" \\-in CAS.pem -inkey CAS.key \\-chain -CAfile CA.pem \\-out CAS.pfx 笔记使用自签名证书有什么好处？使用自签名证书有几个好处： 您无需依赖第三方来签署您的证书。 您可以创建和使用自己的证书颁发机构。 您不必为 CA 的证书付费。 您可以更好地控制您的证书。 使用自签名证书有什么缺点？使用自签名证书也有几个缺点： 您的用户需要在他们的浏览器或应用程序中安装证书。 您的用户将需要手动信任您的证书颁发机构。 它们对于面向公众的应用程序不安全。 除非用户安装它们，否则所有浏览器或操作系统都不信任自签名证书。 容易受到中间人攻击。 通常，对于需要证明自己身份的应用程序，自签名证书是一个不错的选择。它们也是开发和测试环境的不错选择。但是，它们不应该用于生产应用程序。 组织中的自签名证书许多组织对其不面向 Internet 的内部应用程序使用自签名证书。这些证书是使用组织的内部 PKI 基础结构生成的。 CRT、CER、PEM.CRT = CRT扩展用于证书。证书可以被编码为二进制DER或ASCII PEM CER和CRT扩展几乎是同义词，最常见的于Unix 或类Unix系统。 CER = .crt的替代形式（Microsoft Convention）。 可以用微软的工具把CRT文件转换为CER文件（CRT和CER必须是相同编码的，DER或者PEM）。 扩展名为CER的文件可以被IE识别并作为命令调用微软的cryptoAPI（具体点就是rudll32.exe cryptext.dll, CyrptExtOpenCER），进而弹出一个对话框来导入并/或查看证书内容。 查看证书细节1openssl x509 -in SOYBEAN.crt -noout -text 转换证书编码格式.cer、crt 与 pem、pfx .cer/.crt是用于存放证书，它是2进制形式存放的，不含私钥，含公钥 .pem跟.crt/.cer的区别是它以Ascii码来表示（字符串） .pfx/.p12用于存放个人证书/私钥，它通常包含保护密码，2进制方式 注:node服务器需要的是.pem格式的私钥与证书，iOS中需要的是.cer二进制格式的证书。 12345678# .crt 转 .pemopenssl x509 -in SOYBEAN.crt -inform PEM -outform PEM -out SOYBEAN.pem# .cer 转 .pem# openssl x509 -in SOYBEAN.cer -inform PEM -outform PEM -out SOYBEAN.pem# 合成 pkcs#12 证书(含私钥)openssl pkcs12 -export -in SOYBEAN.crt -inkey SOYBEAN.key -name SOYBEANAPP -passout pass: -out SOYBEAN.pfx# 合成 pkcs#12 证书(含私钥和CA 证书)openssl pkcs12 -export -name SOYBEANAPP -caname CAServer -in SOYBEAN.crt -inkey SOYBEAN.key -nodes -password pass: -chain -CAfile ca.crt -out server-all.pfx -subj项在Windows的git Bash 里报错 修改MSYS_NO_PATHCONV环境变量为1 将第一个/变成//，并将第一个参数重复；看起来像：-subj \"/C=CN/ST=ZJ/L=HZ/O=SOYBEAN/OU=SOYBEANDEPT/CN=CASERVER\"==&gt;-subj \"//C=CN/C=CN/ST=ZJ/L=HZ/O=SOYBEAN/OU=SOYBEANDEPT/CN=CASERVER\" Unable to use -subj with Windows Git Bash 12345openssl genrsa -out ca.key 2048openssl req -new -x509 -days 3650 -key ca.key -out ca.crt -subj \"//C=CN/C=CN/ST=ZJ/L=HZ/O=SOYBEAN/OU=SOYBEANDEPT/CN=CASERVER\"openssl genrsa -out server.key 2048openssl req -new -key server.key -out server.csr -subj \"//C=CN/C=CN/ST=ZJ/L=HZ/O=SOYBEAN/OU=SOYBEANDEPT/CN=192.168.1.1\"openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt 输出为pfx文件生成pfx文件无响应，原来是少了个参数：-passout pass:SomePassword；即使密码为空也需要这个参数。 OpenSSL hangs during PKCS12 export with “Loading ‘screen’ into random state” 1openssl pkcs12 -export -in server.crt -inkey server.key -name server -passout pass: -out server.pfx 参考 https://www.jianshu.com/p/e5f46dcf4664https://ningyu1.github.io/site/post/51-ssl-cert/https://www.cnblogs.com/junjiany/p/6273560.htmlhttps://www.cnblogs.com/f-ck-need-u/p/7113610.htmlhttps://blog.miniasp.com/post/2022/06/14/How-to-request-new-tls-certificate-using-OpenSSL","link":"/2022/12/28/Windows-OpenSSL%E5%88%9B%E5%BB%BA%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E8%84%9A%E6%9C%AC/"},{"title":"Windows创建自定义根证书、自签名服务证书【一】","text":"Windows创建自定义根证书、自签名服务证书【一】参考文章 https://devopscube.com/create-self-signed-certificates-openssl 环境 Windows 21H2 Git For Windows Git Bash 起步创建自签根证书我们需要为浏览器创建自己的根 CA 证书以信任自签名证书。因此，让我们首先创建根 CA 证书。 让我们创建一个名为 openssl 的目录来保存所有生成的密钥和证书。 1mkdir openssl &amp;&amp; cd openssl 执行以下openssl命令来创建rootCA.key 和 rootCA.crt。替换SOYBEANCA为您的域名或 IP 地址，这里用SOYBEAN作为单位和组织名称。 1openssl req -new -x509 -days 3650 -nodes -subj \"//C=CN/C=CN/ST=ZJ/L=HZ/O=SOYBEAN/OU=SOYBEAN/CN=SOYBEANCA\" -keyout rootCA.key -out rootCA.crt 创建自签名服务证书请按照以下步骤创建自签名证书。我们将使用我们在上一步中创建的根 CA 注销证书。 创建自签名服务私钥1openssl genrsa -out lis.key 2048 创建”证书签名请求”配置文件 证书签名请求英文名：Certificate signing request 我们将创建一个 lis_csr.conf 文件以包含生成 CSR 的所有信息。将 alt_names节点中的值替换为您的域名或 IP 地址。 lis_csr.conf123456789101112131415161718192021[ req ]default_bits = 2048prompt = nodefault_md = sha256req_extensions = req_extdistinguished_name = dn[ dn ]C = CNST = ZJL = HZO = SOYBEANOU = SOYBEANCN = 192.168.1.1[ req_ext ]subjectAltName = @alt_names[ alt_names ]IP.1 = 192.168.1.1#DNS.1 = site.com 使用自签名服务私钥生成证书签名请求 (CSR)1openssl req -new -key lis.key -out lis.csr -config lis_csr.conf 现在我们的文件夹应该有三个文件。lis_csr.conf,lis.csr和lis.key 创建自签名服务证书拓展属性配置文件为 SSL 证书创建lis_cert.conf。将 alt_names节点中的值替换为您的域名或 IP 地址。 lis_cert.conf12345678authorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentsubjectAltName = @alt_names[alt_names]IP.1 = 192.168.1.1#DNS.1 = site.com 使用自签名根证书 生成 自签名服务证书现在，执行以下命令来生成以rootCA.crt 和 rootCA.key为证书颁发机构，创建自签名证书：lis.crt。 1openssl x509 -req -days 3650 -CAcreateserial -set_serial 01 -CA rootCA.crt -extfile lis_cert.conf -CAkey rootCA.key -in lis.csr -out lis.crt 上面的命令将生成 lis.crt ，它将与我们的 lis.key 一起使用，以在应用程序中启用 SSL。 tips：-CAcreateserial使用后，需要添加-set_serial 01以避免一些问题的发生。如果不指定serial值，会在输出目录生成一个SRL文件，是openssl跟踪可用于新证书的最新序列号的文件，关于SRL文件的问题，见：https://stackoverflow.com/a/66357989。 结束执行上述流程后，应该会拥有4个文件：rootCA.crt、rootCA.key、lis.crt、lis.key。","link":"/2022/12/28/Windows%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B9%E8%AF%81%E4%B9%A6%E3%80%81%E8%87%AA%E7%AD%BE%E5%90%8D%E6%9C%8D%E5%8A%A1%E8%AF%81%E4%B9%A6%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"认识加密算法","text":"加密算法对称加密就是将信息使用一个密钥进行加密，解密时使用同样的密钥，同样的算法进行解密。 非对称加密又称公开密钥加密，是加密和解密使用不同密钥的算法，广泛用于信息传输中。 在现实世界上可作比拟的例子是: 一个传统保管箱，开门和关门都是使用同一条钥匙，这是对称加密； 而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有信箱主人拥有钥匙可以打开信箱，这就视为私钥。 对称加密对称密钥算法（英语：Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。事实上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通信联系。 与公开密钥加密相比，要求双方获取相同的密钥是对称密钥加密的主要缺点之一。 对称加密的速度比公钥加密快很多，在很多场合都需要对称加密。 常见的对称加密算法有AES、ChaCha20、3DES、Salsa20、DES、Blowfish、IDEA、RC5、RC6、Camellia。 非对称加密公开密钥密码学（英语：Public-key cryptography）也称非对称式密码学（英语：Asymmetric cryptography）是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。公钥可以公开，可任意向外发布；私钥不可以公开，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。 基于公开密钥加密的特性，它还能提供数字签名的功能，使电子文件可以得到如同在纸本文件上亲笔签署的效果。 公开密钥基础建设透过信任数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在TLS实现并在万维网的HTTP以HTTPS、在电子邮件的SMTP以SMTPS或STARTTLS引入。 另一方面，信任网络则采用去中心化的概念，取代了依赖数字证书认证机构的公钥基础设施，因为每一张电子证书在信任链中最终只由一个根证书授权信任，信任网络的公钥则可以累积多个用户的信任。PGP就是其中一个例子。 与对称密码学的比较 对称密码是指在加密和解密时使用同一个密钥的方式公钥密码是指在加密和解密时使用不同密钥的方式 对称密钥加密牵涉到密钥管理的问题，尤其是密钥交换，它需要通信双方在通信之前先透过另一个安全的渠道交换共享的密钥，才可以安全地把密文透过不安全的渠道发送；对称密钥一旦被窃，其所作的加密将即时失效；而在互联网，如果通信双方分隔异地而素未谋面，则对称加密事先所需要的“安全渠道”变得不可行；非对称加密则容许加密公钥随便散布，解密的私钥不发往任何用户，只在单方保管；如此，即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，极为适合在互联网上使用。 另一方面，公钥解密的特性可以形成数字签名，使数据和文件受到保护并可信赖；如果公钥透过数字证书认证机构签授成为电子证书，更可作为数字身份的认证，这都是对称密钥加密无法实现的。 不过，公钥加密在在计算上相当复杂，性能欠佳、远远不比对称加密；因此，在一般实际情况下，往往通过公钥加密来随机创建临时的对称秘钥，亦即对话键，然后才通过对称加密来传输大量、主体的数据。","link":"/2022/12/28/%E8%AE%A4%E8%AF%86%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"title":"Lambda表达式常见用法笔记","text":"参考 Lamda 表达式里的Join和GroupJoin的区别, 如何实现SQL的Left Join效果 用法 基础数据 12345public class User{ public string Name{get;set;} public string ID{get;set;} public string } Group by 1","link":"/2023/01/05/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"title":"sqlserver数据库dump文件分析","text":"sqlserver数据库dump文件分析","link":"/2023/01/05/sqlserver%E6%95%B0%E6%8D%AE%E5%BA%93dump%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"},{"title":"初始PWA【一】","text":"https://juejin.cn/post/7147267313920638983","link":"/2023/01/10/%E5%88%9D%E5%A7%8BPWA%E3%80%90%E4%B8%80%E3%80%91/"},{"title":"Windows工具记录","text":"文件传输 名称 描述 地址 FileZilla 免费、开源的FTP客户端 https://filezilla-project.org/download.php","link":"/2023/01/16/Windows%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"},{"title":"LSP初识以及gopls是什么","text":"要谈 gopls，得先聊聊 LSP。 LSP 是什么LSP，全称 Language Server Protocol，即语言服务器协议，这是微软创建的一个协议（目前已有 Codenvy，Red Hat 和 Sourcegraph 等公司一起支持它的发展）。定义了在编辑器或 IDE 中与语言服务器之间使用的协议，该语言服务器提供诸如自动完成，转到定义，查找所有引用等语言功能。语言服务器索引格式（LSIF，其发音类似于“ else if”）的目标是支持开发工具或 Web UI 中的富代码导航，而不需要源代码的本地副本。 目前该协议得到了编辑器和语言社区的广泛支持。 LSP 的官方网站：https://microsoft.github.io/language-server-protocol/，GitHub 地址：https://github.com/Microsoft/language-server-protocol。目前最新版本（2020-09-06）：3.15。 LSP 解决了什么问题为编程语言添加诸如自动完成、转到定义或鼠标悬停出现文档之类的功能需要付出大量的努力。传统上，这项工作必须为每个开发工具重复进行，因为每个工具为实现相同的特性提供不同的 api。 语言服务器（Language Server）旨在提供特定语言的智能功能，并通过支持进程间通讯协议与开发工具进行通信。 语言服务器协议（LSP）背后的思想是为这些服务器和开发工具的通信方式提供标准化协议支持。通过这种方式，可以在多个开发工具中重用单个 Language Server，而这些工具反过来可以用最少的工作支持多种语言。 例如，之前需要为 VSCode 构建 Go 插件、为 Sublime Text 构建 Go 插件、为 Vim 构建 Go 插件、为 Sourcegraph 构建 Go 插件，很多重复的工作。现在，对于每种语言，LSP 允许语言社区将精力集中在一个高性能语言服务器上，这个服务器可以提供代码完成，悬停文档提示、跳转到定义、查找引用等功能，而编辑器和客户端社区可以专注于构建一个单一的、高性能的、直观的和惯用的扩展，这个扩展可以与任何语言服务器通信，即时提供深入的语言支持。 LSP 是语言提供商和工具供应商的双赢！ LSP 的工作原理语言服务器（Language Server）作为单独的进程运行，开发工具在 LSP 基础上通过 JSON-RPC 与服务器通信。下面是一个开发工具和语言服务器在进行编辑时如何通信的例子：图片来自 LSP 官网，演示了协议如何在文档引用（uri）和文档位置级别与语言服务器通信。这些数据类型与编程语言无关，适用于所有编程语言。 How it works The user opens a file (referred to as a document) in the tool: The tool notifies the language server that a document is open (‘textDocument/didOpen’). From now on, the truth about the contents of the document is no longer on the file system but kept by the tool in memory. The contents now has to be synchronized between the tool and the language server. The user makes edits: The tool notifies the server about the document change (‘textDocument/didChange’) and the language representation of the document is updated by the language server. As this happens, the language server analyses this information and notifies the tool with the detected errors and warnings (‘textDocument/publishDiagnostics’). The user executes “Go to Definition” on a symbol of an open document: The tool sends a ‘textDocument/definition’ request with two parameters: (1) the document URI and (2) the text position from where the ‘Go to Definition’ request was initiated to the server. The server responds with the document URI and the position of the symbol’s definition inside the document. The user closes the document (file): A ‘textDocument/didClose’ notification is sent from the tool informing the language server that the document is now no longer in memory. The current contents are now up to date on the file system. 以下是在 C++ 文档中针对“Go to Definition”请求在开发工具和语言服务器之间传输的有效负载。 这是请求: 1234567891011121314{ \"jsonrpc\": \"2.0\", \"id\" : 1, \"method\": \"textDocument/definition\", \"params\": { \"textDocument\": { \"uri\": \"file:///p%3A/mseng/VSCode/Playgrounds/cpp/use.cpp\" }, \"position\": { \"line\": 3, \"character\": 12 } }} 这是响应： 1234567891011121314151617{ \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"uri\": \"file:///p%3A/mseng/VSCode/Playgrounds/cpp/provide.cpp\", \"range\": { \"start\": { \"line\": 0, \"character\": 4 }, \"end\": { \"line\": 0, \"character\": 11 } } }} gopls 是什么经过上面对 LSP 的介绍，你应该猜到 gopls（发音为“Go please”） 是什么了吧？！没错，gopls是由 Go 团队开发的官方 Go 语言服务器。它为任何 LSP 兼容的编辑器提供 IDE 功能。 在 LSP 官网列出了相关的实现，包括三个部分。 1、Language Servers：列出各个语言的 LSP 实现其中 Go 语言的实现有两个：（Sourcegraph 的不再维护，因为集中维护一个会更好） gopls 是 Go 官方维护的、对 LSP 的实现，即一个 Go 语言的官方 Language Server。 2、LSP Clients：列出支持 LSP 的开发工具包括 VSCode、Sublime Text、Atom、Emacs、Vim 和 Eclipse 等很多开发工具。在上文提到的两个网站都有列出。 3、SDKs for LSP：为了方便开发为了方便开发，还有一些 LSP 的 SDK 可以使用。具体可以查看：https://microsoft.github.io/language-server-protocol/implementors/sdks/。 进一步了解 gopls首先说明下，目前 gopls 还不是稳定版本，处于 alpha 状态，所以 VSCode 默认没有启用它。项目地址：https://github.com/golang/tools/tree/master/gopls。 目前 gopls 支持的特性包括： Autocompletion Jump to definition Signature help Hover Document symbols References Rename 目前已知存在如下的问题： Editing multiple modules in one editor window: #32394[1] Type checking does not work in cgo packages: #35721[2] Does not work with build tags: #29202[3] Find references and rename only work in a single package: #32877[4] 当前 gopls 的工作重点是确保稳定性（期待发布 1.0 版本），之前一直受诟骂的是资源占用，目前已经好太多了。 有如下编辑器支持 gopls，你可以根据自己喜爱的编辑器查看相应的安装、配置说明。 VSCode[5] Vim Neovim Vim/Neovim[6] Emacs[7] Acme[8] Sublime Text[9] Atom[10]","link":"/2023/02/02/LSP%E5%88%9D%E8%AF%86%E4%BB%A5%E5%8F%8Agopls%E6%98%AF%E4%BB%80%E4%B9%88/"},{"title":"初始Golang","text":"基本语法main.go12345678910package mainimport( \"fmt\")func main(){ fmt.Println(\"Hello World\")} Template包Template.go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import ( \"fmt\" \"text/template\" \"os\" \"regexp\")func main(){ fmt.Println(\"Hello Go !\") tdata := []info{ {\"abcabcabcfsdfsdfsdf\"}, {\"aaafsdgdfhergdfbdfgbdhdfgdg\"}, } replaceFuncMap := template.FuncMap{ \"replaceAll\":replaceAll, } tmpl, err := template.New(\"test\").Funcs(replaceFuncMap).Parse(` {{ range . }} // {{ .Info }} {{ replaceAll \"(aaaa)\" \"1111\" .Info | replaceAll \"(abc)\" \"【$1】\" | replaceAll \"(aaa)\" \"【$1】\" }} {{end}}`) if err != nil { panic(err) } err = tmpl.Execute(os.Stdout, tdata) if err != nil { panic(err) } var a string fmt.Scanln(&amp;a) fmt.Print(\"input\", a)}func replaceAll(from ,to, input string) string{ m1 := regexp.MustCompile(from) return m1.ReplaceAllString(input,to) // return strings.ReplaceAll(input,from ,to)}type info struct{ Info string} http 库","link":"/2023/02/03/%E5%88%9D%E5%A7%8BGolang/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"},{"name":"live2d","slug":"live2d","link":"/tags/live2d/"},{"name":"emoji","slug":"emoji","link":"/tags/emoji/"},{"name":"记录","slug":"记录","link":"/tags/%E8%AE%B0%E5%BD%95/"},{"name":"软件版本号","slug":"软件版本号","link":"/tags/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7/"},{"name":"ASP.Net MVC","slug":"ASP-Net-MVC","link":"/tags/ASP-Net-MVC/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Mail","slug":"Mail","link":"/tags/Mail/"},{"name":"发送邮件","slug":"发送邮件","link":"/tags/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"name":"ASP.NET","slug":"ASP-NET","link":"/tags/ASP-NET/"},{"name":"System.Net.Mail","slug":"System-Net-Mail","link":"/tags/System-Net-Mail/"},{"name":"邮件发送","slug":"邮件发送","link":"/tags/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"},{"name":"吐槽","slug":"吐槽","link":"/tags/%E5%90%90%E6%A7%BD/"},{"name":"感想","slug":"感想","link":"/tags/%E6%84%9F%E6%83%B3/"},{"name":"负能量","slug":"负能量","link":"/tags/%E8%B4%9F%E8%83%BD%E9%87%8F/"},{"name":"Technology","slug":"Technology","link":"/tags/Technology/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Oracle","slug":"Oracle","link":"/tags/Oracle/"},{"name":"教育","slug":"教育","link":"/tags/%E6%95%99%E8%82%B2/"},{"name":"成长","slug":"成长","link":"/tags/%E6%88%90%E9%95%BF/"},{"name":"命令行","slug":"命令行","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Gmail","slug":"Gmail","link":"/tags/Gmail/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"Postman","slug":"Postman","link":"/tags/Postman/"},{"name":"sqlserver","slug":"sqlserver","link":"/tags/sqlserver/"},{"name":"死锁","slug":"死锁","link":"/tags/%E6%AD%BB%E9%94%81/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"SQLlite","slug":"SQLlite","link":"/tags/SQLlite/"},{"name":"转载","slug":"转载","link":"/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"kettle","slug":"kettle","link":"/tags/kettle/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"速查表","slug":"速查表","link":"/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"},{"name":"ADO.NET","slug":"ADO-NET","link":"/tags/ADO-NET/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"v2ray","slug":"v2ray","link":"/tags/v2ray/"},{"name":"shadowsocks","slug":"shadowsocks","link":"/tags/shadowsocks/"},{"name":"vmess","slug":"vmess","link":"/tags/vmess/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"webservice","slug":"webservice","link":"/tags/webservice/"},{"name":"SOAP","slug":"SOAP","link":"/tags/SOAP/"},{"name":"IIS","slug":"IIS","link":"/tags/IIS/"},{"name":"sql server","slug":"sql-server","link":"/tags/sql-server/"},{"name":"字符编码","slug":"字符编码","link":"/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"name":"进制转换","slug":"进制转换","link":"/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"},{"name":"监控","slug":"监控","link":"/tags/%E7%9B%91%E6%8E%A7/"},{"name":"Prometheus","slug":"Prometheus","link":"/tags/Prometheus/"},{"name":"Grafana","slug":"Grafana","link":"/tags/Grafana/"},{"name":"Alert","slug":"Alert","link":"/tags/Alert/"},{"name":"DingTalk","slug":"DingTalk","link":"/tags/DingTalk/"},{"name":"XML Schema","slug":"XML-Schema","link":"/tags/XML-Schema/"},{"name":"DTD","slug":"DTD","link":"/tags/DTD/"},{"name":"Schema","slug":"Schema","link":"/tags/Schema/"},{"name":"xml","slug":"xml","link":"/tags/xml/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"2019-nCoV","slug":"2019-nCoV","link":"/tags/2019-nCoV/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Sql","slug":"Sql","link":"/tags/Sql/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Command","slug":"Command","link":"/tags/Command/"},{"name":"TLS","slug":"TLS","link":"/tags/TLS/"},{"name":"OpenSSL","slug":"OpenSSL","link":"/tags/OpenSSL/"},{"name":"self-signed certificates","slug":"self-signed-certificates","link":"/tags/self-signed-certificates/"},{"name":"加密","slug":"加密","link":"/tags/%E5%8A%A0%E5%AF%86/"},{"name":"Csharp","slug":"Csharp","link":"/tags/Csharp/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"PDI","slug":"PDI","link":"/tags/PDI/"},{"name":"Kettle","slug":"Kettle","link":"/tags/Kettle/"}],"categories":[{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"转载","slug":"转载","link":"/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"cranky","slug":"cranky","link":"/categories/cranky/"},{"name":"Technology","slug":"Technology","link":"/categories/Technology/"},{"name":"VUE","slug":"VUE","link":"/categories/VUE/"},{"name":"node","slug":"node","link":"/categories/node/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"other","slug":"other","link":"/categories/other/"},{"name":"Csharp","slug":"Csharp","link":"/categories/Csharp/"},{"name":"用户认证","slug":"用户认证","link":"/categories/%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"xml","slug":"xml","link":"/categories/xml/"},{"name":"运维","slug":"Tools/运维","link":"/categories/Tools/%E8%BF%90%E7%BB%B4/"},{"name":"lifestyle","slug":"lifestyle","link":"/categories/lifestyle/"},{"name":"摘录","slug":"摘录","link":"/categories/%E6%91%98%E5%BD%95/"}],"pages":[{"title":"其它","text":"其它","link":"/other/index.html"},{"title":"关于","text":"这是一个用来记录生活为主的Blog,请不要转载。声明：本博客中部分图片、文章来源于网络，版权归原作者所有， 如有侵权请联系删除。Email：selectitemc@gmail.com","link":"/about/index.html"}]}